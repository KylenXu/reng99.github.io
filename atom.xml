<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Reng の 博客</title>
  
  <subtitle>If you don&#39;t think, then you shouldn&#39;t talk.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://reng99.cc/"/>
  <updated>2018-07-08T14:43:39.880Z</updated>
  <id>http://reng99.cc/</id>
  
  <author>
    <name>嘉明</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重游广西阳朔</title>
    <link href="http://reng99.cc/2018/07/08/yangShuo-tourist-second/"/>
    <id>http://reng99.cc/2018/07/08/yangShuo-tourist-second/</id>
    <published>2018-07-08T14:22:02.000Z</published>
    <updated>2018-07-08T14:43:39.880Z</updated>
    
    <content type="html"><![CDATA[<p>时隔半年，周末(6.23-6.24)的时候又来到了阳朔，这次过来的阳朔是团队FEers一起来的，人多又是不同的一次体验，而且还遇上了下雨天气，又是不一番的景象。多图预警哈，啦啦啦～</p><a id="more"></a><p><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/yangShuoSecond/banner.jpg" alt="life/tourist/yangShuoSecond/banner"></p><blockquote><p>未完待续…</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时隔半年，周末(6.23-6.24)的时候又来到了阳朔，这次过来的阳朔是团队FEers一起来的，人多又是不同的一次体验，而且还遇上了下雨天气，又是不一番的景象。多图预警哈，啦啦啦～&lt;/p&gt;
    
    </summary>
    
      <category term="诗和远方" scheme="http://reng99.cc/categories/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
    
      <category term="旅游" scheme="http://reng99.cc/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript糟粕部分</title>
    <link href="http://reng99.cc/2018/07/08/javascript-rubbishy-part/"/>
    <id>http://reng99.cc/2018/07/08/javascript-rubbishy-part/</id>
    <published>2018-07-08T02:55:04.000Z</published>
    <updated>2018-07-08T09:03:34.568Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/javascript/rubbishy/banner.jpg" alt="frontend/javascript/rubbishy/banner"></p><p>JavaScript是一门优秀的语言，但是难免存在着某些缺点，本博文主要说明下JavaScript的一些缺点。</p><a id="more"></a><h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><p>JavaScript有两组相等的运算符：<code>===和!==</code>，以及他们邪恶的孪生兄弟<code>==和!=</code>。<code>===和!==</code>运算符能够按照你期望的方式工作。如果两个<strong>运算数类型一致且拥有相同的值</strong>，那么<code>===</code>就返回true，<code>!==</code>返回false。但是<strong>==和!=</strong>只有在两个运算符类型一致时才会做出正确的判断，如果两个运算数是不同的类型，他们试图去强制转换值的类型。转换的规则复杂难以记忆。下面的一些有趣的例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 传递性</span><br><span class="line">'0' == 0 # true</span><br><span class="line">0 == '' # true</span><br><span class="line">'' == '0' # false   为什么不是true呢</span><br><span class="line"></span><br><span class="line">false == 'false' # false</span><br><span class="line">false == 0 # true</span><br><span class="line"></span><br><span class="line">false == undefined # false</span><br><span class="line">false == null # false</span><br><span class="line">null == undefined # true</span><br><span class="line"></span><br><span class="line">'\t\r\n' == 0 # true</span><br></pre></td></tr></table></figure><p><code>==</code>运算符对<strong>传递性</strong>的缺乏值值得我们警惕。最好永远不要使用那对邪恶的孪生兄弟。相反的，请始终使用<code>===和!==</code>。如果上面的比较都是用<code>===</code>运算符，结果都是false，在编程中规定使用，很是受益。</p><p>⚠️传递性是一种编程约定。可以理解：对于任意的引用值x、y和z，如果x == y 和 y == z 为 ture，那么 x == z 为true。而JavaScript中的 == 运算符在某种特例上违背了传递性。</p><h2 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h2><p>JavaScript提供了一个with语句，本意是想使用它来快捷访问对象的属性。然而，它的结果可能有时不可预料，所以应该避免使用它。</p><p>下面的语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (obj)&#123;</span><br><span class="line">a = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和下面的代码做的是同样的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj.a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">a = obj.b === <span class="literal">undefined</span> ? b : obj.b;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">obj.a = obj.b === <span class="literal">undefined</span> ? b : obj.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，它等于这些语句中的一条：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = b;</span><br><span class="line">a = obj.b;</span><br><span class="line">obj.a = b;</span><br><span class="line">obj.a = obj.b;</span><br></pre></td></tr></table></figure><p>通过阅读代码，你不可能辨别出你会得到的是这些语句的那一条。它可能随着程序运行到下一步时发生变化。它甚至可能在程序运行过程中就发生了变化。如果你不能通过阅读程序就了解它将做什么，你就无法确信它会正确地做你想要做的事情。</p><p>with语句在JavaScript中存在，本身就<strong>严重影响了JavaScript处理器的速度</strong>，因为它阻断了变量名的语法作用域绑定。它的本意是好的，但是如果没有它，JavaScript语言会更好一点。</p><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>eval函数传递了一个字符串给JavaScript编译器，并且执行其结果。它是一个被滥用的JavaScript特性。那些对JavaScript语言一知半解的人们最常用到它。例如你知道点表示法，但是不知道下标表示法，就可能会这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"myValue = myObject."</span> + myKey + <span class="string">";"</span>);</span><br></pre></td></tr></table></figure><p>而不是这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvalue = myObject[myKey];</span><br></pre></td></tr></table></figure><p>使用eval形式的代码更加难以阅读。这种形式使得性能显著降低，因为它<strong>需要运行编译器</strong>，但也许只是为了执行一个微不足道的赋值语句。它也会让JSLint【⚠️JSLint是一个JavaScript语法检查器和校验器。】失效，让此工具检测问题的能力大打折扣。</p><p>eval函数还减弱了你的应用程序的安全性，带来XSS攻击，因为它被求值的文本授予了太多的权力。而且就像with语句执行的方式一样，它降低了语言的性能。</p><p>Function 构造器是eval的另一种形式，同样也应该避免使用它。</p><p>浏览器提供的setTimeout和setInterval函数，他们能够接受字符串参数或函数参数。当传递的是字符串参数时，setTimeout和setInterval会像eval那样去处理。同样也应该避免使用字符串参数形式。</p><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>continue语句跳转到循环的顶部。可对代码重构后，性能会得到一定的改善，看下面的代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> beginTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="keyword">var</span> loop = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; loop ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> endTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">console.log('耗费时间:'+ (endTime-beginTime)); # 58625</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> beginTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="keyword">var</span> loop = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; loop ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> endTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">console.log('耗费时间:'+ (endTime-beginTime)); # 58471</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> beginTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"><span class="keyword">var</span> loop = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; loop ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> endTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">console.log('耗费时间:'+ (endTime-beginTime)); # 56063</span><br></pre></td></tr></table></figure><h2 id="switch穿越"><a href="#switch穿越" class="headerlink" title="switch穿越"></a>switch穿越</h2><p>除非是明确中断流程，否则每次条件判断后都穿越到下一个case条件。在使用的时候要小心这种带刺的玫瑰，他们是有用的，也是危险的。</p><h2 id="缺少块的语句"><a href="#缺少块的语句" class="headerlink" title="缺少块的语句"></a>缺少块的语句</h2><p>If、while、do 或 for 语句可以接受一个括在花括号中的代码块，页可以接受单行语句。单行语句的形式是另一种带刺的玫瑰。它带来的好处是可以节省两个字节，但这是不是一个好处值得商榷。它模糊了程序的结构，使得在随后的操作代码中可能容易插入错误。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ok)</span><br><span class="line">t = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>可能变成:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ok)</span><br><span class="line">t = <span class="literal">true</span>;</span><br><span class="line">advance();</span><br></pre></td></tr></table></figure><p>它看起来就像要这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">t = <span class="literal">true</span>;</span><br><span class="line">advance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际上它的本意是这样的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">t = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">advance();</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">t = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">advance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>貌似是在做一件事情，但实际上是在做另一件事的程序是很难理解清楚的。团队中制定严格的规范要求始终使用代码块是得代码更加容易理解。</p><h2 id="–"><a href="#–" class="headerlink" title="++ –"></a>++ –</h2><p>递增和递减运算符使得程序员可以用非常简洁的风格去编码。比如在C语言中，它们使得用一行代码实现字符串的复制成为可能：</p><p><code>for(p = src, q = dest; *p; p++, q++) *q = *p;</code></p><p>事实上，这两个运算符鼓励了一种不够严谨的编码风格。大多数的缓冲区溢出错误所造成的安全漏洞，都是由像这样编码而导致的。</p><p>当使用<code>++ 和 --</code>时，代码往往过于拥挤、复杂和隐晦。因此，作为一条原则，我不再使用它们。团队上也可以规范一波，那样我们的代码风格会变得更加整洁。</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>JavaScript有着和Java相同的一套位运算符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;and 按位与</span><br><span class="line">|or 按位或</span><br><span class="line">^xor 按位异或</span><br><span class="line">~not 按位非</span><br><span class="line">&gt;&gt;带符号的右移动</span><br><span class="line">&gt;&gt;&gt;无符号的（用0补足的）右移动</span><br><span class="line">&lt;&lt; 左位移</span><br></pre></td></tr></table></figure><p>在Java中，位运算符处理的是整数。JavaScript没有整数类型，它只有双精度的浮点数。因此，位操作符吧它们的数字运算数先转换成整数，接着执行运算，然后再转换回去。在大多数语言中，这些运算符接近于硬件处理，所以非常快。但JavaScript的执行环境一般接触不到硬件，所以非常慢。JavaScript很少被用来执行位操作。</p><h2 id="function语句对比function表达式"><a href="#function语句对比function表达式" class="headerlink" title="function语句对比function表达式"></a>function语句对比function表达式</h2><p>JavaScript既有function语句，同时也有function表达式。这令人困惑，因为它们看起来好像是相同的。一个function语句就是其值为一个函数的var语句的速记形式。</p><p>下面的语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>意思相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>第二种写法相对友好，因为它明确表示foo是一个包含一个函数值的<strong>变量</strong>。要学好JavaScript这门语言，理解<strong>函数就是数值</strong>是很重要的。</p><p>function语句在解析时会发生被提升的情况，这意味着不管function被放置在哪里，它会被移动到被定义时所在作用域<code>顶层</code>。这就放宽了函数必须先声明后使用的要求，这会导致混乱的。在if语句中使用<code>function语句</code>也是被禁止的。结果表明大多数的浏览器都允许在if语句里使用function语句，但是它们在解析的时候处理上各不相同。这就造成了可移植性的问题。</p><p>一个语句不能以一个函数表达式开头，因为官方的语法假定以单词<code>function</code>开头的语句是一个<code>function</code>语句。解决的方法就是把函数调用括在一个圆括号中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> hidden_variable;</span><br><span class="line"></span><br><span class="line"># 这个函数可能对环境有一些影响，但是不会映入新的全局变量</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="类型的包装对象"><a href="#类型的包装对象" class="headerlink" title="类型的包装对象"></a>类型的包装对象</h2><p>JavaScript有一套类型的包装对象。例如：</p><p><code>new Boolean(false)</code></p><p>会返回一个对象，该对象有一个valueOf方法会返回被包装的值。这其实完全没有必要，并且有时还令人困惑。不要使用<code>new Boolean、new Number 或 new String</code>。</p><p>此外，页应该避免使用<code>new Object 和 new Array</code>。可使用<code>{} 和 []</code>来替代。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>JavaScript的new运算符创建了一个继承于其运算符的原型的新对象，然后调用该运算数，把新创建的对象绑定给this。这给运算数（它应该是一个构造函数）一个机会在返回给请求者自定义新创建对象。</p><p>如果忘记了使用此<code>new运算符</code>，你得到的就是一个普通的函数调用，并且this被绑定到全局对象，而不是新创建的对象。者意味着当你的函数尝试去初始化新成员属性时它将会污染全局变量。这是一件非常糟糕的事情。而且既没有编译时警告，也没有运行时警告。</p><p>按照惯例，<strong>打算与new结合使用的函数应该以首字母大写的形式命名</strong>，并且首字母大写的形式应该只用来命名那些构造器函数。这个约定帮助我们进行区分，便于我们发现那些Javascript语言自身经常忽略但是却带来昂贵代价的错误。</p><p>一个更好的应对方法策略是根本不去使用new。幻想下就行啦～</p><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>在很多语言中，void 是一种类型，表示没有值（空值）。<code>而在JavaScript中，void是一个运算符</code>，它接受一个运算数并且返回undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   a = <span class="keyword">void</span> ( a = <span class="number">90</span> );</span><br><span class="line">   document.write('a = ' + a); # a = undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这并没有什么用，而且令人非常困惑。应该避免使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《JavaScript语言精粹》Douglas Crockford著 赵泽欣 鄢学鹍 译</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/javascript/rubbishy/banner.jpg&quot; alt=&quot;frontend/javascript/rubbishy/banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;JavaScript是一门优秀的语言，但是难免存在着某些缺点，本博文主要说明下JavaScript的一些缺点。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="javascript" scheme="http://reng99.cc/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>CSS清除浮动</title>
    <link href="http://reng99.cc/2018/07/03/clear-float/"/>
    <id>http://reng99.cc/2018/07/03/clear-float/</id>
    <published>2018-07-03T04:59:16.000Z</published>
    <updated>2018-07-08T02:59:15.294Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/css/clear-float/banner.jpg" alt="frontend/css/clear-float/banner"></p><p>浮动对页面的影响：如果一个父盒子中有一个子盒子，并且子盒子没有设置高，子盒子在父盒子中进行浮动，那么将来父盒子的高度为0，由于父盒子的高度为0，下面的元素会自动补位，所以这个时候有必要进行浮动的清除。</p><a id="more"></a><p>下面代码来掩饰如何清除浮动：</p><p>原代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>清除浮动的方法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        .outer&#123;</span></span><br><span class="line"><span class="undefined">background: #999;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.red&#123;</span></span><br><span class="line"><span class="undefined">width:100px;</span></span><br><span class="line"><span class="undefined">height: 100px;</span></span><br><span class="line"><span class="undefined">background:red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.blue&#123;</span></span><br><span class="line"><span class="undefined">width:100px;</span></span><br><span class="line"><span class="undefined">height:100px;</span></span><br><span class="line"><span class="undefined">background: blue;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.other&#123;</span></span><br><span class="line"><span class="undefined">width:300px;</span></span><br><span class="line"><span class="undefined">height: 30px;</span></span><br><span class="line"><span class="undefined">background:yellow;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"other"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原效果：</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/css/clear-float/origin_clear_float.png" alt="frontend/css/clear-float/origin_clear_float"></p><p>为红色和绿色方块添加左浮动后</p><p>原代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>清除浮动的方法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">.outer&#123;</span></span><br><span class="line"><span class="undefined">background: #999;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.red&#123;</span></span><br><span class="line"><span class="undefined">float: left;</span></span><br><span class="line"><span class="undefined">width:100px;</span></span><br><span class="line"><span class="undefined">height: 100px;</span></span><br><span class="line"><span class="undefined">background:red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.blue&#123;</span></span><br><span class="line"><span class="undefined">float: left;</span></span><br><span class="line"><span class="undefined">width:100px;</span></span><br><span class="line"><span class="undefined">height:100px;</span></span><br><span class="line"><span class="undefined">background: blue;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.other&#123;</span></span><br><span class="line"><span class="undefined">width:300px;</span></span><br><span class="line"><span class="undefined">height: 30px;</span></span><br><span class="line"><span class="undefined">background:yellow;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"other"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其效果为–</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/css/clear-float/float_left.png" alt="frontend/css/clear-float/float_left"></p><h2 id="方法一：使用overflow属性来清除浮动"><a href="#方法一：使用overflow属性来清除浮动" class="headerlink" title="方法一：使用overflow属性来清除浮动"></a>方法一：使用overflow属性来清除浮动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.outer&#123;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先找到浮动盒子的父元素（盒子），在父元素中田间一个属性<code>overflow:hidden</code>，就是清除这个父元素中的子元素浮动对页面的影响。</p><p>效果如下：</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/css/clear-float/after_clear_float_method1.png" alt="frontend/css/clear-float/after_clear_float_method1"></p><p><strong>注意：</strong>一般情况下不会使用这种方式，因为<code>overfloat:hidden</code>有一个特点，离开了这个元素所在的区域之后会被隐藏（overflow:hidden会将超出的部分隐藏起来）。</p><h2 id="方法二：使用额外的标签"><a href="#方法二：使用额外的标签" class="headerlink" title="方法二：使用额外的标签"></a>方法二：使用额外的标签</h2><p>这又分两种情况–</p><h3 id="内部标签"><a href="#内部标签" class="headerlink" title="内部标签"></a>内部标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"other"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>放在浮动元素的父元素里面，效果如下图：</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/css/clear-float/after_clear_float_method1.png" alt="frontend/css/clear-float/after_clear_float_method1"></p><h3 id="外部标签"><a href="#外部标签" class="headerlink" title="外部标签"></a>外部标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"other"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>放在浮动元素父元素同级位置，最终效果如下：</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/css/clear-float/after_clear_float_method2.png" alt="frontend/css/clear-float/after_clear_float_method2"></p><p>这两种种清除的方式有下面的特点：</p><p>1.内部标签：会将这个浮动盒子的父盒子的高度重新撑开</p><p>2.外部标签：会将这个浮动盒子的影响清除，但是不会撑开父盒子。</p><p><strong>注意：</strong>⚠️一般情况下不会使用这种方式来清除浮动。因为这种清除浮动方式会增加页面的标签，造成机构混乱。</p><h2 id="方法三：使用伪元素-after"><a href="#方法三：使用伪元素-after" class="headerlink" title="方法三：使用伪元素:after"></a>方法三：使用伪元素:after</h2><p>outer利用其伪类<code>clear:after</code>在元素内部增加一个类似div.clear的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.outer &#123; /*==for IE6/7 Maxthon2  为了兼容IE==*/</span><br><span class="line">        zoom:1;</span><br><span class="line">    &#125;  </span><br><span class="line">.outer:after&#123;</span><br><span class="line">content:"."; /*可以取值，也可以为空*/</span><br><span class="line">clear:both;</span><br><span class="line">display: block;</span><br><span class="line">width:0;</span><br><span class="line">height: 0;</span><br><span class="line">visibility: hidden;／*visibility:hidden;的作用是允许浏览器渲染它，但是不显示出来*／</span><br><span class="line"></span><br><span class="line">　　　　　&#125;</span><br></pre></td></tr></table></figure><p>这是网上使用比较广泛，拉风的清除方式。</p><p>其效果如下：</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/css/clear-float/after_clear_float_method1.png" alt="frontend/css/clear-float/after_clear_float_method1"></p><h2 id="方法四：使用双伪元素清除浮动"><a href="#方法四：使用双伪元素清除浮动" class="headerlink" title="方法四：使用双伪元素清除浮动"></a>方法四：使用双伪元素清除浮动</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.outer &#123; /*==for IE6/7 Maxthon2  为了兼容IE==*/</span><br><span class="line">        zoom:1;</span><br><span class="line">    &#125;  </span><br><span class="line">.outer:after,.outer:before&#123;</span><br><span class="line">content:"."; /*取值只能为空*/</span><br><span class="line">clear:both;</span><br><span class="line">display: block;</span><br><span class="line">　　　　　&#125;</span><br></pre></td></tr></table></figure><p>其效果如下：</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/css/clear-float/after_clear_float_method1.png" alt="frontend/css/clear-float/after_clear_float_method1"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>第一种方法会将超出部分隐藏，在某些时候我们想清除浮动并且保留超出部分的时候做不到。</p><p>第二种方法会增加不必要的标签。</p><p>所以我们选择第三种方法来清除浮动。</p><p>为什么不选择第四种来清除呢？因为第四种是第三种的改良版，虽然比较简便，但是不够严谨，比如<code>content</code>的内容不为空的时候，会出现问题，感兴趣的话可以自行尝试下咯。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/css/clear-float/banner.jpg&quot; alt=&quot;frontend/css/clear-float/banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;浮动对页面的影响：如果一个父盒子中有一个子盒子，并且子盒子没有设置高，子盒子在父盒子中进行浮动，那么将来父盒子的高度为0，由于父盒子的高度为0，下面的元素会自动补位，所以这个时候有必要进行浮动的清除。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CSS浮动" scheme="http://reng99.cc/tags/CSS%E6%B5%AE%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>散列</title>
    <link href="http://reng99.cc/2018/06/18/algorithm-hash/"/>
    <id>http://reng99.cc/2018/06/18/algorithm-hash/</id>
    <published>2018-06-18T10:00:48.000Z</published>
    <updated>2018-06-26T15:05:08.388Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/algorithm/hash/banner.jpg" alt="algorithm/hash/banner"></p><p>散列是一种常用的数据存储技术，散列后的数据可以进行快速地插入或取用。散列使用的数据结构叫做散列表（hash table, 也叫哈希表）。在散列表中<strong>插入、删除和取用数据</strong>都非常快，但是对于查找操作来说却效率低下，比如查找一组数据中的最大或者最小值。</p><a id="more"></a><blockquote><p>散列算法的作用是尽可能快地在数据结构中找到一个值。在前面几个博文中提到的数据结构，我门如果在数据结构中获取一个值（使用get方法），需要遍历整个数据库来找到它。如果使用散列函数，就知道值的具体位置，因此你能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址。</p></blockquote><p>见下图的例子（散列函数这里取ascii值相加-电子邮件地址薄）：</p><p><img src="http://omu538iq8.bkt.clouddn.com/algorithm/hash/email-demo.png" alt="algorithm/hash/email-demo"></p><h2 id="创建一个散列表"><a href="#创建一个散列表" class="headerlink" title="创建一个散列表"></a>创建一个散列表</h2><p>搭建散列表类如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> table = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的散列函数如下（取上图的ascii值）:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> loseloseHashCode = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; key.length; i++)&#123;</span><br><span class="line">hash += key.charCodeAt(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash % <span class="number">37</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本完整代码"><a href="#基本完整代码" class="headerlink" title="基本完整代码"></a>基本完整代码</h2><p>hash表的简单demo的基本完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> loseloseHashCode = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; key.length; i++)&#123;</span><br><span class="line">hash += key.charCodeAt(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash % <span class="number">37</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> table = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向散列表中增加一个新的项（也能更新散列表）</span></span><br><span class="line"><span class="keyword">this</span>.put = <span class="function"><span class="keyword">function</span>(<span class="params">key , value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> position = loseloseHashCode(key);</span><br><span class="line"><span class="built_in">console</span>.log(position + <span class="string">' - '</span> + key);</span><br><span class="line">table[position] = value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回检索到的特定的值</span></span><br><span class="line"><span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> table[loseloseHashCode(key)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据键值从散列表中移除值</span></span><br><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">table[loseloseHashCode(key)] = <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="color:red;text-align:center;">业余时间补充…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/algorithm/hash/banner.jpg&quot; alt=&quot;algorithm/hash/banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;散列是一种常用的数据存储技术，散列后的数据可以进行快速地插入或取用。散列使用的数据结构叫做散列表（hash table, 也叫哈希表）。在散列表中&lt;strong&gt;插入、删除和取用数据&lt;/strong&gt;都非常快，但是对于查找操作来说却效率低下，比如查找一组数据中的最大或者最小值。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://reng99.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="散列" scheme="http://reng99.cc/tags/%E6%95%A3%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>字典</title>
    <link href="http://reng99.cc/2018/06/18/algorithm-dictionary/"/>
    <id>http://reng99.cc/2018/06/18/algorithm-dictionary/</id>
    <published>2018-06-18T05:08:26.000Z</published>
    <updated>2018-06-18T09:44:26.841Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/algorithm/dictionary/banner.jpg" alt="algorithm/dictionary/banner"></p><p>在字典中，存储的是[键,值]对，其中键名是用来查询特定元素的。字典和之前介绍的<a href="http://reng99.cc/2018/06/18/algorithm-set/">集合</a>很相似，集合以[值,值]的形式存储元素，字典则是以[键,值]的形式来存储元素。字典也称做映射。</p><a id="more"></a><h2 id="字典类"><a href="#字典类" class="headerlink" title="字典类"></a>字典类</h2><p>字典类和之前介绍的集合类一样，基本的骨架如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> items = &#123;&#125;; <span class="comment">// 存放数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>因为其和集合很是相似，部分的代码可以使用集合的代码，比如清空字典，字典的大小等等。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否存在键-值</span></span><br><span class="line"><span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value <span class="keyword">in</span> items;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 也可以是使用hasOwmProperty来实现</span></span><br><span class="line"><span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> items.hasOwnProperty(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置新元素</span></span><br><span class="line"><span class="keyword">this</span>.set = <span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</span><br><span class="line">items[key] = value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示字典的数据</span></span><br><span class="line"><span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 临时存放数据</span></span><br><span class="line"><span class="keyword">var</span> values = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> items)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.has(k))&#123;</span><br><span class="line">values.push(items[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> values;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除元素</span></span><br><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.has(key))&#123;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">delete</span> items[key];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取特定的项</span></span><br><span class="line"><span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.has(key) ? items[key] : <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空集合中所有值</span></span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">items = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取集合的数量</span></span><br><span class="line"><span class="comment">// 下面的实现是在现代浏览器才能使用，当然借助babel可以转换成所有浏览器识别的代码</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.keys(items).length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 所有浏览器都可以运行</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> items)&#123;</span><br><span class="line"><span class="keyword">if</span>(items.hasOwnProperty(prop))&#123;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的代码请查看<a href="https://github.com/reng99/algorithm" target="_blank" rel="noopener">https://github.com/reng99/algorithm</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/algorithm/dictionary/banner.jpg&quot; alt=&quot;algorithm/dictionary/banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;在字典中，存储的是[键,值]对，其中键名是用来查询特定元素的。字典和之前介绍的&lt;a href=&quot;http://reng99.cc/2018/06/18/algorithm-set/&quot;&gt;集合&lt;/a&gt;很相似，集合以[值,值]的形式存储元素，字典则是以[键,值]的形式来存储元素。字典也称做映射。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://reng99.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="字典" scheme="http://reng99.cc/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="http://reng99.cc/2018/06/18/algorithm-set/"/>
    <id>http://reng99.cc/2018/06/18/algorithm-set/</id>
    <published>2018-06-18T01:58:38.000Z</published>
    <updated>2018-06-18T04:17:14.496Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/algorithm/set/set-banner.jpg" alt="algorithm/set/set-banner"></p><p>集合(Set)是一种包含不同元素的数据结构。集合中的元素称为成员，集合的两个最重要的特性是：首先，集合中的成员是无序的；其次，集合中不允许相同成员的存在。</p><a id="more"></a><h2 id="集合的定义"><a href="#集合的定义" class="headerlink" title="集合的定义"></a>集合的定义</h2><ul><li>不包含任何成员的集合称为空集{}，全集则是包含一切可能成员的集合。</li><li>如何两个集合的成员完全相同，则称两个集合相等。</li><li>如果一个集合中所有的成员都属于另外一个集合，则前一集合称为后一个集合的子集。</li></ul><h2 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h2><p>对集合的操作基本是下面三种：</p><ol><li>并集: 将两个集合中的成员进行合并，得到一个新的集合。</li><li>交集: 两集合中共同存在的成员组成一个新的集合。</li><li>差集: 属于一个集合而不属于另一个集合的成员组成的集合。</li><li>子集: 验证一个给定集合是否是另一个集合的子集。</li></ol><h2 id="创建集合类"><a href="#创建集合类" class="headerlink" title="创建集合类"></a>创建集合类</h2><p>这里还是使用构造函数进行创建集合类:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// some code here ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们将使用对象来表示集合<code>var items = {}</code>，集合的键-值是相同的。当然，你也可以使用数组来表示，但是不够直观。而使用对象一个好处是，javascript的对象不允许一个键指向两个不同的属性，保证了集合里的元素都是唯一性的。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>基本的完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 选择对象而不是数组来表示集合</span></span><br><span class="line"><span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否存在键-值</span></span><br><span class="line"><span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value <span class="keyword">in</span> items;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 也可以是使用hasOwmProperty来实现</span></span><br><span class="line"><span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> items.hasOwnProperty(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">this</span>.has(value))&#123;</span><br><span class="line">items[value] = value;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取items对象，返回所有属性，以数组形式返回</span></span><br><span class="line"><span class="comment">// 下面的实现是在现代浏览器才能使用，当然借助babel可以转换成所有浏览器识别的代码</span></span><br><span class="line"><span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.keys(items);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 下面的实现在任何浏览器上可以运行</span></span><br><span class="line"><span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> keys = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> items)&#123;</span><br><span class="line">keys.push(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> keys;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除一个元素</span></span><br><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.has(value))&#123;</span><br><span class="line"><span class="keyword">delete</span> items[value];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空集合中所有值</span></span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">items = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取集合的数量</span></span><br><span class="line"><span class="comment">// 下面的实现是在现代浏览器才能使用，当然借助babel可以转换成所有浏览器识别的代码</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.keys(items).length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 所有浏览器都可以运行</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> items)&#123;</span><br><span class="line"><span class="keyword">if</span>(items.hasOwnProperty(prop))&#123;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">this</span>.union = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 定义一个并集</span></span><br><span class="line"><span class="keyword">var</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本集合对象</span></span><br><span class="line"><span class="keyword">var</span> values = <span class="keyword">this</span>.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.length; i++)&#123;</span><br><span class="line">unionSet.add(values[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已知的另外一个集合对象</span></span><br><span class="line">values = otherSet.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; values.length; i++)&#123;</span><br><span class="line">unionSet.add(values[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">this</span>.intersection = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 定义一个交集</span></span><br><span class="line"><span class="keyword">var</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = <span class="keyword">this</span>.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(otherSet.has(values[i]))&#123;</span><br><span class="line">intersectionSet.add(values[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">this</span>.difference = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 定义一个差集</span></span><br><span class="line"><span class="keyword">var</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = <span class="keyword">this</span>.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!otherSet.has(values[i]))&#123;</span><br><span class="line">differenceSet.add(values[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子集</span></span><br><span class="line"><span class="keyword">this</span>.subset = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 如果个数越界肯定不是子集了</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.size() &gt; otherSet.size())&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">var</span> values = <span class="keyword">this</span>.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.length ; i++)&#123;</span><br><span class="line"><span class="comment">// 只要有一个元素不再另外的集合里面，则不是子集</span></span><br><span class="line"><span class="keyword">if</span>(!otherSet.has(values[i]))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的代码请查看<a href="https://github.com/reng99/algorithm" target="_blank" rel="noopener">https://github.com/reng99/algorithm</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/algorithm/set/set-banner.jpg&quot; alt=&quot;algorithm/set/set-banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;集合(Set)是一种包含不同元素的数据结构。集合中的元素称为成员，集合的两个最重要的特性是：首先，集合中的成员是无序的；其次，集合中不允许相同成员的存在。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://reng99.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="集合" scheme="http://reng99.cc/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://reng99.cc/2018/06/17/algorithm-linked-list/"/>
    <id>http://reng99.cc/2018/06/17/algorithm-linked-list/</id>
    <published>2018-06-17T09:15:48.000Z</published>
    <updated>2018-06-17T15:43:39.028Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/algorithm/linked-list/banner.jpg" alt="algorithm/linked-list/banner"></p><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称为指针或链接，通常叫指针）组成。自己无聊的时候还翻译一点维基百科上的<a href="http://reng99.cc/2018/05/29/linked-list/">链表的介绍</a>。</p><a id="more"></a><h2 id="数组的缺点"><a href="#数组的缺点" class="headerlink" title="数组的缺点"></a>数组的缺点</h2><p>在<code>栈和队列</code>数据结构中，存储数据我们是使用了数组的形式。但是，数组不总是组织数据的最佳的结构。原因如下：</p><ol><li>数组被实现成对象，与其他语言（比如C++和Java）的数组相比，效率很低。【主要原因】</li><li>数组的长度是固定的，所以当数组已被数据填满的时，再要加入新的元素会非常困难。</li><li>从数组的起点或中间插入或移除项的成本很高。虽然<code>splice</code>等方法能帮方便的实现，但是背后的原理还是需要移动元素。</li></ol><p>所以，当数组的代价高的时候，需要考虑其他的数据结构，比如现在要说的链表。</p><h2 id="创建链表类"><a href="#创建链表类" class="headerlink" title="创建链表类"></a>创建链表类</h2><p>通过一个构造函数创建链表类:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// somecode here ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点数据也是使用一个类进行存放，这里我们叫做Node类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.element = element;</span><br><span class="line"><span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>链表的基本的完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助类</span></span><br><span class="line"><span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.element = element; <span class="comment">// 存放数据</span></span><br><span class="line"><span class="keyword">this</span>.next = <span class="literal">null</span>; <span class="comment">// 存放指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的长度</span></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化头指针为空</span></span><br><span class="line"><span class="keyword">var</span> head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向链表尾部追加元素</span></span><br><span class="line"><span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 创建一个node节点</span></span><br><span class="line"><span class="keyword">var</span> node = <span class="keyword">new</span> Node(element),</span><br><span class="line">current; <span class="comment">// 当前的指向节点/元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(head == <span class="literal">null</span>)&#123; <span class="comment">// 列表中的第一个节点</span></span><br><span class="line">head = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">current = head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环列表，直到找到最后一项</span></span><br><span class="line"><span class="keyword">while</span>(current.next)&#123;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到追后一项，将next赋值为node，建立链接</span></span><br><span class="line">current.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新链表的长度</span></span><br><span class="line">length++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表中移除元素,通过指定位置移除</span></span><br><span class="line"><span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span>(<span class="params">position</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 检查指定移除的position是否越界</span></span><br><span class="line"><span class="keyword">if</span>(position &gt; <span class="number">-1</span> &amp;&amp; position &lt; length)&#123; <span class="comment">// 未越界</span></span><br><span class="line"><span class="keyword">var</span> current = head, <span class="comment">// 当前元素指向头节点</span></span><br><span class="line"> previous, <span class="comment">// 上一个节点</span></span><br><span class="line"> index = <span class="number">0</span>; <span class="comment">// 节点的索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除第一项</span></span><br><span class="line"><span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</span><br><span class="line">head = current.next;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (index++ &lt; position)&#123;</span><br><span class="line">previous = current;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将previous与current的下一项链接起来：跳过current，从而移除它</span><br><span class="line">previous.next = current.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 链表长度减一</span><br><span class="line">length--;</span><br><span class="line"></span><br><span class="line">// 返回删除的元素</span><br><span class="line">return current.element;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">// position越界的情况</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 任意位置插入一个元素</span><br><span class="line">this.insert = function(position , element)&#123;</span><br><span class="line">// 检查position是否越界</span><br><span class="line">if(position &gt;= 0 &amp;&amp; position &lt;=length)&#123;</span><br><span class="line"></span><br><span class="line">var node = new Node(element), // 新建一个节点</span><br><span class="line">current = head, // 初始当前节点指向头节点</span><br><span class="line">previous, // 前一个节点</span><br><span class="line">index = 0; // 默认索引从第一个开始</span><br><span class="line"></span><br><span class="line">if(position == 0)&#123; // 在第一个位置添加元素</span><br><span class="line">node.next = current;</span><br><span class="line">head = node;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">while(index++ &lt; position)&#123;</span><br><span class="line">previous = current;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line">node.next = current;</span><br><span class="line">previous.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新列表长度</span><br><span class="line">length++;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125; else&#123;</span><br><span class="line">// position越界</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 将LinkedList对象转换成一个字符串</span><br><span class="line">this.toString = function() &#123;</span><br><span class="line">var current = head,</span><br><span class="line"> string = '';</span><br><span class="line"> </span><br><span class="line">while(current)&#123;</span><br><span class="line">string += current.element;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 查找元素在链表中的位置</span><br><span class="line">this.indexOf = function(element) &#123;</span><br><span class="line">var current = head;</span><br><span class="line">index = 0;</span><br><span class="line"></span><br><span class="line">while(current)&#123;</span><br><span class="line">if(element == current.element) &#123;</span><br><span class="line">return index;</span><br><span class="line">&#125;</span><br><span class="line">index++;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 找不到元素</span><br><span class="line">return -1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 链表中移除元素，通过指定移除的元素</span><br><span class="line">this.remove = function(element) &#123;</span><br><span class="line">var index = this.indexOf(element);</span><br><span class="line">return this.removeAt(index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 检查链表是否为空</span><br><span class="line">this.isEmpty = function() &#123;</span><br><span class="line">return length == 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 获取链表的长度</span><br><span class="line">this.size = function() &#123;</span><br><span class="line">return length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 获取链表的头节点</span><br><span class="line">this.getHead = function() &#123;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的代码请查看<a href="https://github.com/reng99/algorithm" target="_blank" rel="noopener">https://github.com/reng99/algorithm</a>。</p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>上面所说的链表是单链表。尽管从链表的头节点遍历到尾节点很简单，但反过来，从后向前遍历九没有那么简单了。这时候我们可以通过给Node对象增加一个头指针的属性就容易多了。</p><p>Node类就变成下面这样了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.element = element;</span><br><span class="line"><span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个双向链表的类如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoublyLinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.element = element;</span><br><span class="line"><span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">this</span>.prev = <span class="literal">null</span>; <span class="comment">// 新增的前指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> head = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> tail = <span class="literal">null</span>; <span class="comment">// 新增的尾节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// methods here ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其相关的方法和单链表的方法是大同小异，还有一个循环链表也是差不多啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/algorithm/linked-list/banner.jpg&quot; alt=&quot;algorithm/linked-list/banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称为指针或链接，通常叫指针）组成。自己无聊的时候还翻译一点维基百科上的&lt;a href=&quot;http://reng99.cc/2018/05/29/linked-list/&quot;&gt;链表的介绍&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://reng99.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="链表" scheme="http://reng99.cc/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="http://reng99.cc/2018/06/17/algorithm-queue/"/>
    <id>http://reng99.cc/2018/06/17/algorithm-queue/</id>
    <published>2018-06-17T05:11:08.000Z</published>
    <updated>2018-06-17T09:13:49.692Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/algorithm/queue/queue_banner.jpg" alt="algorithm/queue/queue_banner"></p><p>队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列在队尾添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。</p><a id="more"></a><h2 id="定义一个队列类"><a href="#定义一个队列类" class="headerlink" title="定义一个队列类"></a>定义一个队列类</h2><p>类似创建栈，创建队列也是使用构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 这里是属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存放数据也是使用一个数组<code>var items = []</code>。</p><h2 id="完整的基本代码"><a href="#完整的基本代码" class="headerlink" title="完整的基本代码"></a>完整的基本代码</h2><p>直接上基本的完整代码和相关的代码注释：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储数据的结构</span></span><br><span class="line"><span class="keyword">var</span> items = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队，相当于入栈</span></span><br><span class="line"><span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">items.push(element);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队，相当于出栈</span></span><br><span class="line"><span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item.shift();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队首，队列的第一个元素</span></span><br><span class="line"><span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾，队列的最后一个元素</span></span><br><span class="line"><span class="keyword">this</span>.end = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> items[items.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查队列是否是空的队列</span></span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> items.length == <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列置空</span></span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">items = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列的长度</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> items.lenght;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示/打印队列信息</span></span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(items.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的代码跟之前的<a href="http://reng99.cc/2018/06/16/algorithm-stack/">栈</a>的代码是大同小异，更多的代码请查看<a href="https://github.com/reng99/algorithm" target="_blank" rel="noopener">https://github.com/reng99/algorithm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/algorithm/queue/queue_banner.jpg&quot; alt=&quot;algorithm/queue/queue_banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列在队尾添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://reng99.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="队列" scheme="http://reng99.cc/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://reng99.cc/2018/06/16/algorithm-stack/"/>
    <id>http://reng99.cc/2018/06/16/algorithm-stack/</id>
    <published>2018-06-16T04:20:52.000Z</published>
    <updated>2018-06-17T04:58:10.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/algorithm/stack/stack_banner.jpg" alt="algorithm/stack/stack_banner"></p><p>栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保留在栈的末尾，称为栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都靠近栈底。</p><a id="more"></a><h2 id="定义一个栈类"><a href="#定义一个栈类" class="headerlink" title="定义一个栈类"></a>定义一个栈类</h2><p>使用构造函数来定义一个栈类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 各种属性和方法的声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义的存放的数据结构是数组。<code>var item = []</code>。</p><h2 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h2><p>数组本身就有方法push进来一个内容，这里也是使用这个方法，我们来写一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">items.push(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h2><p>pop也是数组的方法，表示出栈，这里也是使用pop为函数名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> items.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>还有方法，比如返回栈顶元素，检查是否是空栈等。这里不展开讲，下面全列出代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义存储的数据结构</span></span><br><span class="line"><span class="keyword">var</span> items = []; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈，返回新的数组</span></span><br><span class="line"><span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">items.push(element); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  出栈，弹出栈顶元素</span></span><br><span class="line"><span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item.pop();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line"><span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> items[items.length<span class="number">-1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否是空栈</span></span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> items.length == <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈元素的个数</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> items.length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示栈的元素</span></span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(items.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的代码请看<a href="https://github.com/reng99/algorithm" target="_blank" rel="noopener">https://github.com/reng99/algorithm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/algorithm/stack/stack_banner.jpg&quot; alt=&quot;algorithm/stack/stack_banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保留在栈的末尾，称为栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都靠近栈底。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://reng99.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈" scheme="http://reng99.cc/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>javascript基础 -- 内部分享</title>
    <link href="http://reng99.cc/2018/06/14/javascript-foundation/"/>
    <id>http://reng99.cc/2018/06/14/javascript-foundation/</id>
    <published>2018-06-14T15:29:27.000Z</published>
    <updated>2018-06-18T09:59:14.751Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/javascript/foundation/banner.jpg" alt="frontend/javascript/foundation/banner"></p><p>javascript不仅仅在前端比较重要（网页三剑客之一），在后端还是占有一席之地。本博文主要是介绍javascript的基础（主打es5标准）。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>编写<code>javascrip</code>脚本不需要任何特殊的软件或者环境的配置，一个普通的文本编辑器和一个web浏览器就可以了。</p><p>相关的可运行的代码示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="undefined">javascript goes here ...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">mark-up goes here ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Javascript的语法和Java与C++语言的语法非常相似。</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>在javascript中把各条语句放在不同的行上就可以分隔他们，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first statement</span><br><span class="line">second statement</span><br></pre></td></tr></table></figure><p>如果是想放在同一行上，就必须像下面这样用<strong>分号</strong>来分隔它们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">first statement; second statement;</span><br></pre></td></tr></table></figure><p>为了养成一个良好的编程习惯，建议每条语句后面都添加一个分号。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释能够有效得帮助你了解代码流程。在代码中扮演生活中的便条的角色，能够帮助看者弄清楚脚本到底在干什么。注释有多种方式，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 这是单行注释</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">这是多行注释</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">&lt;!--这是在html页面中的注释--&gt;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>javascript是松散型语言，在es6标准之前，其变量都是以<code>var</code>来进行定义。es6后就支持let，const等，这是后话了，这里主讲es5。当变量没有var定义的时候，浏览器会自动追加，但是，在不赋值的情况下会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a; <span class="comment"># Uncaught ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line">var a ; <span class="comment"># output is 'undefined'</span></span><br><span class="line"></span><br><span class="line">a = 100 ; <span class="comment"># 100 相当于var a = 100;</span></span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>javascript中数据类型<code>包括基本类型和引用类型</code>。基本类型是指简单的数据段，包括<code>Undefined, Null, Boolean, Number 和 String</code>；引用类型指那些可能由多个值构成的对象。我们可以使用typeof操作符进行检验：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'undefined'</span> <span class="comment"># 值未定义</span></span><br><span class="line"><span class="string">'boolean'</span> <span class="comment"># 布尔值</span></span><br><span class="line"><span class="string">'string'</span> <span class="comment"># 字符串</span></span><br><span class="line"><span class="string">'number'</span> <span class="comment"># 数值</span></span><br><span class="line"><span class="string">'object'</span> <span class="comment"># 值是对象或null , null 是历史遗留下来的问题</span></span><br><span class="line"><span class="string">'function'</span> <span class="comment"># 这个值是函数</span></span><br></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>要用javascript做一些有用的工作，需要能够进行计算和处理数据。也就是完成一些操作。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>简单的数字加减乘除就不多说了。数字的自加，自减也省略下。不过<code>+</code>号挺有意思的一个运算符号。它可以简单的数字的相加，也可以用于字符串的拼接，和数字转字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 + 20  <span class="comment"># 30</span></span><br><span class="line"><span class="string">'你好'</span>+<span class="string">'name'</span> <span class="comment"># 你好name</span></span><br><span class="line">10 + <span class="string">''</span> <span class="comment"># 10</span></span><br><span class="line">10 + <span class="string">'20'</span> <span class="comment"># 1020</span></span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>基本的条件语句的语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>javascript提供了许多在条件语句里面使用的比较操作符，包括大于，小于，等于等等。返回的是一个布尔值。</p><p>还有一些逻辑运算符，比如&amp;&amp;和||等。</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>相对于条件语句，循环语句能够多次重复的执行代码。只要给定的条件满足，包含在循环语句里的代码就重复执行下去，一旦给定条件的求值结果不再是true，循环也就到此为止。</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>相关的基本语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">statements;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">statements;</span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环重复执行一些代码也很方便，它类似于while循环。可以将while循环的代码改写下，称为for循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">initialize;</span><br><span class="line"><span class="keyword">while</span> (condition)&#123;</span><br><span class="line">statements;</span><br><span class="line">increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改写</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(initial condition; test condition; alter condition)&#123;</span><br><span class="line">statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数就是一组允许在你的代码里随时调用的语句。每个函数实际上就是一个短小的脚本。但是函数声明于函数表达式的调用又有所差别，见下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">//TypeError: sum is not a function</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析器会率先读取函数声明，并使其执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析。函数中有一个闭包的概念，感兴趣的可戳<a href="http://reng99.cc/2018/03/01/javascript-high-level/">这里</a>。</p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM，文档对象模型。</p><p><strong>文档：DOM中的D</strong>当创建了一个网页并把它加载到web浏览器中时，DOM就在幕后悄然而生了。浏览器会将你编写的网页文档转换成为一个文档对象。</p><p><strong>对象：DOM中的O</strong>与某个特定对象相关联的变量被称为这个对象的属性。只能通过某个特定的对象去调用的函数被称为这个对象的方法。document对象的主要功能就是处理网页内容。</p><p><strong>模型：DOM中的M</strong>DOM中的<code>M</code>代表了<code>Model</code>(模型)，但是说它代表着<code>Map</code>（地图）也未尝不可。模型也好，地图也罢，它们的含义都是某种事物的表现形式。就像一个模型火车代表一列真正的火者。DOM代表着加载到浏览器窗口的当前网页。浏览器提供了网页的地图（或者说模型），而我们可以通过javascript去读取这张地图。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>在DOM里面有很多的节点，这里介绍三种：元素节点、文本节点和属性节点。</p><p><strong>元素节点：</strong>DOM的原子就是元素节点。比如<html>元素。</html></p><p><strong>文本节点：</strong>比如</p><p>content</p>种标签包含的content。<p></p><p><strong>属性节点：</strong>属性节点用来对元素作出更具体的描述。比如:</p><p title="name">mike</p>中的<code>title=&quot;name&quot;</code>就是属性节点了。<p></p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>有三种DOM方法可以获取元素节点，分别是通过元素ID、通过标签名字和通过类名字来获取。 </p><p><strong>getElementById</strong> 这个方法返回一个与那个有着给定id属性值的元素节点对应的对象。如<code>document.getElementById(&#39;home&#39;)</code></p><p><strong>getElmentsByTagName</strong> 这个方法返回一个对象数组，每个对象分别对应文档里有着给定标签的一个元素。如<code>document.getElementsByTagName(&#39;li&#39;)</code></p><p><strong>getElementsByClassName</strong> 这个方法能让我们通过class属性来访问元素。如<code>document.getElementsByClassName(&#39;item&#39;)</code></p><p>当然我们还是可以通过<code>querySelector,querySelectorAll</code>来获取元素的，比如querySelector(‘.item’),它返回与该匹配模式的第一个元素，即类名是item的元素；querySelectorAll(‘.item’),返回的是一个NodeList实例。</p><h3 id="获取和设置属性"><a href="#获取和设置属性" class="headerlink" title="获取和设置属性"></a>获取和设置属性</h3><p>在获取到元素后，我们就可以设法获取它的属性。getAttribute方法就是用来做这件事的。相应的，setAttribute方法则可以更改属性节点的值。</p><p><strong>getAttribute</strong>用法是<code>object.getAttribute(attribute)</code>，如下例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paras = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paras.length; i++)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(paras[i].getAttribute(<span class="string">'title'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>setAttribute</strong>用法是<code>object.setAttribute(attribute,value)</code>。它允许我们对属性节点的值作出修改。与getAttribute一样，setAttribute也只能用于元素节点。例子有：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shopping = <span class="built_in">document</span>.getElementById(<span class="string">'purchases'</span>);</span><br><span class="line">shopping.setAttribute(<span class="string">'title'</span>,<span class="string">'a list of goods'</span>);</span><br></pre></td></tr></table></figure><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>BOM，浏览器对象模型。</p><p>关于BOM具体指的是什么，可以参考DOM的解析。</p><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window有双重的角色，它既是通过javascript访问浏览器窗口的一个<code>接口</code>，又是规定的全局(Global)对象。这就意味着在网页中定义的任何一个对象，变量和函数，都是以window作为Global对象，因此有权访问parseInt()等方法。</p><p><strong>窗口位置</strong></p><p>用来确定和修改window对象位置的属性和方法很多。IE、Safari、Opera和Chrome（也可以说Trident内核、Webkit内核、Presto内核-&gt;目前废弃，改Blink内核、Blink内核）都提供了screenLeft和screenTop属性，分别表示<code>用于窗口相对屏幕左边和上边的位置</code>。Firefox（可以说是Gecko内核）则在screenX和screenY属性中提供相同的窗口信息，Safari和Chrome也同时支持这两个属性。Opera虽然也是支持screenX和screenY属性，但与screenLeft和screenTop属性并不对应。附上内核的说明<a href="https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/10602413?fr=aladdin" target="_blank" rel="noopener">链接</a>。使用下列代码可以兼容到不同的浏览器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">'number'</span>) ? <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">'number'</span>) ? <span class="built_in">window</span>.screenTop : wnidow.screenY;</span><br></pre></td></tr></table></figure><p><strong>窗口大小</strong></p><p>跨浏览器确定窗口大小不是一件容易的事情。虽然五大浏览器(上面<code>窗口位置</code>提到的浏览器就是了)都提供了innerWidth、innerHeight、outerWidth和outerHeight四个属性，但是不同浏览器和不同版本的相同浏览器的解析又是不一样。在 IE9+、Safari 和 Firefox 中，outerWidth 和 outerHeight 返回浏览器窗口本身的尺寸(无论是从最外层的 window 对象还是从 某个框架访问)。在 Opera 中，这两个属性的值表示页面视图容器1的大小。而 innerWidth 和 innerHeight 则表示该容器中页面视图区的大小(减去边框宽度)。在 Chrome 中，outerWidth、outerHeight 与 innerWidth、innerHeight 返回相同的值，即视口(viewport)大小而非浏览器窗口大小。</p><p>IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性;不过，它通过 DOM 提供了页面可见区域 的相关信息</p><p>虽然确定不了浏览器的大小，但是我们可以确定页面视口的大小。五大浏览器中，document.documentElement.clientWidth和document.documentElement.clientHeight上保存了页面视口的信息。在IE6中，这些属性必须在 标准模式下才有效;如果是混杂模式，就必须通过 document.body.clientWidth 和 document.body. clientHeight 取得相同信息。整个的兼容的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>)&#123; <span class="comment">// 针对IE8及以下版本</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">'CSS1Compat'</span>)&#123; <span class="comment">// 标准模式下的低版本ie</span></span><br><span class="line">pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123; <span class="comment">// 混杂模式下的IE,Chrome</span></span><br><span class="line">pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>导航和打开窗口</strong></p><p>window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>,<span class="string">"_blank"</span>,<span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</span><br><span class="line"># 参数一是url</span><br><span class="line"># 窗口名称</span><br><span class="line"># 窗口样式设置</span><br></pre></td></tr></table></figure><p>更多内容感兴趣自己了解啦。</p><p><strong>间歇调用和超时调用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 间歇调用</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">'hello'</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"># 超时调用</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">'hello'</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><strong>系统对话框</strong></p><p>浏览器通过alert(),confirm()和prompt()方法调用系统对话框向用户显示信息。在浏览器的控制台上面走一遍就知道了。</p><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>location对象是一个很特别的对象，因为它既是window对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。location对象的用处不只表现在它保存当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。比如，hash,host,hostname,href,pathname,port,protocol,search。</p><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象提供了与浏览器有关的信息。到底提供了哪些新秀，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如userAgent）存在于所有浏览器中。更多的属性请戳<a href="http://www.runoob.com/jsref/obj-navigator.html" target="_blank" rel="noopener">这里</a></p><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为 history 是 window 对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的 history 对象与特定的 window 对象关联。</p><p>使用go()方法可以在用户的历史浏览记录中任意跳转。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 后退一页</span><br><span class="line">history.go(-1); # 可以写成history.back()</span><br><span class="line"></span><br><span class="line"># 前进一页</span><br><span class="line">history.go(1); # 可以写成history.forward()</span><br><span class="line"></span><br><span class="line"># 前进两页</span><br><span class="line">history.go(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>内部分享就到这里为止吧！自己之前有整理过一个《javascript高级程序设计》的内容，感兴趣请戳<a href="http://reng99.cc/2018/03/01/javascript-high-level/">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/javascript/foundation/banner.jpg&quot; alt=&quot;frontend/javascript/foundation/banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;javascript不仅仅在前端比较重要（网页三剑客之一），在后端还是占有一席之地。本博文主要是介绍javascript的基础（主打es5标准）。&lt;/p&gt;
    
    </summary>
    
      <category term="技术交流" scheme="http://reng99.cc/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="javascript" scheme="http://reng99.cc/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>d3js学习</title>
    <link href="http://reng99.cc/2018/06/09/d3js-learning/"/>
    <id>http://reng99.cc/2018/06/09/d3js-learning/</id>
    <published>2018-06-09T12:26:17.000Z</published>
    <updated>2018-06-13T11:14:07.964Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/d3/banner.jpg" alt="frontend/d3/banner"></p><p>D3.js是一个基于数据处理文档的JavaScript库。D3帮助你使用HTML,<a href="http://www.w3school.com.cn/svg/" target="_blank" rel="noopener">SVG</a>和CSS将数据呈现出来。D3依赖于标准的web技术来绘制可视化的元素。</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>D3允许你将任意的数据绑定到文档对象模型(DOM)，然后将数据驱动的转换应用到文档中。比如，可以使用D3将数组数据生成一个HTML文档。或者，使用相同的数据创建具有平滑过渡和交互的交互式SVG条形图。</p><p>D3不是一个旨在提供所有可能功能的单一框架。相方的，D3解决了问题的关键：根据数据有效地处理文档。这就避免了专有代理，并提供了非凡的灵活性，展示了诸如HTML，SVG和CSS等网络标准的全部功能。以最小的开销，D3非常快，支持大数据集和动态行为以进行交互和动画。D3的功能风格允许通过各种官方和开发社区模块来重复使用代码。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>使用W3C DOM API修改文档是很乏味的：方法名是冗长的，并且命令式的方法需要手动迭代和记账临时状态。比如下面改变段落的文字颜色：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> paragraph first <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> paragraph second <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>paragraph third <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> paragraphs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++)&#123;</span><br><span class="line"><span class="keyword">var</span> paragraph = paragraphs.item(i);</span><br><span class="line"> paragraph.style.setProperty(<span class="string">'color'</span>,<span class="string">'blue'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D3采用了一种声明式的方法，使用选择(selection)操作任意的节点集合。比如，我们可以重写上面的循环，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">d3.selectAll('p').style('color','blue'); # 有点类似jquery的$('p')</span><br></pre></td></tr></table></figure><p>当然，我们也可以根据需要操作单个节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">d3.select(<span class="string">'body'</span>).style(<span class="string">'background-color'</span>,<span class="string">'black'</span>);</span><br></pre></td></tr></table></figure><p>选择器依据W3C选择器API定义，并被现代浏览器很好的支持。</p><p>D3提供了许多用于改变节点的方法：设置属性或样式；注册时间监听器；添加、删除或排序节点；和更改HTML或文字的内容。这些满足绝大多数需求。直接访问底层DOM也是可能的，因为每个D3选择只是一个节点数组。</p><h2 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h2><p>熟悉其他DOM框架(如jquery)的读者能够立即意识到与D3的相似的地方。然而，D3中的样式，属性(attributes)和其他属性(properties)可以指定为数据的函数，而不仅仅是简单的常量。尽管它们看起来简单，但是这些功能很是强大。比如这个<a href="https://github.com/d3/d3-shape" target="_blank" rel="noopener">d3-shape</a>。</p><p>下面来个例子，随机指定段落的颜色：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">d3.selectAll(<span class="string">'p'</span>).style(<span class="string">'color'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"># H: Hue 色相(0-360) S：Saturation 饱和度(0-100) L Lightness 明度(0-100)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hsl("</span> + <span class="built_in">Math</span>.random() * <span class="number">360</span> + <span class="string">",100%,50%)"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>指定奇偶节点的灰色阴影的交替：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">d3.selectAll(<span class="string">'p'</span>).style(<span class="string">'color'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d , i</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> i % <span class="number">2</span> ? <span class="string">'#fff'</span> : <span class="string">'#eee'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>计算属性通常指的是绑定数据。数据被指定是一个值数组，并且每个值都被作为第一个参数（d）传递给选择函数。使用默认的索引连接，数据数组中的第一个元素被传递给选择中的第一个节点，第二个元素被传递给第二个选择中的第二个节点，以此类推。比如，将数组数据绑定到段落元素中，就可以使用这些数据来动态计算字体的大小了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">d3.selectAll(<span class="string">'p'</span>)</span><br><span class="line">.data([<span class="number">8</span>,<span class="number">16</span>,<span class="number">20</span>])</span><br><span class="line">.style(<span class="string">'font-size'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> d + <span class="string">'px'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一旦数据绑定之后，我们就是可以省略数据运算符了；D3将检索先前绑定的数据。这允许我们重新计算属性而不需要重新绑定。</p><h2 id="Enter-和-Exit"><a href="#Enter-和-Exit" class="headerlink" title="Enter 和 Exit"></a>Enter 和 Exit</h2><p>使用D3的进入和退出选择，可以为传入的数据创建新节点，并删除不需要的传出节点。当数据绑定到选择器的时候，数组数据中的每个元素都与选择中的对应节点配对。如果节点的数量少于数据，则额外的数据形成输入选择，我们可以通过追加输入选择来实例。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">d3.select(<span class="string">'body'</span>)</span><br><span class="line">.selectAll(<span class="string">'p'</span>)</span><br><span class="line">.data([<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">42</span>])</span><br><span class="line">.enter().append(<span class="string">'p'</span>)</span><br><span class="line">.text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;<span class="keyword">return</span> <span class="string">"I'm number "</span> + d + <span class="string">"!"</span>;&#125;)</span><br></pre></td></tr></table></figure><p>更新节点是默认选择–数据运算符的结果。因此，如果忘记了enter和exit选择器，你将只会自动选择存在的相应数据的元素。一种常见的模式是将初始选择分为三部分：要更新的更新节点，要添加的输入节点以及要移除的现有节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Updata...</span></span><br><span class="line"><span class="keyword">var</span> p = d3.select(<span class="string">'body'</span>)</span><br><span class="line">.selectAll(<span class="string">'p'</span>)</span><br><span class="line">.data([<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">42</span>])</span><br><span class="line">.text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enter...</span></span><br><span class="line">p.enter().append(<span class="string">'p'</span>)</span><br><span class="line">.text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exit...</span></span><br><span class="line">p.exit().remove();</span><br></pre></td></tr></table></figure><p>通过分别处理这三种情况，我们可以准确地指定在哪些节点上运行哪些操作。这可以提高性能并提供对转换的更好控制。例如，对条形图，我们可以使用旧比例初始化输入条，然后将输入条更新为新比例以及退出。</p><p>D3让我们能根据数据来转换成文档，包括创建和销毁元素。D3允许我们更改现有文档以响应用户交互，动画，和来自第三方的异步通知。</p><h2 id="Transformation-not-Representation"><a href="#Transformation-not-Representation" class="headerlink" title="Transformation, not Representation"></a>Transformation, not Representation</h2><p>D3没有引入新的视图表现.与<a href="https://processing.org/" target="_blank" rel="noopener">Processing</a>或<a href="https://mbostock.github.io/protovis/" target="_blank" rel="noopener">Protovis</a>不同，D3的图形标记词汇直接来自Web标准：HTML，SVG和CSS。例如，你可以使用D3创建SVG元素并使用外部的样式进行设置。你可以使用复合的滤镜效果，虚线描边和裁剪，如果浏览器供应商明天提出新功能，我们可以立马使用上–无需更新工具包。而且，如果我们将来决定使用D3以外的工具包，可以自身请整合。</p><p>最重要的是，D3易于浏览器的内置元素检查器进行调试：我们使用D3操作的节点恰好是浏览器本身理解的节点。</p><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>随着时间的推移，过渡逐渐应用到样式和属性中。可以通过一些令人舒服的效果，比如“弹性”，“立方体进出”和“线性效果”来控制补间。</p><p>比如，背景颜色渐变为黑色：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">d3.select(<span class="string">'body'</span>).transition()</span><br><span class="line">.style(<span class="string">'background-color'</span>,<span class="string">'black'</span>);</span><br></pre></td></tr></table></figure><p>再比如，使用延时策略来更改圆圈的大小：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">d3.selectAll(<span class="string">'circle'</span>).transition()</span><br><span class="line">.duration(<span class="number">750</span>)</span><br><span class="line">.delay(<span class="function"><span class="keyword">function</span>(<span class="params">d ,i</span>) </span>&#123; <span class="keyword">return</span> i * <span class="number">10</span>&#125;)</span><br><span class="line">.attr(<span class="string">'r'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(d * scale)&#125;)</span><br></pre></td></tr></table></figure><p>通过只修改实际改变的属性，D3减少了开销，并允许在高帧率时具有更高的图形复杂度。D3还允许通过事件对复杂转换进行排序。而且，你仍然可以CSS3转换。</p><h2 id="一些常用的api讲解"><a href="#一些常用的api讲解" class="headerlink" title="一些常用的api讲解"></a>一些常用的api讲解</h2><h3 id="数组Arrays-d3-array"><a href="#数组Arrays-d3-array" class="headerlink" title="数组Arrays(d3-array)"></a>数组Arrays(d3-array)</h3><p><strong>统计</strong></p><ul><li>d3.min 数组中最小值</li><li>d3.max 数组中最大值</li><li>d3.extent 数组中数据的范围</li><li>d3.sum 数组数据的总和</li><li>d3.mean 数组中算数平均值</li><li>d3.median 数组数据的中位数</li><li>d3.quantile 一个排好序的数字数组的分位数</li><li>d3.variance 数字数组的方差</li><li>d3.deviation 一组数据的标准差</li></ul><p><strong>查找</strong></p><ul><li>d3.scan 对指定的数据执行线性扫描，根据指定的比较器返回最小元素的索引</li><li>d3.bisect 通过二分法获取某个数在排好序中的数组中插入的位置（同d3.bisectRight）</li><li>d3.bisectRight 通过二分法获取某个数在排好序的数组中的插入位置（相等的值归右边）</li><li>d3.bisectLeft 通过二分法获取某个数在排好序的数组中的插入位置（相等的值归左边）</li><li>d3.bisector 自定义一个二等分访问器或比较器</li><li>d3.ascending 比较两个数是否升序</li><li>d3.descending 比较两个数是否降序</li></ul><p><strong>变换</strong></p><ul><li>d3.cross 获取两个数组的笛卡尔积</li><li>d3.merge 合并多个数组为一个数组</li><li>d3.pairs 根据相临的元素合并成数组</li><li>d3.permute 根据数组索引重排数组</li><li>d3.shuffle 随机排序数组（打乱数组排列）</li><li>d3.ticks 从数字区间生成代表值</li><li>d3.tickIncrement 同上</li><li>d3.tickStep 同上</li><li>d3.range 生成一个数值的范围</li><li>d3.transpose 转置二位矩阵</li><li>d3.zip 转置可变数量的数组</li></ul><p><strong>矩形图</strong></p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>虽然D3没有明文规定一定要在缩放矢量图形（SVG,Scalable Vector Graphics）中绘图，但是D3提供了众多的SVG图形生成器，它们都是只支持SVG的。因此，建议使用SVG画布,而SVG除了IE8之前的版本外，现代浏览器都支持。如果你要支持IE8以及IE8-的话，建议使用<a href="http://echarts.baidu.com/" target="_blank" rel="noopener">ECharts</a>，其使用了canvas。</p><p style="text-align:center;color: #f00;font-size: 14px;">精力有限，未能一次更新完…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/d3/banner.jpg&quot; alt=&quot;frontend/d3/banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;D3.js是一个基于数据处理文档的JavaScript库。D3帮助你使用HTML,&lt;a href=&quot;http://www.w3school.com.cn/svg/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SVG&lt;/a&gt;和CSS将数据呈现出来。D3依赖于标准的web技术来绘制可视化的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="d3js" scheme="http://reng99.cc/tags/d3js/"/>
    
  </entry>
  
  <entry>
    <title>从前慢</title>
    <link href="http://reng99.cc/2018/05/30/slow-in-past/"/>
    <id>http://reng99.cc/2018/05/30/slow-in-past/</id>
    <published>2018-05-30T05:32:26.000Z</published>
    <updated>2018-05-30T06:19:33.803Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/life/poem/slow-in-past/cover.jpg" alt="life/poem/slow-in-past/cover"></p><p>从前的日光很慢</p><p>车，马，邮件很慢</p><p>一生只够爱一个人</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Time was slower <span class="keyword">in</span> the past,</span><br><span class="line">Carriage, horse, mail needs time a little bit.</span><br><span class="line">Even one greeting needs days to be passed</span><br><span class="line">从前的日子很慢，</span><br><span class="line">车，马，邮件很慢</span><br><span class="line">一个问候，要等上好几天</span><br><span class="line"></span><br><span class="line">The moonlight was slower <span class="keyword">in</span> the past</span><br><span class="line">With leisure, being indolent</span><br><span class="line">The whole dawn needs a cup of tea to interpret</span><br><span class="line">With little stars twinkling,</span><br><span class="line">moments <span class="keyword">in</span> your dreams move fast</span><br><span class="line">从前的月光很慢</span><br><span class="line">有点闲，有点懒</span><br><span class="line">在一杯茶里消磨了整个黄昏</span><br><span class="line">在半个梦里看星星满天</span><br><span class="line"></span><br><span class="line">The pace was slower <span class="keyword">in</span> the past</span><br><span class="line">From one village to another near it</span><br><span class="line">One needs a whole day on foot</span><br><span class="line">从前的脚步好慢</span><br><span class="line">从一个村子</span><br><span class="line">到另一个村子</span><br><span class="line">要走上一天的时间</span><br><span class="line"></span><br><span class="line">The days were slower</span><br><span class="line">but warmer <span class="keyword">in</span> the past</span><br><span class="line">Through a touch of light mist</span><br><span class="line">Year after year, time is out.</span><br><span class="line">从前的日子很慢很暖</span><br><span class="line">裹在淡淡的烟火里</span><br><span class="line">日日年年</span><br><span class="line"></span><br><span class="line">The handerchiefs were finer <span class="keyword">in</span> the past</span><br><span class="line">Young ladies with soft eyebrows</span><br><span class="line"><span class="keyword">in</span> their perfect fit</span><br><span class="line">stitch by stitch,</span><br><span class="line">more delicate</span><br><span class="line">从前的手帕也很好看</span><br><span class="line">最是那低眉的女子</span><br><span class="line">精致的，一针一线</span><br><span class="line"></span><br><span class="line">It took time to fall <span class="keyword">in</span> love <span class="keyword">in</span> the past</span><br><span class="line">So slow, one needs one<span class="string">'s lifetime</span></span><br><span class="line"><span class="string">seeking for Mr/Ms Right</span></span><br><span class="line"><span class="string">So slow, you need your whole life</span></span><br><span class="line"><span class="string">to love people that suit</span></span><br><span class="line"><span class="string">从前的爱情很慢</span></span><br><span class="line"><span class="string">慢的，用一辈子去等一个人</span></span><br><span class="line"><span class="string">慢的，一生只爱一个人</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Now with everything on the go,</span></span><br><span class="line"><span class="string">one gets up earlier a little bit</span></span><br><span class="line"><span class="string">No time to say good morning,</span></span><br><span class="line"><span class="string">even a hug you cannot wait</span></span><br><span class="line"><span class="string">现在快</span></span><br><span class="line"><span class="string">快到每天早早起床</span></span><br><span class="line"><span class="string">来不及说早安</span></span><br><span class="line"><span class="string">来不及拥抱</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In fact, in the city center,</span></span><br><span class="line"><span class="string">even 5 minutes'</span> on foot</span><br><span class="line">Or a bit of leisure time</span><br><span class="line">after your breakfast</span><br><span class="line">Everything is different</span><br><span class="line">其实</span><br><span class="line">在中成，市中心，5分钟</span><br><span class="line">茶余饭后的那一点点闲暇时光</span><br><span class="line">就变了一个样</span><br><span class="line"></span><br><span class="line">Now is faster</span><br><span class="line">everything is <span class="keyword">in</span> the replacement</span><br><span class="line">So fast that life is easily to be parted</span><br><span class="line">even you cannot notice it</span><br><span class="line">现在快</span><br><span class="line">什么都在更新换代</span><br><span class="line">快到将生活扰得七零八落</span><br><span class="line"></span><br><span class="line">In fact, cluttered life can be combined </span><br><span class="line">by one after one highlight</span><br><span class="line">Like the classical furnishings </span><br><span class="line">mixed with modern decorations</span><br><span class="line"><span class="keyword">in</span> a sample apartment</span><br><span class="line">Less dull, less stale, much more exquisite</span><br><span class="line">其实，杂乱的生活也可以拼凑出一个个美好</span><br><span class="line">就像样板间里带着古典气息的摆设</span><br><span class="line">和现代化装修的搭一起</span><br><span class="line">少了分沉闷古旧</span><br><span class="line">多了份细腻</span><br><span class="line"></span><br><span class="line">Now time flies faster,</span><br><span class="line">just keep the pace after complaint</span><br><span class="line">Strive <span class="keyword">for</span> your dream </span><br><span class="line">with your daring heart</span><br><span class="line">Embrace your leisure time </span><br><span class="line">until you are old but not <span class="keyword">in</span> the past</span><br><span class="line">Why not plan <span class="keyword">for</span> your future earlier </span><br><span class="line">to some extent?</span><br><span class="line">现在快，抱怨几句，仍要跟上节奏</span><br><span class="line">朝着自己的梦想，再努把力</span><br><span class="line">把从前的悠闲搬到老年时享受</span><br><span class="line">其实，何不早早规划未来？</span><br><span class="line"></span><br><span class="line">Now is faster, dating with your love, </span><br><span class="line">after dinner no time left</span><br><span class="line">In fact, time is innocent, </span><br><span class="line">but it is all your mind’s fault</span><br><span class="line">现在快，与恋人约会</span><br><span class="line">吃个饭，没了时间</span><br><span class="line">其实</span><br><span class="line">与时间无关</span><br><span class="line">是心理在作祟</span><br><span class="line"></span><br><span class="line">With a peaceful mind, </span><br><span class="line">walking around the Bell Tower </span><br><span class="line"><span class="keyword">in</span> the old street</span><br><span class="line">Choosing a book <span class="keyword">in</span> the county library, </span><br><span class="line">wandering <span class="keyword">in</span> the old avenue on foot</span><br><span class="line">You forget time has vanished</span><br><span class="line">怀着一份平和</span><br><span class="line">从钟楼老街溜达一圈</span><br><span class="line">县图书馆选本书</span><br><span class="line">老巷子里逛一逛</span><br><span class="line">老了时光 </span><br><span class="line"></span><br><span class="line">Now is faster, </span><br><span class="line">so fast that we always recall </span><br><span class="line">beauty <span class="keyword">in</span> the past</span><br><span class="line">Passionately think of the world </span><br><span class="line">once <span class="keyword">in</span> its purest</span><br><span class="line">现在快，</span><br><span class="line">快到我们总是回忆起以前的美</span><br><span class="line">然后疯狂想念那些纯净的世界</span><br><span class="line"></span><br><span class="line">In fact, <span class="keyword">for</span> your current anguish, beat it</span><br><span class="line">Go to the North Square, </span><br><span class="line">and close your eyes <span class="keyword">in</span> a moment</span><br><span class="line">overwhelming yourself </span><br><span class="line">with those golden days <span class="keyword">in</span> the past</span><br><span class="line">Enjoy yourself with nothing <span class="keyword">in</span> your heart</span><br><span class="line">其实，暂且搁置现在的烦闷</span><br><span class="line">去到北广场，然后闭上双眼</span><br><span class="line">任那些美好将自己淹没</span><br><span class="line">放空那个美好的世界享受下就好</span><br><span class="line"></span><br><span class="line">It is good to be an ordinary person at hard thought</span><br><span class="line">When you said slow pace is fine, </span><br><span class="line">I back you a lot</span><br><span class="line">其实想想，做个中庸的人也不错</span><br><span class="line">你说慢节奏生活好，我附和着</span><br><span class="line"></span><br><span class="line">When he told fast pace adds more spice to life , </span><br><span class="line">I agree without second thought</span><br><span class="line">Like mansion with its luxury, </span><br><span class="line">tiny apartment with its refinement</span><br><span class="line">Good or bad, tell me not</span><br><span class="line">他说快节奏生活刺激，我也赞同</span><br><span class="line">就像小公寓精致，大宅奢阔</span><br><span class="line">各有千秋，委实难分好坏</span><br><span class="line"></span><br><span class="line">No matter how slow the past time was, </span><br><span class="line">how fast it is <span class="keyword">in</span> the current</span><br><span class="line">无论从前有多慢</span><br><span class="line">无论现在有多快</span><br><span class="line"></span><br><span class="line">I know, the earth under your feet,</span><br><span class="line">the love around your heart</span><br><span class="line">Treasure them with your best,</span><br><span class="line">no matter <span class="keyword">in</span> the past </span><br><span class="line">or <span class="keyword">in</span> the right moment.</span><br><span class="line">我知道，脚下的土地和身边的爱人</span><br><span class="line">无论从前还是现在</span><br><span class="line">都要尽全力守护和珍惜</span><br><span class="line"></span><br><span class="line">-- 木心</span><br></pre></td></tr></table></figure><p>我知道，脚下的土地和身边的爱人</p><p>无论从前还是现在</p><p>都要尽全力守护和珍惜</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/life/poem/slow-in-past/cover.jpg&quot; alt=&quot;life/poem/slow-in-past/cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;从前的日光很慢&lt;/p&gt;
&lt;p&gt;车，马，邮件很慢&lt;/p&gt;
&lt;p&gt;一生只够爱一个人&lt;/p&gt;
    
    </summary>
    
      <category term="诗和远方" scheme="http://reng99.cc/categories/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
    
      <category term="诗" scheme="http://reng99.cc/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://reng99.cc/2018/05/29/linked-list/"/>
    <id>http://reng99.cc/2018/05/29/linked-list/</id>
    <published>2018-05-29T10:42:37.000Z</published>
    <updated>2018-06-17T09:44:08.982Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/translation/linked_list/banner.jpg" alt="translation/linked_list/banner"></p><p>在计算机科学领域，链表就是一组数据的线性集合，这种集合的顺序不是根据数据被存放在内存中的顺序决定的。而是根据每个元素的指向下一个的指针决定。</p><a id="more"></a><p>链表是由类队列的一组节点组合而成的数据。每个节点包括了数据和一个指向下一个节点的指针。这种结构在对数据的添加和移除是非常方便的，不管数据所在的位置。</p><p><img src="http://omu538iq8.bkt.clouddn.com/translation/linked_list/data.png" alt="translation/linked_list/data"></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><p>相比数组，链表因为使用指针来存储会更耗内存</p></li><li><p>链表的节点必须是从头开始按照顺序读取，因为它本质上就是顺序访问</p></li><li><p>节点不连续存储，大大增加了访问列表中元素的所需的时间端，尤其在cpu的缓存中</p></li><li><p>当反向便利链表的时候会比较困难。比如，单链表向后导航比较麻烦，而双链表比较容易阅读，内存消耗在为后向指针分配空间</p></li></ul><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><p>链表中的每条记录通常被称为<code>元素或节点</code>（一般叫节点）。</p><p>每个节点的字段包含下一个节点的的地址，这个字段通常被叫做<code>下个链接或者下个指向</code>（一般叫指针）。剩下的字段被称为<code>数据，信息，值，负载或者载荷</code>（一般称为值）。</p><p>列表的头是它的第一个节点，列表的尾部可以指除头节点后其余部分，或者指列表最后的一个节点。</p><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>单链表包含数据字段和指向下个节点的尾指针字段。可以在单链表上执行的操作包括插入，删除和遍历。</p><p><img src="http://omu538iq8.bkt.clouddn.com/translation/linked_list/data.png" alt="translation/linked_list/data"></p><p>以下的代码演示了如何将具有数据<code>值</code>的新节点添加到单链表的末尾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">node addNode(node head , int value)&#123;</span><br><span class="line">node temp,p; // 声明两个节点temp和p</span><br><span class="line">temp = createNode(); // 假设方法createNode创建一个data=0和指向空的指针节点</span><br><span class="line">temp-&gt;data = value; // 添加元素的值到创建的节点data字段</span><br><span class="line"><span class="keyword">if</span>(head == NULL)&#123;</span><br><span class="line">head = temp; // 当链表尾空时</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">p = head; // head节点赋值给p节点</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != NULL)&#123;</span><br><span class="line">p = p-&gt;next; // 遍历链表到最后一个节点。最后一个节点的指向为空</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>在双向链表中，节点中除了指向下一个节点的指针，还包含指向序列中上一个节点的指针字段。</p><p><img src="http://omu538iq8.bkt.clouddn.com/translation/linked_list/double_linkedl_list.png" alt="translation/linked_list/double_linkedl_list"></p><p>许多现代操作系统使用双向链接列表来维护。</p><h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><p>和计算机编程和设计中的大多数选择一样，没有一种方法是可以适用多种情况的。链表数据结构可能在一种情况下运行良好，在另外一个情况下就有问题了。下面列表是包含链表的数据结构的权衡。</p><p><img src="http://omu538iq8.bkt.clouddn.com/translation/linked_list/list_compare.png" alt="translation/linked_list/list_compare"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/Linked_list" target="_blank" rel="noopener">维基百科link_list</a></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>自己在维基百科上查找到的介绍，然后翻译了一丢丢，链接请见上面的参考。翻译到此为止，如果看者感兴趣可以自行查看啦 @～@</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/translation/linked_list/banner.jpg&quot; alt=&quot;translation/linked_list/banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;在计算机科学领域，链表就是一组数据的线性集合，这种集合的顺序不是根据数据被存放在内存中的顺序决定的。而是根据每个元素的指向下一个的指针决定。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://reng99.cc/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="链表" scheme="http://reng99.cc/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>TCP的三次握手和四次挥手</title>
    <link href="http://reng99.cc/2018/05/01/tcp-three-handshake-four-bandge/"/>
    <id>http://reng99.cc/2018/05/01/tcp-three-handshake-four-bandge/</id>
    <published>2018-05-01T10:36:17.000Z</published>
    <updated>2018-05-11T14:54:58.843Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/network/tcp/handshake3_bandge4.jpg" alt="network/tcp/handshake3_bandge4.jpg"></p><p>UDP（用户数据报协议）和TCP（传输控制协议）都是传输层的协议，但是前者无连接，不安全，而后者提供面向链接的服务，倡导网络安全的环境下，还是推荐使用TCP。然而，TCP里面的知识点够啃一丢丢的时间了，这里只是解析TCP的三次握手和四次挥手啦😊</p><a id="more"></a><h2 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h2><p>TCP报文段首部的前20个字节是固定的，后面的有4n字节是根据需要而增加的选项（n是整数）。因此TCP首部的最小长度是20字节。见下图：</p><p><img src="http://omu538iq8.bkt.clouddn.com/network/tcp/tcp_header_desc.png" alt="network/tcp/tcp_header_desc.png"></p><p>相关字段的意义：</p><h3 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h3><p>分别写入源端口号和目的端口号。</p><h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须再链接建立时设置。首部中的序号字段值则指的是<strong>本报文段</strong>所发送的数据的第一个字节序号。比如，一段报文的序号字段值是301，而携带的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，而最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文的序号字段值为401.这个字段的名称也叫做<strong>报文段序号</strong>。</p><h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>是<strong>期望收到对方下一个报文段的第一个数据字节的序号。</strong></p><p>例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（501～700），这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B再发送给A的确认报文段中把确认号置为701。注意⚠️：现在的确认号不是501，也不是700，而是701。</p><p>总之：</p><p><code>若确认号 = N ，则表明：到序号 N - 1 为止的所有数据都已经正确收到。</code></p><h3 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h3><p>指出<strong>TCP报文段的数据起始处</strong>距离<strong>TCP报文段的起始处</strong>有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。但是应该注意，<strong>数据偏移</strong>的单位是32位字（即以4字节长的字位计算单位）。由于4位二进制数能够表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大长度（即选项长度不能超过40字节）。</p><h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><p>占六位，保留为今后使用，但目前应该置为0。</p><h3 id="紧急-URG-URGent"><a href="#紧急-URG-URGent" class="headerlink" title="紧急 URG(URGent)"></a>紧急 URG(URGent)</h3><p>当<code>URG = 1</code>时，表明紧急指针字段有效。它告诉系统次报文段中有紧急数据，应尽快传送（相当于高优先级的数据），而不要按原来的排队顺序来传送。</p><p>例如：已经发送了很长的一个程序要在远地的主机上运行。但是后来发现了一些问题，需要取消该程序的运行。因此用户从键盘发出中断命令（control + c）。如果在所有的数据被处理完毕后这两个字符才被交付接收方的应用程序。这样做就浪费了许多时间。</p><p>当URG置1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的<strong>最前面</strong>，而在紧急数据后面的数据仍然是普通数据。这时要与首部中<strong>紧急指针(Urgent Pointer)</strong>字段配合使用。</p><h3 id="确认-ACK-ACKnowlegment"><a href="#确认-ACK-ACKnowlegment" class="headerlink" title="确认 ACK(ACKnowlegment)"></a>确认 ACK(ACKnowlegment)</h3><p>仅当<code>ACK = 1</code>时确认号字段才有效。当<code>ACK = 0</code>时，确认号无效。TCP 规定，在连接建立后所有传送报文段都必须把ACK置1。</p><h3 id="推送PSH（PuSH）"><a href="#推送PSH（PuSH）" class="headerlink" title="推送PSH（PuSH）"></a>推送PSH（PuSH）</h3><p>当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令行后立即就能够收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文，就尽快地（即“推送”向前）交付接受应用进程，<code>而不再等到整个缓存都填满了后再向上交付</code>。</p><h3 id="复位-RST-ReSeT"><a href="#复位-RST-ReSeT" class="headerlink" title="复位 RST(ReSeT)"></a>复位 RST(ReSeT)</h3><p>当<code>RST = 1</code>时，表明TCP连接中出现严重差错（如有雨主机奔溃或其他原因），必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位。</p><h3 id="同步SYN-SYNchronization"><a href="#同步SYN-SYNchronization" class="headerlink" title="同步SYN(SYNchronization)"></a>同步SYN(SYNchronization)</h3><p>在连接建立时用来同步序号。当<code>SYN = 1而ACK = 0</code>时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应的报文中使<code>SYN = 1和ACK = 1</code>。因此，SYN置为1就表示这是一个连接请求或连接接收报文。</p><h3 id="终止-FIN-FINis"><a href="#终止-FIN-FINis" class="headerlink" title="终止 FIN(FINis)"></a>终止 FIN(FINis)</h3><p>用来释放一个连接。当<code>FIN = 1</code>时，表明此报文段的发送方的数据已发送完毕，并要求释放运输链接。</p><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>窗口指的是发送本报文段的一方的<strong>接收窗口</strong>（而不是自己的发送窗口）。窗口值<strong>告诉对方</strong>：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。之所以要有这个限制，是因为接收方的数据缓存空间有限的。总之，<strong>窗口值作为接收方让发送方设置其发送窗口的依据</strong></p><p>例如，设确认号是701，窗口字段是1000。这就表明，从701号算起，发送此报文段的一方还有接收1000个字节数据（字节号是701-1700）的接收缓存空间。</p><p>总而言之：<strong>窗口字段明确指出了现在允许对方发送的数据量。窗口值是经常在动态变化着。</strong></p><h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><p>检验和字段检验的范围包括首部和数据这两部分。</p><h3 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h3><p>紧急指针只有在<strong>URG=1</strong>时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>长度可变，最长可达40字节。当没有使用<strong>选项</strong>时，TCP的首部长度是20字节。</p><h2 id="TCP的链接建立（三次握手）"><a href="#TCP的链接建立（三次握手）" class="headerlink" title="TCP的链接建立（三次握手）"></a>TCP的链接建立（三次握手）</h2><p>B的TCP服务器进程先创建传<code>输控制块TCP</code>，准备接收客户A进程的链接请求。然后服务器进程就处于LISTEN（接收）状态，等待客户的连接请求。如有，即作出响应。</p><p style="color: red;text-align:center;">精力有限，未能一次更新完，亲见谅…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/network/tcp/handshake3_bandge4.jpg&quot; alt=&quot;network/tcp/handshake3_bandge4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;UDP（用户数据报协议）和TCP（传输控制协议）都是传输层的协议，但是前者无连接，不安全，而后者提供面向链接的服务，倡导网络安全的环境下，还是推荐使用TCP。然而，TCP里面的知识点够啃一丢丢的时间了，这里只是解析TCP的三次握手和四次挥手啦😊&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://reng99.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="tcp" scheme="http://reng99.cc/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>前端安全</title>
    <link href="http://reng99.cc/2018/04/13/frontend-security/"/>
    <id>http://reng99.cc/2018/04/13/frontend-security/</id>
    <published>2018-04-12T17:09:42.000Z</published>
    <updated>2018-07-04T15:35:31.232Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/javascript/frontend_security_banner.jpg" alt="frontend/javascript/frontend_security_banner"></p><p>哈哈哈，本来想在本博文中进行前端安全的讲解的，无奈在断断续续整理的一段时间后…</p><a id="more"></a><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>写了一段文字后，发现安全的信息全放在一篇博文中讲述，hold不住，所以会分解进行个人理解。主要是分为下面的几点————</p><p>⚠️ 链接会在后续添加</p><ul><li><p>点击劫持</p></li><li><p>CSRF攻击</p></li><li><p>XSS攻击</p></li><li><p>DDos攻击</p></li><li><p>SQL注入</p></li><li><p>文件上传漏洞</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>某诺同事分享文档</p></li><li><p>图解HTTP</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/javascript/frontend_security_banner.jpg&quot; alt=&quot;frontend/javascript/frontend_security_banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;哈哈哈，本来想在本博文中进行前端安全的讲解的，无奈在断断续续整理的一段时间后…&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="安全" scheme="http://reng99.cc/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解原型对象和原型链</title>
    <link href="http://reng99.cc/2018/04/05/prototype-object-chain-md/"/>
    <id>http://reng99.cc/2018/04/05/prototype-object-chain-md/</id>
    <published>2018-04-05T07:52:31.000Z</published>
    <updated>2018-04-12T07:36:11.686Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/javascript/prototype_object_chain.jpg" alt="frontend/javascript/prototype_object_chain"></p><p>原型对象和原型链在前端的工作中虽然不怎么显式的使用到，但是也会隐式的使用了，比如使用的jquery，vue等啦。在进入正题的时候，我们还是需要明白什么是<code>__proto__</code>，<code>prototype</code>等知识点，主要讲解构造函数，这篇博文大多是问答形式进行…</p><a id="more"></a><h2 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h2><h3 id="Javascript创建对象的方式？"><a href="#Javascript创建对象的方式？" class="headerlink" title="Javascript创建对象的方式？"></a>Javascript创建对象的方式？</h3><p>也许你会说出<code>工厂模式、构造函数模式、原型模式、组合使用构造函数和原型模式、动态原型模式、寄生构造函数模式和稳妥构造函数</code>这些，但是我们可以对他们进行以下归类–属于函数创建对象。</p><p>我们可以简单的将创建对象的方式分为三种：<code>函数创建对象、字面量创建、Object创建</code>。当然，也可以只是分成两类：<code>函数创建对象和字面量创建对象</code>，因为<code>new Object()</code>中的Object是本身就是一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="comment">// f Object()&#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="什么是prototype"><a href="#什么是prototype" class="headerlink" title="什么是prototype?"></a>什么是prototype?</h3><p><code>function</code>(注意是function哦)定义的对象有一个prototype属性，prototype属性又指向了一个prototype对象，注意prototype属性与prototype对象是两个不同的东西，要注意区别。用伪代码表示如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">function</span></span>&#123;</span><br><span class="line">prototype: prototype&#123;&#125; <span class="comment">// function的prototype属性指向prototype对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面说的是<code>function</code>里面才会有prototype属性，而我们new出来的对象里面是没有的哦。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># function</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fun.prototype <span class="comment">// &#123;constructor:f&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> Fun(<span class="string">'嘉明'</span>);</span><br><span class="line">fun.prototype <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"># Object</span><br><span class="line"><span class="built_in">Object</span>.prototype <span class="comment">// &#123;constructor:f,__defineGetter__:f,...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">object.prototype <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"># 字面量，字面量可以理解没有prototype啦</span><br><span class="line"><span class="keyword">var</span> jack = &#123;&#125;;</span><br><span class="line">jack.prototype <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="proto是什么？"><a href="#proto是什么？" class="headerlink" title="proto是什么？"></a><strong>proto</strong>是什么？</h3><p>在官方的es5种，定义了一个名叫做[[prototype]]的属性，每个对象(除了null)都拥有这样一个属性，这个属性是一个指针，它指向一个名叫做原型对象的内存堆。而原型对象也是一个对象，因此又含有自己的[[prototype]]属性，又指向下一个原型对象，终点指向我们的<code>Object.prototype</code>对象。</p><p>注意⚠️ 这里使用的是[[prototype]]，而并非<strong>proto</strong>。可是他们是同一个东西哈：[[prototype]]是官方所定义的属性，而<strong>proto</strong>是浏览器（就是任性）自己对[[prototype]]所做的实现。</p><p>分三种情况来说对象内部的<code>__proto__</code>：</p><ol><li>使用字面量定义一个普通对象: var foo = {}</li><li>创建一个函数: function Foo(){};<code>包含Object()啦</code></li><li>创建对象实例: var foo = new Foo();</li></ol><p>情况一：{}</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;&#125;;</span><br><span class="line">foo.__proto__; <span class="comment">// &#123;&#125;</span></span><br><span class="line">foo.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line">foo.hasOwnProperty(<span class="string">'prototype'</span>); <span class="comment">// false 函数才有prototype属性</span></span><br><span class="line">foo.hasOwnProperty(<span class="string">'__proto__'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty(<span class="string">'__proto__'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>代码的最后一行，一个是返回了false，另一个是true。⚠️<code>因为它并不存在于foo对象(foo.__proto__)或者Foo.prototype（Foo.prototype.__proto__）或者Foo（Foo.__proto__）中【下面情况二和三会有代码验证】</code>，实际上，它是来自于<strong>Object.prototype</strong>，与其说是一个属性，不如说是一个getter/setter。</p><p>情况二：function Foo(){}</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="number">2.</span> Foo.__proto__; <span class="comment">// [Function]</span></span><br><span class="line"><span class="number">3.</span> Foo.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// false</span></span><br><span class="line"><span class="number">4.</span> Foo.__proto__.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="number">5.</span> Foo.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true 函数的原型对象指向</span></span><br><span class="line"><span class="number">6.</span> Foo.__proto__ == Foo.prototype; <span class="comment">//false</span></span><br><span class="line"><span class="number">7.</span> Foo.hasOwnProperty(<span class="string">'__proto__'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="number">8.</span> Foo.hasOwnProperty(<span class="string">'prototype'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在函数中，通过上面代码<code>2，3，4，5</code>可以知道Foo.<strong>proto</strong>可以理解为指向了Foo.prototype(广义上理解)，而实际上两个又有差别（狭义上，第6点可以说明，欢迎补充）。然后就是每个函数都有一个默认的<code>prototype</code>属性，其指向函数的原型对象。</p><p>情况三：对象实例 new Foo()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.__proto__; <span class="comment">// Foo &#123;&#125;</span></span><br><span class="line">foo.__proto__ === Foo.prototype ; <span class="literal">true</span></span><br><span class="line">foo.hasOwnProperty(<span class="string">'prototype'</span>); <span class="literal">false</span></span><br><span class="line">foo.hasOwnProperty(<span class="string">'__proto__'</span>); <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面可知，实例中是没有<code>prototype</code>这个属性的，对比上面的三种情况，也说明了只有在函数中才默认创建了<code>prototype</code>属性，而且指向了相应的函数原型对象。</p><h3 id="constructor是什么？"><a href="#constructor是什么？" class="headerlink" title="constructor是什么？"></a>constructor是什么？</h3><p>在javascript语言中，constructor属性是专门为function而设计的，它存在于每一个function的prototype属性中，这个constructor保存了指向function的一个引用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># javascript内部会执行如下的动作</span><br><span class="line"># 1.为该函数添加一个原型（即prototype）属性</span><br><span class="line"># 2.为prototype对象额外添加一个constructor属性，并且该属性保存指向函数F的一个引用</span><br></pre></td></tr></table></figure><p>对象的实例中也有一个constructor属性（从prototype那里获取的），每一个对象实例都可以通过constructor对象访问它的构造函数，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.constructor === F; <span class="comment">// true</span></span><br><span class="line">f.constructor === F.prototype.constructor; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>既然可以访问实例的类型<code>f.constructor</code>，那么我们就可以对实例进行特殊的处理啦：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f.constructor == F)&#123;</span><br><span class="line"><span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过别这样操作，因为constructor是不稳定的（见下文对象中的constructor的作用是什么呢？），一般不会采取上面的这种操作，而是通过<code>instanceof</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line"><span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象中的constructor的作用是什么呢？"><a href="#对象中的constructor的作用是什么呢？" class="headerlink" title="对象中的constructor的作用是什么呢？"></a>对象中的constructor的作用是什么呢？</h3><p>这里推荐<a href="https://www.zhihu.com/people/he-shi-jun/activities" target="_blank" rel="noopener">贺师俊</a>前辈的回答，原文复制如下：</p><p><code>constructor属性不影响任何javascript的内部属性。instanceof检测对象的原型链，通常你是无法修改的（不过某些引擎通过私有的__proto__属性暴露出来）。</code></p><p><code>constructor其实没有什么用，只是javascript语言设计的历史遗留物。由于constructor属性是可以变更的，所以未必真的指向对象的构造函数，只是一个提示。不过，从编程习惯上，我们应该尽量让对象的constructor指向其构造函数，以维持这种习惯。</code></p><p>例子解析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype.constructor; <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;).constructor; <span class="comment">// undefined</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="原型链的最高指向？"><a href="#原型链的最高指向？" class="headerlink" title="原型链的最高指向？"></a>原型链的最高指向？</h3><p>《javascript高级程序设计》中有说到<code>所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。</code>那么原型的最高指向就是Object了嘛？你可以理解是Object，可是我认为是null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__; <span class="comment">// null</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__===<span class="literal">null</span> ; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>最高指向是Object/null，无伤大雅。</p><h3 id="实例和原型的关系？"><a href="#实例和原型的关系？" class="headerlink" title="实例和原型的关系？"></a>实例和原型的关系？</h3><p>当读取实例的属性时，如果找不到实例的属性，就会查找与对象关联的原型的属性，如果还是查找不到，就查找原型的原型，一直到顶级为止。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"嘉明"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">"jiaming"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// "jiaming"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除实例的属性后</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// "嘉明"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加一个疑问  在__proto__中加属性会覆盖原来的嘛</span></span><br><span class="line">person.__proto__.name = <span class="string">"嘉"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// "嘉"   证明成功，不建议这样修改，毕竟__proto__是浏览器厂商实现的，非标准的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再追加一个疑问 __proto__添加的属性或者方法是放在对象的原型上的嘛</span></span><br><span class="line"><span class="keyword">var</span> another_person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(another_person.name); <span class="comment">// "嘉"  证明是放在对象的原型上的</span></span><br></pre></td></tr></table></figure><h3 id="原型的原型呢？"><a href="#原型的原型呢？" class="headerlink" title="原型的原型呢？"></a>原型的原型呢？</h3><p>属性或者方法在自己的原型上没有找到的话，那就要跑到原型上去找啦。之前有提到过<code>所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。</code></p><p>那么一个构造函数<code>function Person(){}</code>就存在这样的一个关系，实例出来的<code>var person = new Person()</code>person通过<strong>proto</strong>指向构造函数的原型<code>Person.prototype</code>，然后构造函数的原型指向Object的原型，即是<code>Person.prototype.__proto__</code>指向<code>Object.prototype</code>。</p><h3 id="总结下呗"><a href="#总结下呗" class="headerlink" title="总结下呗"></a>总结下呗</h3><p>嗯，还是针对构造函数来说哈，将上面提到的知识点汇总一下啦。上面都是纯文字说明，下面就配上图片好好理解下。</p><p>先上相关代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"嘉明"</span>);</span><br><span class="line">person.age = <span class="number">12</span>;</span><br><span class="line">person.sayName(); <span class="comment">// "嘉明"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name.toString()); <span class="comment">// "嘉明"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> another_person = <span class="keyword">new</span> Person(<span class="string">"jiaming"</span>);</span><br><span class="line">another_person.sayName();</span><br></pre></td></tr></table></figure><p>上面代码中，相关的关系如下图</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/javascript/prototype_chain_summerize_img01.png" alt="frontend/javascript/prototype_chain_summerize_img01"></p><h2 id="实验环节"><a href="#实验环节" class="headerlink" title="实验环节"></a>实验环节</h2><p>小demo是使用canvas画出小星光，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>canvas<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        body&#123;</span></span><br><span class="line"><span class="undefined">            margin: 0;</span></span><br><span class="line"><span class="undefined">            padding: 0;</span></span><br><span class="line"><span class="undefined">            position: relative;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#myCanvas</span>&#123;</span></span><br><span class="line"><span class="undefined">            position: absolute;</span></span><br><span class="line"><span class="undefined">            left: 50%;</span></span><br><span class="line"><span class="undefined">            top: 50%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line"><span class="undefined">            margin-left: -300px;</span></span><br><span class="line"><span class="undefined">            margin-top: -150px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"600"</span> <span class="attr">height</span>=<span class="string">"300"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid #000;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/canvas.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> grd = <span class="string">""</span>; <span class="comment">// 渐变的颜色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文</span></span><br><span class="line">    <span class="keyword">var</span> context = c.getContext(<span class="string">"2d"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(context)&#123;</span><br><span class="line">        <span class="comment">// x,y,r 坐标和半径</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params">x,y,r</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.r = r;</span><br><span class="line">            <span class="keyword">this</span>.init(<span class="keyword">this</span>.x,<span class="keyword">this</span>.y,<span class="keyword">this</span>.r);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制星星</span></span><br><span class="line">        Star.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params">x,y,r</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">            context.beginPath();</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 渐变颜色</span></span><br><span class="line">            grd = context.createRadialGradient(x,y,r<span class="number">-2</span>,x,y,r+<span class="number">2</span>)</span><br><span class="line">            grd.addColorStop(<span class="number">0</span>, <span class="string">'white'</span>);</span><br><span class="line">            grd.addColorStop(<span class="number">1</span>, <span class="string">'yellow'</span>);</span><br><span class="line">            context.fillStyle=grd;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//  画圆</span></span><br><span class="line">            context.arc(x,y,r,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 填充颜色</span></span><br><span class="line">            context.fill();</span><br><span class="line">        </span><br><span class="line">            context.closePath();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建星星</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> x = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">600</span>);</span><br><span class="line">            <span class="keyword">var</span> y = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">3</span>)+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">new</span> Star(x,y,r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">        div.innerHTML = <span class="string">"您的浏览器不支持canvas，请升级浏览器！"</span>;</span><br><span class="line">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">"body"</span>)[<span class="number">0</span>].appendChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的简单效果如下图哈（ps，您可自行验证哈，改善啥的）：</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/javascript/prototype_chain_demo.png" alt="frontend/javascript/prototype_chain_demo"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/javascript/prototype_object_chain.jpg&quot; alt=&quot;frontend/javascript/prototype_object_chain&quot;&gt;&lt;/p&gt;
&lt;p&gt;原型对象和原型链在前端的工作中虽然不怎么显式的使用到，但是也会隐式的使用了，比如使用的jquery，vue等啦。在进入正题的时候，我们还是需要明白什么是&lt;code&gt;__proto__&lt;/code&gt;，&lt;code&gt;prototype&lt;/code&gt;等知识点，主要讲解构造函数，这篇博文大多是问答形式进行…&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="javascript" scheme="http://reng99.cc/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>小结http</title>
    <link href="http://reng99.cc/2018/03/11/summerize-http/"/>
    <id>http://reng99.cc/2018/03/11/summerize-http/</id>
    <published>2018-03-11T05:25:22.000Z</published>
    <updated>2018-04-03T14:12:59.182Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/network/http/http_banner.jpg" alt="network/http/http_banner"></p><p>了解http是前端工程师必备的一个技能哈，虽然现在自己不是很了解，但是根据查阅的资料，自己谈下自己的总结啦！路漫漫兮其修远…</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Web使用一种名为HTTP(HyperText Transfer Protocol，超文本传输协议)的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定。可以说，Web是建立在HTTP协议上通信的。</p><h3 id="HTTP是干什么的？"><a href="#HTTP是干什么的？" class="headerlink" title="HTTP是干什么的？"></a>HTTP是干什么的？</h3><p>http是数据传输协议（超文本传输协议），用来沟通客户端和服务器。</p><h3 id="什么是资源"><a href="#什么是资源" class="headerlink" title="什么是资源?"></a>什么是资源?</h3><p>网络上的一切内容皆资源，无论是静态文件还是动态生成的代码等。</p><h3 id="什么是媒体类型"><a href="#什么是媒体类型" class="headerlink" title="什么是媒体类型?"></a>什么是媒体类型?</h3><p>最初设计MIME（Multipurpose Internet Mail Extension，多用途英特网邮件扩展）是为了解决在不同的电子邮件系统之间搬迁报文时存在的问题。MIME在电子邮件系统中工作得非常好，因此HTTP也采纳了它，用它来描述并标记多媒体内容。</p><p>其实多媒体类型就是一种数据类型的标记，用来告诉接收端，接收到的数据是什么类型，让接收端知道怎么才能处理该文件。常见的标记方式就是MIME(见上解析)，MIME描述了文件的主要类型以及特定子类型，例如：<code>&quot;Content-Type&quot;:&quot;text/html&quot;</code>，其中<code>text</code>描述的文件主要类型是文本，而其特定类型是html文档！</p><h3 id="怎么理解URI以及它的子集（URL-URN）"><a href="#怎么理解URI以及它的子集（URL-URN）" class="headerlink" title="怎么理解URI以及它的子集（URL,URN）"></a>怎么理解URI以及它的子集（URL,URN）</h3><p>URI（Uniform Resource Identifier，统一资源标志符）的作用就是在网络上确定唯一资源，这就好比，在中国，身份证能唯一确定一个人一样。知道身份证号，就一定能确定一个人的信息。</p><p>URL（Uniform Resource Locator，统一资源定位符）是跟资源在网络上的位置有关，比如文章的banner图的位置为<code>http://omu538iq8.bkt.clouddn.com/network/http/http_banner.jpg</code>，广义上讲，我们说的URI就是指URL。</p><p>URN（Uniform Resource Name，统一资源名称）是作为特定内容的唯一名称使用的，与目前的资源所在地无关。URN是未来的趋势(试想一下人不可能是在一个地理位置不动吧，而ID_card的一定不会变的)，不过貌似具体实施还在商讨中。</p><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务就是<strong>一次http连接（不包括tcp/ip连接，只包括一次http报文发送与接收）</strong>的整个过程，由请求命令和响应结果组成。中间数据格式是http报文。本文的banner图示就是一次http的事务。我们平常打开一个网站，里面包括很多事务，比如：请求网页文档、请求某张图片以及请求某个视频/音频。</p><h3 id="方法指什么？"><a href="#方法指什么？" class="headerlink" title="方法指什么？"></a>方法指什么？</h3><p>HTTP方法会告诉服务器要执行什么动作（获取一个web页面、运行一个网关程序、删除一个文件等）。这些方法包括<code>GET , PUT , DELETE , POST , HEAD</code> 。</p><h3 id="状态码有什么用？"><a href="#状态码有什么用？" class="headerlink" title="状态码有什么用？"></a>状态码有什么用？</h3><p>状态码是一个三位数字的代码，告知客服端请求是否成功，或者是否需要采取其他动作。状态码带着一个原因短语，方便人解读，比如<code>304 Not Modified ，当发送GET请求资源返回上面的代码时候，可以解读成：客户端已经执行了GET，但文件没发生改变（和上次请求的资源一模一样）</code>。</p><h3 id="简单介绍一些报文"><a href="#简单介绍一些报文" class="headerlink" title="简单介绍一些报文"></a>简单介绍一些报文</h3><p>首先报文是<strong>http协议一种纯文本的数据格式</strong>，分为请求报文和响应报文，两种报文都具有类似的结构，分别由三部分构成：<code>起始行、首部、主体</code>。起始行描述了报文干了什么；首部描述报文传输的具体细节；主体描述传输的实际内容。</p><h3 id="什么是TCP-IP-更HTTP有什么关系？"><a href="#什么是TCP-IP-更HTTP有什么关系？" class="headerlink" title="什么是TCP/IP?更HTTP有什么关系？"></a>什么是TCP/IP?更HTTP有什么关系？</h3><p>TCP/IP是全世界的计算机和网络设备常用的层次化交换网络协议集。简单说，HTTP协议是一个应用层协议，位于TCP/IP协议的上一层，TCP/IP协议的主要作用就是过滤掉每个计算机的差异性，隐藏相关弱点，使得对于HTTP协议来说提供的都是”相同的”接口。</p><h3 id="在一次网络请求中，经历了哪些过程？"><a href="#在一次网络请求中，经历了哪些过程？" class="headerlink" title="在一次网络请求中，经历了哪些过程？"></a>在一次网络请求中，经历了哪些过程？</h3><p>(a).浏览器从RUL中通过解析出服务器的主机名</p><p>(b).浏览器将服务器的主机名转换成服务器的IP地址</p><p>(c).浏览器将端口号(如果有的话，默认是80)从URL中解析出来</p><p>(d).浏览器建立一条与web服务器的TCP连接</p><p>(e).浏览器向服务器发送一条HTTP请求报文</p><p>(f).服务器向浏览器回送一条HTTP响应报文</p><p>(g).关闭连接，浏览器显示文档</p><h3 id="HTTP协议有哪些版本？"><a href="#HTTP协议有哪些版本？" class="headerlink" title="HTTP协议有哪些版本？"></a>HTTP协议有哪些版本？</h3><p><strong>HTTP/0.9：</strong>这个协议有很多严重的设计缺陷；</p><p><strong>HTTP/1.0：</strong>使用广泛；</p><p><strong>HTTP/1.0+：</strong>是非官方的<code>HTTP/1.0</code>的扩展版本；</p><p><strong>HTTP/1.1：</strong>是目前正在广泛使用的版本，修复相关的设计缺陷，增加相关特性；</p><p><strong>HTTP-NG（又名HTTP/2.0）：</strong>将来使用与否正在商讨中</p><h3 id="Web的一些结构组件"><a href="#Web的一些结构组件" class="headerlink" title="Web的一些结构组件"></a>Web的一些结构组件</h3><p>上面有介绍了两个应用程序（Web浏览器和Web服务器）是如何互相发送报文来实现基本事务处理的。下面将列其他一些比较重要的应用程序，如下：</p><p><strong>代理：</strong>位于客户端和服务器之间的HTTP中间实体。具体来说就是代理位于客户端和服务器之间，接收所有客户端的HTTP请求，并把这些请求转发给服务器（可能会对请求进行修改之后转发）。对于用户来说，这些应用程序就是一个代理，代表用户访问服务器。代理的主要作用有过滤、屏蔽等，比如，在企业中对下载的应用程序进行病毒检测，<br>或者对小学生屏蔽一些成人才能看的内容。（注意⚠️ 代理即可以代表服务器对客户端进行响应，又可以代表客户端对服务器进行请求）</p><p><strong>缓存(cache)：</strong>HTTP的仓库，使常用页面的副本可以保存在离客户端更近的地方。首先说明一下：缓存某种意义上来说是一种代理服务器。它主要使用代表服务器对客户端进行响应。发送于预先缓存好的资源的副本（浏览器上就有缓存哈）。这样会加快事务响应速度、同时也会减少服务器的负载、减轻带宽等问题。</p><p><strong>网关(gateway)：</strong>是连接其他应用程序的特殊的web服务器。网关是一种特殊的服务器，面对客户端时好像它就是服务器，而对于服务器，它又充当客户端的角色，它的主要作用就是协议转换。例如下面的HTTP/FTP网关。</p><p><img src="http://omu538iq8.bkt.clouddn.com/network/http/gateway.png" alt="network/http/gateway"></p><p><strong>隧道(tunnel)：</strong>对HTTP通信报文进行盲转发的特殊代理。HTTP隧道通常用来在一条或多条HTTP数据，转发时不会窥探数据。</p><p><strong>Agent代理：</strong>发起自动HTTP请求的半只能Web客户端。说白了就是我们平时所说的浏览器，以及web机器人、爬虫等。</p><h2 id="URL和资源"><a href="#URL和资源" class="headerlink" title="URL和资源"></a>URL和资源</h2><p>上面提到过，URN还没成熟，说的URI可以等同说URL，即<code>URI == URL , URI !== URL</code>。</p><h3 id="URL的语法"><a href="#URL的语法" class="headerlink" title="URL的语法"></a>URL的语法</h3><p>下面是URL的组成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;<span class="comment">#&lt;frag&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># scheme:方法描述了请求资源时用了什么协议，用“:”与url其它部分隔开；</span></span><br><span class="line"><span class="comment"># user:用户名描述了访问是带的用户名</span></span><br><span class="line"><span class="comment"># password:密码描述了用户名后面可能跟的密码，用“:”跟用户名隔开；</span></span><br><span class="line"><span class="comment"># host:主机描述了网站主机名或ip地址，如果前面有用户名和密码，用@分开；</span></span><br><span class="line"><span class="comment"># post:服务器当前正在监听的端口，http默认为80，https默认为443;</span></span><br><span class="line"><span class="comment"># path:路劲描述了资源在服务器上的位置，用‘/’跟前面部分隔开；</span></span><br><span class="line"><span class="comment"># params:参数描述了请求需要附加的参数，用“;”与其他部分隔开；</span></span><br><span class="line"><span class="comment"># query:查询是用来激活服务器程序去执行某些操作，比如查询数据库等，用“?”与其余部分隔开；</span></span><br><span class="line"><span class="comment"># frag/fragments:片段只在客户端使用，不发送到服务器端；</span></span><br></pre></td></tr></table></figure><h3 id="URL快捷方式"><a href="#URL快捷方式" class="headerlink" title="URL快捷方式"></a>URL快捷方式</h3><p>URL快捷方式描述了一个程序如何通过相对地址解析处绝对地址的过程以及在浏览器地址栏输入部分URL浏览器自动补全主机名的一种机制。</p><p>相对地址转换为绝对地址：首先会根据一个基础地址来得到出协议、主机名、端口等。</p><p>浏览器扩展地址主要通过主机名扩展和历史扩展等方式实现自动地址补全。</p><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><p><strong>为什么需要编码？</strong></p><p>主要从URL的一致性、安全性、以及完整性来强调需要对URL字符进行编码。比如因为一个URL连接的两端可能出现的机器种类很多，为了让大家能够解析出一个相同的url，所以有必要对某些不安全的URL字符进行转义。</p><p><strong>URL字符集由什么编码构成？</strong></p><p>早起的URL是由US-ASCII码编码，但是随着网络全世界的流行，有很多字符是US-ASCII不能编码的，因为US-ASCII码最多只能编译127个字符。通过转义序列，就可以用US-ASCII字符集的有限子集字符值或数据进行编码了。</p><p><strong>编码机制？</strong></p><p>为了避开安全字符集表示法带来的限制，人们设计了一种编码机制，用来在URL中表示各种不安全的字符。这种编码机制就是通过一种“转义”表示法来表示不安全字符的，这种转义表示法包含一个百分号（%），后面跟着两个表示字符的ASCII码的十六进制数。</p><p><strong>哪些字符不建议在URL里面使用？</strong></p><p>在URL中，有几个字符被保留起来，有着特殊的含义。有些字符不在定义的US-ASCII可打印字符集中。还有些字符会与某些因特网网关和协议产生混淆，因此不赞成使用，比如“%”。</p><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>如果说HTTP是因特网的信使，那么<code>HTTP 报文</code>就是它用来搬东西的包裹了。我们将了解：</p><ol><li>报文是如何流动的</li><li>HTTP报文的三个组成部分（起始行、首部和实体的主体部分）</li><li>请求和响应报文直接的区别</li><li>请求报文支持的各种功能（方法）</li><li>和响应报文一起返回的各种状态码</li><li>各种各样的HTTP首部都是用来干什么的</li></ol><h3 id="报文流"><a href="#报文流" class="headerlink" title="报文流"></a>报文流</h3><p>HTTP报文是以一种类似的流方式来发送数据的，所以报文流讲述了HTTP报文的一些客观状态，相关的术语：流入、流出形容事物的处理。HTTP报文任何时候是从上流流入，其中经过的节点既可能是上流，也有可能是下流，如果从某个节点流出，那么相对于此节点流入的那个节点就是上游，翻过它就是下游。</p><h3 id="报文的组成部分"><a href="#报文的组成部分" class="headerlink" title="报文的组成部分"></a>报文的组成部分</h3><p>报文是由三部分组成：<code>起始行、首部、主体</code>。起始行和首部都是ASCII文本，而主体可以是任意类型文件，比如二进制，视频等。且起始行和首部都以一个<code>crlf</code>作为结束符，并且首部与主体之间应始终存在一个以crlf序列作为结束的<code>空行</code>。当然了，为了兼容老版本的http，这里有时并不是那么严格要求非要crlf同时存在。</p><h3 id="请求报文和响应报文直接的区别"><a href="#请求报文和响应报文直接的区别" class="headerlink" title="请求报文和响应报文直接的区别"></a>请求报文和响应报文直接的区别</h3><p>两者的报文语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求报文 </span></span><br><span class="line">&lt;method&gt;&lt;request-URL&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 响应报文</span></span><br><span class="line">&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure><p>上面的请求报文和响应报文的字段解析如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method是客户端希望执行的动作，如GET、POST等</span></span><br><span class="line"><span class="comment"># request-URL是指请求资源的路径</span></span><br><span class="line"><span class="comment"># version报文版本号，格式为http/&lt;major&gt;.&lt;minor&gt;，分别代表主要版本和次要版本号，其含义应分开理解</span></span><br><span class="line"><span class="comment"># status就是用一个三位的数字表示当前事务处于什么状态，便于开发者处理</span></span><br><span class="line"><span class="comment"># reason-phrase原因短语，方便查看状态码的意思</span></span><br><span class="line"><span class="comment"># headers首部是一个包含零个或多个的键值对，键值对以crlt隔开，而键，值之间以":"隔开，期间包含一个可选的空格</span></span><br><span class="line"><span class="comment"># 任意格式组成的数据块，也是实际发送的内容</span></span><br></pre></td></tr></table></figure><h3 id="请求报文支持的方法"><a href="#请求报文支持的方法" class="headerlink" title="请求报文支持的方法"></a>请求报文支持的方法</h3><p><strong>安全方法</strong></p><p>能在服务器端操作的就是非安全方法，比如DELETE、PUT、POST，不在服务器端游操作的就是安全方法，比如GET、HEADER。当然了，安全方法并非不能在服务器端有操作，这是开发者可以控制的。</p><p><strong>GET</strong></p><p>用来请求服务器端发送某个资源。</p><p><strong>HEADER</strong></p><p>此方法跟GET方法类似，区别就是不返回主体。HEAD请求的回应部分的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标志的资源的信息。常用于测试超链接的有效性，是否可以访问，以及最近是否更新。</p><p><strong>PUT</strong></p><p>用于向服务器端修改、插入数据。</p><p><strong>POST</strong></p><p>用于向服务器端发送数据。常用于表单的提交，用于登录注册页面。</p><p><strong>TRACK</strong></p><p>用于向服务器端请求报文在发送过程中经过了什么修改，主要是用来测试。</p><p><strong>OPTIONS</strong></p><p>用来请求服务器告知其支持什么功能。</p><p><strong>DELETE</strong></p><p>用于向服务器删除某个指定的资源。</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><table><thead><tr><th>#</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><p><strong>常见的状态码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br><span class="line"><span class="comment"># 表示从客户端发过来的请求在服务器端被正常处理了</span></span><br><span class="line"></span><br><span class="line">204 No Content</span><br><span class="line"><span class="comment"># 表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分</span></span><br><span class="line"></span><br><span class="line">206 Partial Content</span><br><span class="line"><span class="comment"># 表示客户端进行了范围请求</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">301 Moved Permanently</span><br><span class="line"><span class="comment"># 永久性重定向。该状态码表示请求的资源已经被删除，重新分配了新的URI，以后应使用资源现在所指的URI</span></span><br><span class="line"></span><br><span class="line">302 Found</span><br><span class="line"><span class="comment"># 临时性重定向。该状态码表示请求分配的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。和301状态相似，但是302代表的资源不是被永久转移，只是临时性质的。</span></span><br><span class="line"></span><br><span class="line">303 See Other</span><br><span class="line"><span class="comment"># 该状态码表示由于请求对应的资源存在着另一个URI，应该使用GET方法定向获取请求的资源。</span></span><br><span class="line"></span><br><span class="line">304 Not Modified</span><br><span class="line"><span class="comment"># ⚠️ 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304虽然被划分到3XX类别里面，但是和重定向没有关系。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">400 Bad Request</span><br><span class="line"><span class="comment"># 表示请求报文中存在语法错误。</span></span><br><span class="line"></span><br><span class="line">401 Unauthorized</span><br><span class="line"><span class="comment"># 表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。</span></span><br><span class="line"></span><br><span class="line">403 Forbidden</span><br><span class="line"><span class="comment"># 表示对请求资源的访问被服务器拒绝了。</span></span><br><span class="line"></span><br><span class="line">404 Not Found</span><br><span class="line"><span class="comment"># 表示服务器上无法找到请求的资源。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">500 Internal Server Error</span><br><span class="line"><span class="comment"># 表明服务器端执行请求时发生了错误</span></span><br><span class="line"></span><br><span class="line">503 Server Unavailable</span><br><span class="line"><span class="comment"># 表明服务器暂时处于负载或者正在进行停机维护，无法处理请求。</span></span><br></pre></td></tr></table></figure><p>更多的状态码请自行百度。</p><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><p>首部和方法配合工作，共同决定了客户端和服务器能够做什么事情。首部分为通用首部、请求首部、响应首部、主体首部、扩展首部！具体的信息请查看《HTTP权威指南》。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>Web代理(proxy)服务器是网络的中间实体。代理位于客户端和服务器之间，扮演“中间人”的角色，在各端点之间来回传送HTTP报文。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>web缓存是可以自动保存常见文档副本的http设备。当web请求抵达缓存时，如果本地有<code>已缓存的副本</code>，就可以从本地存储设备而不是原始服务器中提取这个文档。使用缓存的优点有：</p><ol><li>缓存减少了冗余的数据传输，节省了你的网络费用。</li><li>缓存缓解了网络的瓶颈问题。不需要更多的带宽就能更快的加载页面。</li><li>缓解降低了对原始服务器的要求。服务器可以更加快地响应，避免过载的出现。</li><li>缓存降低了距离时延，因为从较远的地方加载页面会更慢些。</li></ol><h3 id="冗余的数据传输"><a href="#冗余的数据传输" class="headerlink" title="冗余的数据传输"></a>冗余的数据传输</h3><p>每次从服务器上拿数据（客户端频繁访问同一个页面），那么带来的后果就是：服务端多次发送重复的数据浪费流量、耗费昂贵的网络带宽从而减低传输速率、加大服务器的负载。而有了缓存之后，这些问题可以迎刃而解。</p><h3 id="带宽瓶颈"><a href="#带宽瓶颈" class="headerlink" title="带宽瓶颈"></a>带宽瓶颈</h3><p>很多本地的网络客户端提供的带宽比远程服务器提供的带宽要宽。客户端会以路径上最慢的网速访问服务器，这样本地的带宽优势就没有体现出来。如果在客户端方向配置一个高速缓存服务器，那么就可以很快得到响应，由此也可以看出带宽对报文传输速率的影响。</p><h3 id="瞬间拥塞"><a href="#瞬间拥塞" class="headerlink" title="瞬间拥塞"></a>瞬间拥塞</h3><p>瞬间拥塞描述的是一种情况：一个爆炸性的新闻和热点事件，如果没有配置缓存的情况下，那么在短时间内，服务器会收到突变的请求增长，负荷会爆炸性增长，肯定会吃不消。但是又了缓存，可以大大分担服务器的负载数量。</p><h3 id="距离时延"><a href="#距离时延" class="headerlink" title="距离时延"></a>距离时延</h3><p>距离时延说明的一个问题就是传输数据过程这个过程需要的时间，而且路程越长，那么需要的时间也会越多，即时延越长。所以在距离客户端较近的地方部署缓存服务器，减少了传输路程，那么就减少了传输时延。平时使用的cdn就是这个原理啦。</p><h3 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h3><ul><li><p><strong>缓存命中与缓存未命中：</strong>一次http事务请求如果是从得到的响应是从缓存得到的原始副本，那么这样的过程就称之为缓存命中。如果缓存没有响应的副本，而要去请求原始服务，那么久把这个过程称之为缓存未命中。</p></li><li><p><strong>http再验证：</strong>原始响应内容是在变化的，所以缓存应该在文档<code>过期时间</code>之后去验证缓存的副本是不是新鲜的，这个过程就叫做http再验证。如果再验证之后得知副本是新鲜的，那么原始服务器就会返回<code>304 not modified</code>。此时，称之为再验证命中或者缓存慢命中。如果得知缓存不是新鲜的，那么服务器返回<code>200 ok</code>。此时，称之为再验证未命中。如果原始对象被删除，返回<code>404 not found</code>响应。响应的缓存副本要删除。</p></li><li><p><strong>命中率：</strong>指由缓存返回副本事务在全部事务中所占的比例，称之为缓存命中率。这个数据实际意义不是很大，而字节命中率从资源大小总量的角度说明缓存命中所占的比例。因为它从数据流量的角度出发，所以实际中这个数据的意义挺大的。</p></li><li><p><strong>区分命中和未命中：</strong>简单来说，http没有相应的机制来告知客户端响应是从缓存得到的还是从原始服务器得到的。但是我们可以从http响应报文首部中的date字段得知这一情况：如果这个字段的时间比当前时间更早得多，说明这是从缓存得到的，因为date描述的服务器第一次响应的时间，而缓存是不会对这个字段进行修改的。</p></li></ul><h3 id="缓存的拓扑结构"><a href="#缓存的拓扑结构" class="headerlink" title="缓存的拓扑结构"></a>缓存的拓扑结构</h3><ul><li><p><strong>分类：</strong>缓存分为私有缓存（只为一个客户端服务，比如我们给浏览器配置的代理）和共有缓存（为多个客户端服务，现实中是以代理缓存服务器的形式出现）</p></li><li><p><strong>代理缓存的层级结构：</strong>此种结构描述的以父、子层级出现的层级结构，同时离客户端越近的子缓存命中率较低（较廉价），可以把请求上升到父缓存（较昂贵），从而在父缓存那里实现事务处理。</p></li><li><p><strong>代理缓存的网状结构：</strong>它描述的缓存结构并不是很明显呈现父子关系的结构，而是呈现无规则的网状。这种结构的思想就是子缓存可以动态选择上一级缓存，从而实现更灵活的缓存控制。</p></li></ul><h3 id="缓存的处理步骤"><a href="#缓存的处理步骤" class="headerlink" title="缓存的处理步骤"></a>缓存的处理步骤</h3><ol><li><strong>接收</strong>————缓存从网络中读取抵达的请求报文。</li><li><strong>解析</strong>————缓存对报文进行解析，提取出url和各种首部。</li><li><strong>查询</strong>————缓存查看是否有本地副本可用，如果没有，就去获取一份副本（根据情形和配置，到原始服务器或父代理中去取，将副本存在本地，或者获取不到返回错误信息）</li><li><strong>新鲜度检测</strong>————缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。</li><li><strong>创建响应</strong>————缓存会用新的首部和已缓存的主体来构建一条响应报文。</li><li><strong>发送</strong>————缓存通过网络将响应发送给客户端。</li><li><strong>日志</strong>————缓存可选地创建一个日志文件条目来描述这个事务。</li></ol><h3 id="保存副本的新鲜度"><a href="#保存副本的新鲜度" class="headerlink" title="保存副本的新鲜度"></a>保存副本的新鲜度</h3><ul><li>文档过期通过特殊的http首部cache-control和expires，http让原始服务器为每个文档设置一个“过期时间”，如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: Max-Age = 484200  // 除了Max-Age , 还可以有其他的字段啦</span><br><span class="line">Expire: Fri, 28 Oct 2016 12:00:00 GMT</span><br><span class="line"></span><br><span class="line">// Max-Age 是相对时间，以秒为单位，理解为使用期  推荐使用</span><br><span class="line">// Expires 为绝对时间，理解为到期时间  不推荐使用--由于很多服务器的时钟都不同步，或者不正确，所以最好使用剩余秒数（相对时间）来表示过期时间</span><br></pre></td></tr></table></figure><ul><li><p><strong>服务器再验证：</strong>仅仅是已缓存文档过期了并不意味着它和原始服务器目前处于活跃状态的文档有诗集的区别；这知识意味着到了要进行核对的时间了。这种情况被称为<code>服务器再验证</code>，说明缓存需要询问服务器是否发生了变化。</p></li><li><p><strong>用条件再验证：</strong>涉及到的两个首部为<code>If-Modified-Since</code>和<code>If-None-Match</code>。如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: &lt;data&gt;</span><br><span class="line">If-None-Match: &lt;verson&gt;</span><br><span class="line"></span><br><span class="line">// date为服务器响应报文里面Last-Modified时间</span><br><span class="line">// version是实体标签ETag。其机制跟If-Modified-Since不同在于：后者是根据修改时间来判断文档的新鲜度，但是有些情况下是不适合的，比如我们只是加了注释什么的，其中实际内容并没有什么变化。</span><br></pre></td></tr></table></figure><h3 id="缓存的控制能力"><a href="#缓存的控制能力" class="headerlink" title="缓存的控制能力"></a>缓存的控制能力</h3><ul><li><strong>缓存控制能力</strong>描述的是服务器可以通过设置相关的首部来控制文档的缓存过期时间的能力。相关首部解析如下：</li></ul><table><thead><tr><th>指令</th><th>目的</th></tr></thead><tbody><tr><td>Cache-Control:no-store</td><td>不能缓存/尽快从存储器中删除文档的所有痕迹，因为里面可能有敏感信息</td></tr><tr><td>Cache-Control:no-cache</td><td>除非资源进行了再验证，否则这个客户端不会接受已缓存的资源</td></tr><tr><td>Cache-Control:must-revalidate</td><td>严格遵守新鲜验证规则</td></tr><tr><td>Cache-Control:max-age</td><td>设置多长时间过期（相对时间）</td></tr><tr><td>Expires: <date></date></td><td>设置多长时间过期（绝对时间）不建议使用</td></tr><tr><td>试探性过期</td><td>不设置首部，让缓存来决定，这个方式涉及到一种算法，比如缓存服务器通过查看最后修改时间，从而得到该文档的修改频繁度，从而为其设置缓存过期时间</td></tr></tbody></table><p>上面的优先级从上到下依次降低。</p><ul><li><strong>客户端的新鲜度限制：</strong>web浏览器都有<code>refresh（刷新）</code>或者<code>reload（重载）</code>按钮，可以强制对浏览器或者代理缓存中可能过期的内容进行刷新。<code>refresh</code>按钮会发布一个附加了<code>cache-control</code>请求首部的get请求，这个请求会强制进行再验证，或者无条件地从服务器获取文档。<code>refresh</code>的确切行为取决于浏览器、文档以及拦截缓存的配置。客户端可以用<code>cache-control</code>请求首部来强化或者放松对过期时间的限制，相关的首部介绍如下：</li></ul><table><thead><tr><th>指令</th><th>目的</th></tr></thead><tbody><tr><td>Cache-Control: max-stale = <s></s></td><td>缓存可以随意提供过期的文件。如果指定了参数<s>，这段时间内，文档就不能过期。这条指令放松了缓存的规则</s></td></tr><tr><td>Cache-Control: min-fresh = <s></s></td><td>至少在未来<s>秒内文档要保持新鲜。这就使缓存规则更加严格了</s></td></tr><tr><td>Cache-Control: max-age = <s></s></td><td>缓存无法返回缓存时间长于<s>秒的文档。这条指令会使缓存规则更加严格，除非同时还发送了max-stale指令，在这种情况下，使用期可能会超过其过期时间</s></td></tr><tr><td>Cache-Control: no-cache  Pragma: no-cache</td><td>除非资源进行了再验证，否则这个客户端不会接受已缓存的资源</td></tr><tr><td>Cache-Control: no-store</td><td>缓存应该尽快从存储器中删除文档的所有痕迹，因为其中可能会包含敏感信息</td></tr><tr><td>Cache-Control: only-if-cached</td><td>只有当缓存中有副本存在时，客户端才会获取一份副本</td></tr></tbody></table><h3 id="设置缓存控制"><a href="#设置缓存控制" class="headerlink" title="设置缓存控制"></a>设置缓存控制</h3><p>不通的web服务器为HTTP Cache-Control 和 Expiration首部的设置提供了一些不同的机制。下面讲解下面这些：</p><ol><li>控制Apache的HTTP首部</li></ol><p>默认没有开启，需要进行相关的配置：<code>mod_headers,mod_expires,mod_cern_meta</code></p><ol><li>通过HTTP-EQUIV控制HTML缓存</li></ol><p>例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;this is the title&lt;/title&gt;</span><br><span class="line">&lt;meta HTTP-EQUIV=<span class="string">"Cache-control"</span> CONTENT=<span class="string">"no-cache"</span>/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此方法只是对html文件有用，并不是很好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《HTTP权威指南》</p><p>《图解HTTP》</p><p style="color:red;text-align: center;">精力有限，未能一次性更新完，还望体谅…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/network/http/http_banner.jpg&quot; alt=&quot;network/http/http_banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;了解http是前端工程师必备的一个技能哈，虽然现在自己不是很了解，但是根据查阅的资料，自己谈下自己的总结啦！路漫漫兮其修远…&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://reng99.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http" scheme="http://reng99.cc/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>前端优化：雅虎35条原则</title>
    <link href="http://reng99.cc/2018/03/06/frontend-optimization/"/>
    <id>http://reng99.cc/2018/03/06/frontend-optimization/</id>
    <published>2018-03-06T08:28:09.000Z</published>
    <updated>2018-03-23T02:40:47.445Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/optimization/fontend-optimization-banner.jpg" alt="frontend/optimization/fontend-optimization-banner"></p><p>整理前端优化的方案，主要是雅虎的35条原则。欢迎补充哈 😊 </p><a id="more"></a><h2 id="内容-尽量减少HTTP请求数"><a href="#内容-尽量减少HTTP请求数" class="headerlink" title="[内容]尽量减少HTTP请求数"></a>[内容]尽量减少HTTP请求数</h2><p>80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本，Flash等等。减少组件数必然能减少页面提交的HTTP请求书。这是让页面更快的关键。</p><p><strong>合并文件</strong>是通过把所有脚本(javascript)放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。</p><p><strong>CSS Sprites(精灵图)</strong>是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的<code>background-image</code>和<code>background-position</code>属性来定位要显示的部分。也可以只用<code>position</code>就行了。</p><p><strong>图像映射</strong>可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在页面中连续的时候才有用，比如导航条。给<code>image map</code>设置坐标的过程既无聊又容易出错，用<code>image map</code>来做导航也不容易，所以不推荐用这种方式。</p><p><strong>行内图片(Base64编码)</strong>用<code>data:</code>URL模式来把图片嵌入图片。这样会增加HTML文件的大小，把行内图片放在(缓存的)样式表中是个好办法，而且成功避免了页面变重。但目前主流浏览器并不能很好地支持行内图片。</p><h2 id="服务器-使用CDN-Content-Delivery-Network"><a href="#服务器-使用CDN-Content-Delivery-Network" class="headerlink" title="[服务器]使用CDN(Content Delivery Network)"></a>[服务器]使用CDN(Content Delivery Network)</h2><p>用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。当具体要怎么做呢？</p><p>实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务。缩短用户和内容之间的距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。</p><p>记住终端用户80%到90%的响应时间都花在下载组件上了：图片，样式，脚本，Flash等等，这是<code>业绩黄金法则</code>。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。</p><p><strong>内容分发网络(CDN)</strong>是一组分散在不同地理位置的web服务器，用来给用户更高效地分发内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数(hop)最少的或者响应时间最快的服务器。</p><h2 id="服务器-添上Expires或者Cache-Control-HTTP头"><a href="#服务器-添上Expires或者Cache-Control-HTTP头" class="headerlink" title="[服务器]添上Expires或者Cache-Control HTTP头"></a>[服务器]添上Expires或者Cache-Control HTTP头</h2><p>这条规则有两个方面： </p><ul><li><p>对于静态组件：通过设置一个遥远的将来时间作为<code>Expires</code>来实现用不失效</p></li><li><p>多余动态组件：用适合的<code>Cache-Control</code>HTTP头来让浏览器进行条件性的请求</p></li></ul><p>网页设计越来越丰富，这意味着页面里有更多的脚本，图片Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这就避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但是它们应该用在<code>所有</code>组件上，包括脚本、样式和Flash组件。</p><p>浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2020年03月06日前不会改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Fri, <span class="number">06</span> Mar <span class="number">2020</span> <span class="number">21</span>:<span class="number">00</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure><p>用一个遥远的未来时间做有效期HTTP头，只有在用户已经访问过站点之后才会影响页面视图。如果是新访客或者浏览器的缓存被清空时，对HTTP请求的数量并没有影响。因此这种性能提升取决于已缓存各个组件的用户访问站点的频率。我们<a href="https://yuiblog.com/blog/2007/01/04/performance-research-part-2/" target="_blank" rel="noopener">在Yahoo!测量了这个数据</a>，发现已缓存各个组件的页面访问量（PV）占75%到85%。通过把一个遥远的未来时间作为有效期HTTP头，增加了被浏览器缓存的组件数量，在后续页面的访问中不需要用Internet连接多发哪怕一个字节。</p><h2 id="服务器-Gzip组件"><a href="#服务器-Gzip组件" class="headerlink" title="[服务器]Gzip组件"></a>[服务器]Gzip组件</h2><p>前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽，网络服务商，对等交换点的距离问题等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。</p><p>从HTTP/1.1开始，web客户端就有了支持压缩<code>Accept-Encoding HTTP</code>请求头。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip,deflate</span><br></pre></td></tr></table></figure><p>如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过<code>Content-Encoding: gzip</code>响应头来通知客户端。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure><p>Gzip是目前最常见的高效压缩方法，由GNU项目开发并被<a href="http://www.ietf.org/rfc/rfc1952.txt" target="_blank" rel="noopener">RFC 1952</a>标准化。唯一一个你可能会看到的其它压缩格式是deflate，但它效率不高而且并不常见。</p><p>Gzipping一般能够把响应压缩到70%左右，目前大约90%的通过浏览器的网络传输都支持gzip。如果是Apache服务器，配置gzip的模块取决于版本Apache 1.3用<a href="https://sourceforge.net/projects/mod-gzip/" target="_blank" rel="noopener">mod_gzip</a>而Apache 2.x是<a href="http://httpd.apache.org/docs/2.0/mod/mod_deflate.html" target="_blank" rel="noopener">mod_deflate</a>模块。</p><p>浏览器和代理的某些因素可能会引起浏览器所期望的和它收到的压缩内容不匹配。幸运的是，随着老旧浏览器的淘汰，这些极少遇到的情况正在逐渐减少，而且Apache模块可以通过自动添加合适的Vary响应头来帮你搞定。</p><p>服务器会根据文件类型来决定要不要用gzip压缩，但这非常有限。大多数网站都有gzip压缩HTML文件，其实压缩脚本，样式表也是不错的选择，但是很多网站却错失了这个机会。其实，可以压缩任何文本内容，包括XML和JSON，而图片和PDF不用压缩，因为它们已经被压缩过了，再用gzip压缩不仅浪费CPU，还可能会越压越大。</p><p>尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。</p><h2 id="CSS-把样式表放在顶部"><a href="#CSS-把样式表放在顶部" class="headerlink" title="[CSS]把样式表放在顶部"></a>[CSS]把样式表放在顶部</h2><p>在Yahoo!研究性能的时候，我们发现把样式表放在文档的HEAD部分能让页面<code>看起来</code>加载得更快。这是因为把样式表放在head里能让页面逐步渲染。</p><p>关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显示得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被记录下来了。在我们的例子中，HTML页面就是进度条！当浏览器逐渐加载页面头部，导航条，顶部logo等等的内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整个用户体验。</p><p>在很多浏览器（包括IE）中，把样式表放在HTML文档底部会阻止页面逐渐渲染。这些浏览器阻塞渲染过程，以避免因为样式变动而重绘页面元素，用户这时就只能盯着空白页面。</p><p><a href="https://www.w3.org/TR/html4/struct/links.html#h-12.3" target="_blank" rel="noopener">HTML官方文档</a>清楚的描述了样式表应该放在页面的HEAD里面：<code>Unlike A,[LINK] may only appear in the HEAD section of a document, although it may appear any number of times.</code>（不像a标签,link标签可能只出现在head部分，虽然它可以出现多次）。空白屏幕或者没有样式的falsh内容都是不可取的。理想的方案就是遵循<a href="https://www.w3.org/TR/html4/struct/links.html#h-12.3" target="_blank" rel="noopener">HTML官方文档</a>，把样式表放在HTML文档的HEAD部分。</p><h2 id="javascript-把脚本放在底部"><a href="#javascript-把脚本放在底部" class="headerlink" title="[javascript]把脚本放在底部"></a>[javascript]把脚本放在底部</h2><p>脚本会阻塞并行下载，<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4" target="_blank" rel="noopener">HTTP/1.1官方文档</a>建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。<code>如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同的名下的。</code></p><p>有时候，并不容易吧脚本移动到底部。举个例子，如果脚本是用<code>document.write</code>插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在大多数情况下，这些问题都是可以解决的。</p><p>一个常见的建议是用推迟(deferred)脚本，有<code>DEFER</code>属性的脚本意味着不能含有document.write，并提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持<code>DEFER</code>属性。在IE中，脚本可能被推迟，但不尽人意。如果脚本可以推迟，我们就可以把它放在页面底部，页面就可以更快地载入。</p><h2 id="CSS-避免使用CSS表达式"><a href="#CSS-避免使用CSS表达式" class="headerlink" title="[CSS]避免使用CSS表达式"></a>[CSS]避免使用CSS表达式</h2><p>用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4" target="_blank" rel="noopener">从IE8起就不推荐使用了</a>。例如，可以用CSS表达式吧背景颜色设置成按小时交替的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">expression</span>((<span class="selector-tag">new</span> <span class="selector-tag">Date</span>())<span class="selector-class">.getHours</span>()%2 ? "<span class="selector-id">#f00</span>" : "<span class="selector-id">#fff</span>");</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>expression</code>方法可以接受一个javascript表达式。css属性会被设置成表达式的计算结果。<code>expression</code>方法会被其他浏览器忽略，所以只有想办法实现垮浏览器的与IE一致的用户体验才有用。</p><p>表达式最大的问题是<code>它们经常被重复计算，比我们想象的次数还要多。</code>不仅仅是页面渲染和调整大小的时候，在页面被滚动，甚至用户在页面上移动鼠标时都被重新计算表达式。给css表达式添加一个计算器就可以追踪它重新计算的时间和频率，而在页面上动动鼠标就可以引发10000多次重新计算。</p><p>减少css表达式重新计算的一种方式就是用一次性表达式，即在表达式第一次计算后就把样式属性设置成一个明确的值，换掉表达式。如果必须要在页面的整个生命周期中动态设置样式属性，可以用事件处理器来代替css表达式。如果必须使用css表达式，要记得它们可能被重复计算千次，从而影响整个页面的性能。</p><h2 id="javascript-css-把javascript和css放到外面"><a href="#javascript-css-把javascript和css放到外面" class="headerlink" title="[javascript ,css]把javascript和css放到外面"></a>[javascript ,css]把javascript和css放到外面</h2><p>很多性能原则都是关于如何管理外部组件的，然而，在这些顾虑出现之前你应该问一个基础的问题：<code>应该把javascript和css放到外部文件中还是直接卸载页面里？</code></p><p>实际上，用外部文件可以让页面更快，因为javascript和css文件会被缓存在浏览器。HTML文档中的行内javascript和css在每次请求该html文档的时候都会重新下载。这样做是减少了所需的HTTP请求数，但是增加了html文档的大小。另一方面，如果javascript和css在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。</p><p>关键因素是，外部文件被缓存的频率和页面被请求数量之间的关系。尽管这个因素很难量化，但我们还是可以用各种各样的指标来衡量的。如果用户的每个会话中都有多次页面访问，那么相同的脚本和样式表就可以被多个页面复用，缓存的外部文件就会带来巨大的好处。</p><p>很多站点在度量中都处于中等水平，对这些站点来说，一般最好的解决方案就是把javascript和css部署为外部文件。唯一的例外是主页上汗哪方式的优先。在每个会话中访问量比较少的主页会发现行内javascript和css能让终端用户的响应时间更快。</p><p>对典型的站点来说，首页是众多访问量的开始，有很多技术可以对减少HTTP请求起到杠杆作用，就像用外部文件缓存的好处一样。这样的一种技术就是在首页使用行内javascript和css，但是在页面载入完成之后动态加载外部文件，这样后续的页面所需的外部文件就已经被放在浏览器的缓存里面了。</p><h2 id="内容-减少DNS查找"><a href="#内容-减少DNS查找" class="headerlink" title="[内容]减少DNS查找"></a>[内容]减少DNS查找</h2><p>域名系统建立了主机名和IP地址间的映射，就像电话薄上人名和号码的映射一样。当你在浏览器输入www.yahoo.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完之前，浏览器无法从主机名下载任何东西。</p><p>DNS查找被缓存起来更加有效，由用户的ISP(网络提供商)或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己cache。只要浏览器在自己的cache里还保存着这条记录，它就不会向操作系统查询DNS。</p><p>IE默认缓存DNS查找30分钟，写在<code>DnsCacheTimeout</code>注册表设置中。Firefox缓存1分钟，可以用<code>network.dnsCacheExpiration</code>配置项设置。（Fasterfox把缓存时间改成了1小时P.S.Fasterfox是FF的一个提速插件）</p><p>如果客户端的DNS cache是空的（包括浏览器和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。</p><p>减少不同主机名的数量同时也减少了页面能够并行下载的组件的数量，避免了DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散到2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。</p><h2 id="javascript-css-压缩javascript和css"><a href="#javascript-css-压缩javascript和css" class="headerlink" title="[javascript,css]压缩javascript和css"></a>[javascript,css]压缩javascript和css</h2><p>压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行符和tab）。在javascript中这样做能够提高响应性能，因为要下载的文件变小了。自己一般使用gulp来压缩。</p><h2 id="内容-避免重定向"><a href="#内容-避免重定向" class="headerlink" title="[内容]避免重定向"></a>[内容]避免重定向</h2><p>重定向用301和302状态码，下面是一个有301状态码的HTTP头：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">301</span> Moved Permanently</span><br><span class="line">Location: http:<span class="comment">//example.com/newuri</span></span><br><span class="line">Content-type: text/html</span><br></pre></td></tr></table></figure><p>浏览器会自动跳转到<code>Location</code>域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其额外的HTTP头，比如<code>Expires</code>和<code>Cache-Control</code>也表示重定向。除此之外还有别的跳转方式：refresh元素和javascript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。</p><p>牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。</p><p>有一种常见的极其浪费资源的重定向，而且WEB开发人员一般意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到<a href="http://reng99" target="_blank" rel="noopener">http://reng99</a>会返回一个重定向到<a href="http://reng99/" target="_blank" rel="noopener">http://reng99/</a>的301响应（注意添加在尾部的斜线）。在Apache中可以用Alias,mod_rewrite或者DirectorySlash指令来取消不必要的重定向。</p><p>重定向最常见的用途就是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户账号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用<code>Alias</code>和<code>mod_rewrite</code>，前提是两个代码路径都在相同的服务器上。如果因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合<code>Alias</code>或者<code>mod_rewrite</code>指令。</p><h2 id="javascript-去除重复脚本"><a href="#javascript-去除重复脚本" class="headerlink" title="[javascript]去除重复脚本"></a>[javascript]去除重复脚本</h2><p>页面含有重复脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：<code>团队大小和脚本数量</code>。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的javascript代码，而影响页面性能。</p><p>IE会产生不必要的HTTP请求，而Firefox不会。在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载的时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。</p><p>除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的javascript代码。</p><p>避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中使用SCRIPT标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"path/to/*.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="服务器-配置ETags"><a href="#服务器-配置ETags" class="headerlink" title="[服务器]配置ETags"></a>[服务器]配置ETags</h2><p>实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETag可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的<code>ETag</code>来指定组件的ETag:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Last-Modified; Tue,12 Dec 2006 03:03:58 GMT</span><br><span class="line">ETag: <span class="string">"17hkh23-3hn-42kj23jlj"</span></span><br><span class="line">Content-Length: 12195</span><br></pre></td></tr></table></figure><p>然后，如果浏览器必须验证一个组件，它用<code>If-None-Match</code>请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /i/yahoo.gif HTTP/1.1</span><br><span class="line">      Host: us.yimg.com</span><br><span class="line">      If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line">      If-None-Match: <span class="string">"10c24bc-4ab-457e1c1f"</span></span><br><span class="line">      HTTP/1.1 304 Not Modified</span><br></pre></td></tr></table></figure><p>ETags存在的问题是它们由特定服务器构造的，所以如果浏览器从一个服务器获取最初的组件，然后想验证另一个服务器上的相同组件，ETags是无法匹配成功的，而用一群服务器处理请求在web站点中又非常普遍。默认情况下，Apache和IIS会在ETag中嵌入谁，以大大降低在服务器站点上有效性测试成功的几率。</p><h2 id="内容-让Ajax可缓存"><a href="#内容-让Ajax可缓存" class="headerlink" title="[内容]让Ajax可缓存"></a>[内容]让Ajax可缓存</h2><p>Ajax的一个好处是可以给用户提供即时反馈，因为它能够从后台服务器异步请求信息。然而，用Ajax就无法保证用户在等待异步javascript和XML响应返回期间不会非常无聊。在很多应用程序中，用户能够一直等待取决于如何使用Ajax。例如，在基于web的电子邮件客户端中，用户为了寻找符合他们搜索标准的邮件信息，将会保持对Ajax请求返回结果的关注。重要的是，要记得”异步”并不意味着”即时”。</p><p>要提高性能，优化这些Ajax响应至关重要。最重要的提高Ajax性能就是让响应变得可缓存，就像添上Expires或者Cache-Control HTTP头讨论的一样。下面适用于Ajax的其他规则：</p><ul><li><p>Gzip组件</p></li><li><p>减少DNS查找</p></li><li><p>压缩javascript</p></li><li><p>避免重定向</p></li><li><p>配置ETags</p></li></ul><p>我们看下例子，一个web 2.0的电子邮价客户端用了Ajax来下载用户的通讯录，以便实现自动完成功能。如果用户从上一次使用之后再没有修改过她的通讯录，而且Ajax响应是可以缓存的，有尚未过期的Expires或者Cache-Control HTTP头，那么之前的通讯录就可以从缓存中读出。必须通知浏览器，应该继续使用之前之前缓存的通讯录响应，还是去请求一个新的。可以通过给通讯录的Ajax URL里添加一个表明用户通讯录最后修改时间的时间戳来实现，例如<code>&amp;t=1190241612</code>。如果通讯录从上一次下载之后再没有被修改过，时间戳不变，通讯录就将从浏览器缓存中直接读出，从而避免一次额外的HTTP往返消耗。如果用户已经修改了通讯录，时间戳也可以确保新的URL不会匹配缓存的响应，浏览器将请求新的通讯录条目。</p><p>即使Ajax响应是动态创建的，而且可能只适用于单用户，它们也可以被缓存，而这样会让你的WEB 2.0应用更快。</p><h2 id="服务器-尽早清空缓存区"><a href="#服务器-尽早清空缓存区" class="headerlink" title="[服务器]尽早清空缓存区"></a>[服务器]尽早清空缓存区</h2><p>当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个<code>flush()</code>函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很<code>轻</code>的前端页面上（PS也就是说，响应时耗主要在后台方面时最能体现优势）。</p><p>比较理想的清空缓存区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和javascript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。</p><p>例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  ... &lt;!-- css, js --&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> flush(); <span class="meta">?&gt;</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  ... &lt;!-- content --&gt;</span><br></pre></td></tr></table></figure><p><a href="https://search.yahoo.com/" target="_blank" rel="noopener">Yahoo!搜索</a>开创了这项技术，而且真实用户测试研究也证明了使用这种技术的诸多好处。</p><h2 id="服务器-对Ajax用GET请求"><a href="#服务器-对Ajax用GET请求" class="headerlink" title="[服务器]对Ajax用GET请求"></a>[服务器]对Ajax用GET请求</h2><p><a href="https://login.yahoo.com/?.src=ym&amp;.intl=us&amp;.done=https%3A%2F%2Fmail.yahoo.com%2F" target="_blank" rel="noopener">Yahoo!邮箱</a>团队发现使用<code>XMLHttpRequest</code>时，浏览器的POST请求是通过一个两步的过程来实现的： 先发送HTTP头，再发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。</p><p>POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="noopener">HTTP说明文档</a>中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。</p><h2 id="内容-延迟加载组件"><a href="#内容-延迟加载组件" class="headerlink" title="[内容]延迟加载组件"></a>[内容]延迟加载组件</h2><p>javascript是分隔onload事件之前和之后的一个理想选择。例如，如果javascript代码和支持拖放以及动画的库，这些都可以先等会儿，因为拖放元素是在页面最初渲染之后的。其它延迟加载的部分，包括隐藏内容（在某个交互动作之后才出现的内容）和折叠的图片。</p><p>工具可以帮你减轻工作量:<a href="https://developer.yahoo.com/yui/imageloader/" target="_blank" rel="noopener">YUI Image Loader</a>可以延迟加载折叠的图片，还有<a href="https://developer.yahoo.com/yui/get/" target="_blank" rel="noopener">YUI Get utility</a>是一种引入javascript和css的简单方法。<a href="https://www.yahoo.com/" target="_blank" rel="noopener">Yahoo!主页</a>就是一个例子，可以打开Firebug的网络面板仔细看看。</p><p>最好让性能目标符合其它WEB开发最佳实践，比如”渐进增强”。如果客户端支持javascript，可以提高用户体验，但必须确保页面在不支持javascript时也能正常工作。所以，在确定页面运行正常之后，可以用一些延迟加载脚本增强它，以支持一些拖放和动画之类的华丽效果。</p><h2 id="内容-预加载组件"><a href="#内容-预加载组件" class="headerlink" title="[内容]预加载组件"></a>[内容]预加载组件</h2><p>预加载可能看起来和延迟加载是相反的，但它实际有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得很快的。</p><p>时间应用中有以下几种预加载的类型：</p><ul><li><p>无条件预加载 ： 尽快开始加载，获取一些额外的组件。google.com就是一个sprite图片预加载的好例子，这个sprite图片并不是google.com主页需要的，而是搜索结果页面上的内容。</p></li><li><p>条件性预加载 ： 根据用户操作猜测用户跳转到哪里并据此预加载。</p></li><li><p>提前预加载 ： 在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但是比以前更慢了”，一部分原因是用户访问之前的页面都是旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。</p></li></ul><h2 id="内容-减少DOM元素的数量"><a href="#内容-减少DOM元素的数量" class="headerlink" title="[内容]减少DOM元素的数量"></a>[内容]减少DOM元素的数量</h2><p>一个复杂的页面意味着要下载更多的字节，而且用javascript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素是有区别的。</p><p>大量的DOM元素是一种征兆 ： 页面上有些内容无关的标记需要清理。正在用嵌套表格来布局吗？还是为了修复布局问题而添加了一堆的<code>&lt;div&gt;</code>？或许应该用更好的语义化标记。</p><p>DOM元素的数量很容易测试，只需要在Firebug的控制台输入:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>).length;</span><br></pre></td></tr></table></figure><p>那么多少DOM元素才算是太多呢？可以参考其他类似的标记良好的页面，例如<a href="https://www.yahoo.com/" target="_blank" rel="noopener">Yahoo!主页</a>是一个相当繁忙的页面，但只有不到700个元素(HTML标签)。</p><h2 id="内容-跨域分离组件"><a href="#内容-跨域分离组件" class="headerlink" title="[内容]跨域分离组件"></a>[内容]跨域分离组件</h2><p>分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在<code>www.example.org</code>，而把静态组件分离到<code>static1.example.org</code>和<code>static2.example.org</code>。</p><p>更多信息请查看Tenni Theurer和Patty Chi的文章：<a href="https://yuiblog.com/blog/2007/04/11/performance-research-part-4/" target="_blank" rel="noopener">Maximizing Parallel Downloads in the Carpool Lane</a></p><h2 id="内容-尽量少使用iframe"><a href="#内容-尽量少使用iframe" class="headerlink" title="[内容]尽量少使用iframe"></a>[内容]尽量少使用iframe</h2><p>用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。</p><p><code>&lt;iframe&gt;</code>的优点：</p><ul><li><p>引入缓慢的第三方内容，比如标志和广告</p></li><li><p>安全沙箱</p></li><li><p>并行下载脚本</p></li></ul><p><code>&lt;iframe&gt;</code>的缺点：</p><ul><li><p>代价昂贵，即使是空白的iframe</p></li><li><p>阻塞页面加载</p></li><li><p>非语义</p></li></ul><h2 id="内容-杜绝404"><a href="#内容-杜绝404" class="headerlink" title="[内容]杜绝404"></a>[内容]杜绝404</h2><p>HTTP请求代价昂贵，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。</p><p>有些站点用的是有帮助的404 ： “你的意思是xxx？”，这样做有利于用户体验，但是也浪费了服务器的资源（比如数据库等等）。最糟糕的是连接到的外部javascript有错误而且结果是404。首先，这种下载将阻塞并行下载。其次，浏览器会试图解析404响应体，因为它是javascript代码，需要找出其中可以用的部分。</p><h2 id="cookie-给Cookie减肥"><a href="#cookie-给Cookie减肥" class="headerlink" title="[cookie]给Cookie减肥"></a>[cookie]给Cookie减肥</h2><p>使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。</p><p>更多信息请查看Tenni Theurer和Patty Chi的文章：<a href="https://yuiblog.com/blog/2007/03/01/performance-research-part-3/" target="_blank" rel="noopener">When the Cookie Crumbles</a>。相关经验原则可以总结如下：</p><ul><li><p>清除不必要的cookie</p></li><li><p>保证cookie尽可能小，以最小化对用户响应时间的影响</p></li><li><p>注意给cookie设置合适的域级别，以免影响其他子域</p></li><li><p>设置适合的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间</p></li></ul><h2 id="把组件放在不含cookie的域下"><a href="#把组件放在不含cookie的域下" class="headerlink" title="[把组件放在不含cookie的域下]"></a>[把组件放在不含cookie的域下]</h2><p>当浏览器发送静态图像的请求时，cookies也会一起发送，而服务器根本就不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署到那儿。</p><p>如果域名是<code>www.example.org</code>，可以把静态组件部署到<code>static.example.org</code>。然而，如果已经在顶级域<code>example.org</code>或者<code>www.example.org</code>设置了cookie，那么所有对<code>static.example.org</code>的请求都会含这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是<code>yimg.com</code>,YouTube是<code>ytimg.com</code>，亚马逊是<code>images-amazon.com</code>等等。</p><p>把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是www.example.org作为主页，可以考虑下cookie的影响。省略www的话，就只能把cookie写到<code>*.example.org</code>，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。</p><h2 id="javascript-尽量减少DOM访问"><a href="#javascript-尽量减少DOM访问" class="headerlink" title="[javascript]尽量减少DOM访问"></a>[javascript]尽量减少DOM访问</h2><p>用javascript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该：</p><ul><li><p>缓存已访问过的元素的索引</p></li><li><p>先“离线”更新节点，再把它们添加到DOM树上</p></li><li><p>避免用javascript修复布局问题</p></li></ul><p>更多信息请查看YUI影院里Julien Lecomte的文章：<a href="https://yuiblog.com/blog/2007/12/20/video-lecomte/" target="_blank" rel="noopener">High Performance Ajax Applications</a></p><h2 id="javascript-用智能的事件处理器"><a href="#javascript-用智能的事件处理器" class="headerlink" title="[javascript]用智能的事件处理器"></a>[javascript]用智能的事件处理器</h2><p>有时候感觉页面反应不够灵敏，是因为有太多频繁执行的事件处理器被添加到DOM树的不同元素上，这就是推荐使用<code>事件委托</code>的原因。如果一个<code>div</code>里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。</p><p>不需要为了处理DOM树而等待onload事件，通常只有目标元素在DOM树中可以访问即可，而不必等待所有的图片下载完成。可以考虑用<code>DOMContentLoaded</code>来替代onload事件，但为了让它在所有浏览器中都可用，可以用<a href="https://developer.yahoo.com/yui/event/" target="_blank" rel="noopener">YUI Event</a>工具，它有一个<a href="https://developer.yahoo.com/yui/event/#onavailable=" target="_blank" rel="noopener">onAvailable</a>方法。</p><p>更多信息请查看YUI影院里Julien Lecomte的文章：<a href="https://yuiblog.com/blog/2007/12/20/video-lecomte/" target="_blank" rel="noopener">High Performance Ajax Applications</a></p><h2 id="CSS-选择舍弃-import"><a href="#CSS-选择舍弃-import" class="headerlink" title="[CSS]选择舍弃@import"></a>[CSS]选择<link>舍弃@import</h2><p>前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。</p><p>在IE中用<code>@import</code>与底部用<code>&lt;link&gt;</code>效果一样，所以最好不要用它。</p><h2 id="CSS-避免使用滤镜"><a href="#CSS-避免使用滤镜" class="headerlink" title="[CSS]避免使用滤镜"></a>[CSS]避免使用滤镜</h2><p>IE专有的<code>AlphaImageLoader</code>滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个过滤会阻塞渲染，卡住浏览器，还会增加内存消耗而且被应用到每个元素的，而不是每个图片，所以会存在一大推问题。</p><p>最好的方法是干脆不要用<code>AlphaImageLoader</code>，而优雅地降级到用IE中支持性很好的PNG8图片来代替。如果非要用<code>AlphaImageLoader</code>，应该用下划线hack：<code>_filter</code>来避免影响IE7及更高版本的用户。</p><h2 id="图片-优化图片"><a href="#图片-优化图片" class="headerlink" title="[图片]优化图片"></a>[图片]优化图片</h2><p>设计师做好图之后，在把这些图通过FTP上传到web服务器之前，我们还可以做一些事情。</p><ul><li><p>检查GIF图片，看看图片中是不是用了调色板大小对应的颜色数，用<a href="http://www.imagemagick.org/script/index.php" target="_blank" rel="noopener">imagemagick</a>可以简单地检查：<code>identify -verbose image.gif</code>如果4色图片用了调色板中256色的“槽”，那就还有改进的余地</p></li><li><p>试着把GIF图片转换成PNG，看能不能缩减大小，往往可以。开发者通常不愿意用PNG图片，因为浏览器支持有限，但这都是过去的事情了。真正的问题是PNG图片完全支持alpha透明度，而GIF图片却不支持透明度渐变，所以GIF能做的任何事情,PNG都可以（除了动画）。下面这个简单的命令就能让PNG图片可以安全使用：<code>convert image.gif image.png</code>“我们强调的是：给PNG一个机会。”</p></li><li><p>用<a href="https://pmt.sourceforge.io/pngcrush/" target="_blank" rel="noopener">pngcrush</a>（或者其他的PNG优化工具）处理所有的PNG图片，例如：<code>pngcrush image.png -rem alla -reduce -brute result.png</code></p></li><li><p>用jpegtran处理所有JPEG图片，这个工具支持对JPEG图片的无损操作比如旋转，还可以用来去除注释和其他无用信息（比如EXIF信息 P.S.数码照片信息，焦距光圈之类的）：<code>jpegtran -copy none -optimize -perfect src.jpg dest.jpg</code></p></li></ul><h2 id="图片-优化CSS-Sprite"><a href="#图片-优化CSS-Sprite" class="headerlink" title="[图片]优化CSS Sprite"></a>[图片]优化CSS Sprite</h2><ul><li><p>在Sprite图片中横向排列一般都比纵向排列的最终文件小</p></li><li><p>组合Sprite图片中的相似颜色可以保持低色度，最理想的是256色以下PNG8格式</p></li><li><p>“对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会有很大程度上影响文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100 x 100的图片是1万个像素，而1000 x 1000的图片就是100万个像素了。</p></li></ul><h2 id="图片-不要用HTML缩放图片"><a href="#图片-不要用HTML缩放图片" class="headerlink" title="[图片]不要用HTML缩放图片"></a>[图片]不要用HTML缩放图片</h2><p>不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要<code>&lt;img width=&quot;100&quot; height=&quot;100&quot;src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot;&gt;</code>那么图片本身(mycat.jpg)应该是100 x 100px的，而不应该是去缩小500 x 500px的图片。</p><h2 id="图片-用更小的可缓存的favicon-ico（P-S-收藏夹图片）"><a href="#图片-用更小的可缓存的favicon-ico（P-S-收藏夹图片）" class="headerlink" title="[图片]用更小的可缓存的favicon.ico（P.S.收藏夹图片）"></a>[图片]用更小的可缓存的favicon.ico（P.S.收藏夹图片）</h2><p>favicon.ico是放在服务器根目录的图片，它会带来一大堆麻烦，因为即使你不管它，浏览器也会自动请求它，所以最好不要给一个<code>404 Not Found</code>响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。</p><p>所以为了缓解favicon.ico的缺点，应该确保:</p><ul><li><p>足够小，最好在1K以下</p></li><li><p>设置合理的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。</p></li></ul><p><a href="http://www.imagemagick.org/script/index.php" target="_blank" rel="noopener">Imagemagick</a>可以用来处理小收藏夹图标</p><h2 id="移动-保证所有组件都小于25K"><a href="#移动-保证所有组件都小于25K" class="headerlink" title="[移动]保证所有组件都小于25K"></a>[移动]保证所有组件都小于25K</h2><p>这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是<code>未压缩的</code>大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。</p><p>更多信息请查看Wayne Shea和Tenni Theurer的文章：<a href="https://yuiblog.com/blog/2008/02/06/iphone-cacheability/" target="_blank" rel="noopener">Performance Research, Part 5: iPhone Cacheability – Making it Stick</a></p><h2 id="移动-把组件打包到一个复合文档里"><a href="#移动-把组件打包到一个复合文档里" class="headerlink" title="[移动]把组件打包到一个复合文档里"></a>[移动]把组件打包到一个复合文档里</h2><p>把各个组件打包成一个像附有的电子邮件一样的符合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。</p><h2 id="服务器-避免图片src属性为空"><a href="#服务器-避免图片src属性为空" class="headerlink" title="[服务器]避免图片src属性为空"></a>[服务器]避免图片src属性为空</h2><p>Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现：</p><p>1.straight HTML</p><blockquote><p><img src=""></p></blockquote><p>2.Javascript</p><blockquote><p>var img = new Image();<br>img.src = “”</p></blockquote><p>这两种形式都会引起相同的问题：浏览器会向服务器发送另一个请求。</p><ul><li><p>IE向页面所在目录发起一个请求</p></li><li><p>Safari和Chrome想当前页面本身发送一个请求</p></li><li><p>Firefox3及更早版本与Safari和Chrome处理方式一样，但3.5解决了这个问题<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=444931" target="_blank" rel="noopener">bug 444931</a>，不会再发送请求了</p></li><li><p>Opera遇到有空src属性的图片不做任何处理</p></li></ul><p>为什么图片src属性为空不好？</p><p>1.意外发送大量的通信量对服务器来说是很伤的，尤其是在每天有几百万访问量页面的时候。</p><p>2.浪费服务器资源去生成一个根本不可能看到的页面</p><p>3.可能会污染用户数据，如果追踪请求状态，要么通过cookie要么是其它方式，可能会破坏用户数据。即使图片请求并没有返回图片，整个HTTP头部也会被浏览器接受并读取，包括所有的cookie。虽然其余部分会被丢弃，但这可能已经造成破坏了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ayqy.net/blog/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%EF%BC%9A%E9%9B%85%E8%99%8E35%E6%9D%A1/?utm_source=tuicool&amp;utm_medium=referral#r1" target="_blank" rel="noopener">前端优化：雅虎35条</a></p><p style="color: red;text-align:center;">精力有限，未能一次更新完毕，还请见谅…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/optimization/fontend-optimization-banner.jpg&quot; alt=&quot;frontend/optimization/fontend-optimization-banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;整理前端优化的方案，主要是雅虎的35条原则。欢迎补充哈 😊 &lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="读书" scheme="http://reng99.cc/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>重读《JavaScript高级程序设计》</title>
    <link href="http://reng99.cc/2018/03/01/javascript-high-level/"/>
    <id>http://reng99.cc/2018/03/01/javascript-high-level/</id>
    <published>2018-03-01T09:09:19.000Z</published>
    <updated>2018-06-11T02:16:22.295Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/life/learn/read/javascript/javascript_high_level.jpg" alt="life/learn/read/javascript/javascript_high_level"></p><p>最近自己在休假，打算闭门几天将《JavaScript高级程序设计》(第3版)这本良心教材再回顾一遍。目前自己进入前端领域两年多，现在重读并记录下这本教材的“硬”知识点 😊 。</p><a id="more"></a><h2 id="函数没有重载"><a href="#函数没有重载" class="headerlink" title="函数没有重载"></a>函数没有重载</h2><p>ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数类型和数量）不同即可[p66]。ECMAScript的类型是松散形的，没有签名，所以是没有重载的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">num,name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = load(<span class="number">100</span>); <span class="comment">// 200</span></span><br><span class="line"># 后面的函数声明覆盖掉前面的函数声明</span><br></pre></td></tr></table></figure><h2 id="基本的数据类型"><a href="#基本的数据类型" class="headerlink" title="基本的数据类型"></a>基本的数据类型</h2><p><strong>基本类型值</strong>指的是简单的数据段，而<strong>引用类型</strong>指那些可能由多个值构成的对象[p68]。这里指出来的基本的数据类型是说的es5的哈：<code>Undefined</code>,<code>Null</code>,<code>Boolean</code>,<code>Number</code>和<code>String</code>。</p><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>ECMAScript 中所有的函数的参数都是<code>按值传递</code>的[p70]。也就是说，把函数外部的值复制给函数内部的参数，就是把值从一个变量复制到另一个变量一样。<strong>基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。</strong>下面分开例子介绍两种不同类型为什么是按值传递。</p><h3 id="基本类型值"><a href="#基本类型值" class="headerlink" title="基本类型值"></a>基本类型值</h3><p>基本类型这个按值传递比较好理解，直接复制变量的值传递：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">num += <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 20 ，没有变化哈</span></span><br></pre></td></tr></table></figure><h3 id="引用类型值"><a href="#引用类型值" class="headerlink" title="引用类型值"></a>引用类型值</h3><p>有些人认为引用类型的传参是按照引用来传的，那暂且认为他们的理解是正确的，那下面的示例结果怎么解析呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">obj.name = <span class="string">'嘉明'</span>;</span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">'庞嘉明'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// '嘉明'，为啥不是'庞嘉明'呢？</span></span><br></pre></td></tr></table></figure><p>如果是按照引用传的话，那么新建的对象<code>obj = new Object()</code>应该是指向堆内容的对象啊，那么改变它本有的<code>name</code>属性值应该生效，然而并没有生效。所以它也是<code>按值传递</code>滴。</p><h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h2><p>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁[p111]。解析器会率先读取函数声明，并使其执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">//TypeError: sum is not a function</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apply和call"><a href="#apply和call" class="headerlink" title="apply和call"></a>apply和call</h2><p>每个函数都包含两个非继承而来的方法：<code>apply()和call()</code>。这两个方法的<strong>用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值</strong>[116]。call和apply在对象中还是挺有用处的。</p><p>apply()方法和call()方法的作用是相同的，区别在于接收参数的方式不同。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是<strong>参数数组</strong>，这里的参数数组可以是Array的实例，也可以是arguments对象（类数组对象）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">// 传入arguments类数组对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,[num1 , num2]); <span class="comment">// 传入数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>call()方法接收的第一个参数和apply()方法接收的一样，变化的是其余的参数直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.call(<span class="keyword">this</span> , sum1 , sum2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>虽然Object构造函数或者对象字面量都可以用来创建单个对象，但是这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。[p144]</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式就是造一个模子产生一个个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name , age ,job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = name;</span><br><span class="line">o.age = age;</span><br><span class="line">o.job = job;</span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">'greg'</span> , <span class="number">27</span> , <span class="string">'doctor'</span>);</span><br></pre></td></tr></table></figure><p> 工厂模式解决了创建多个相似对象的问题（解决创建对象时产生大量重复代码），但是没有解决对象识别的问题（即怎么知道一个对象的类型，是Person还是Animal啊）。</p><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>下面使用构造函数创建特定类型的对象。这里是Person类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , job</span>)</span>&#123; <span class="comment">// 注意构造函数的首字母为大写哦</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'greg'</span> , <span class="number">27</span> , <span class="string">'doctor'</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.constructor == Person); <span class="comment">// true 可以理解为person1的创造者是Person，也就是对象的类型Person</span></span><br></pre></td></tr></table></figure><p>在创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（因此this指向了这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><p>构造函数解决了重复实例话问题（也就是创建多个相似对象的问题）和解决了对象识别的问题。但是，像上面那样，person1和person2共有的方法，实例化的时候都创建了，这未免多余了。当然可以将共有的方法提取到外面，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'greg'</span> , <span class="number">27</span> , <span class="string">'doctor'</span>);</span><br></pre></td></tr></table></figure><p>将sayName提取出来，就成了全局的方法了，然而这里只有Person类创建对象的时候才使用到，这样就大才小用了吧，所以提取出来到全局方法这种操作不推荐。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>创建的每个函数都有一个prototype（原型）属性，这个属性就是一个指针，指向一个对象，而这个对象的用途就是包含可以由特定类型的所有实例共享的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'nicholas'</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以有关系图如下：</p><p><img src="http://omu538iq8.bkt.clouddn.com/life/learn/read/javascript/prototype_object.jpg" alt="life/learn/read/javascript/prototype_object"></p><p>上面的Person.prototype不建议使用字面量来写Person.prototype={},虽让效果一样，但是这里重写了原本Person.prototype的对象，因此constructor属性会指向Ohject而不是Person。当然也是可以处理的啦，将指向指正确并指定’construtor’的枚举属性为<code>enumerable: false</code>。</p><p>原型模式解决了函数共享的问题，但是也带了一个问题：实例化中对象的属性是独立的，而原型模式这里共享了。</p><h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>创建自定义类型的最常见的方式，就是组合使用构造函数模式和原型模式。<strong>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age ,job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="keyword">this</span>.friends = [<span class="string">'shelby'</span> , <span class="string">'court'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'greg'</span> , <span class="number">27</span> , <span class="string">'doctor'</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">'van'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">// 'shelby,court,van'</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// 'shelby,court'</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>其他的OO语言，比如java，创建对象的类中是包含了自身的属性、方法和共有的属性、方法，如下小狗的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name )</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">System.out.println(<span class="string">'小狗的名字是: '</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">'小狗的年龄为: '</span> + age);</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 创建对象 */</span></span><br><span class="line">Dog dog = <span class="keyword">new</span> Dog(<span class="string">'tom'</span>);</span><br><span class="line"><span class="comment">/* 通过方法来设定age */</span></span><br><span class="line">dog.setAge(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/* 调用另外一个方法获取age */</span></span><br><span class="line">dog.getAge();</span><br><span class="line"><span class="comment">/* 也可以通过 对象.属性名 获取 */</span></span><br><span class="line">System.out.println(<span class="string">'变量值: '</span> + dog.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了看起来是类那么一会事，动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age ,job</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>)&#123;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>在前面几种模式都不适应的情况下，可以用寄生构造函数模式（数据结构中就使用到哈），寄生构造函数模式可以看成是工厂模式和构造函数模式的结合体。其基本思想是<strong>创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = name;</span><br><span class="line">o.age = age;</span><br><span class="line">o.job = job;</span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span>, <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line">friend.sayName(); <span class="comment">// nicholas</span></span><br></pre></td></tr></table></figure><p>关于寄生构造函数模式，需要说明：返回的对象与构造函数或者与构造函数的原型属性直接没有什么关系；也就是说，构造函数返回的对象与构造函数外部创建的对象没有什么区别。为此，不能依赖instanceof操作符来确定对象类型。由于存在上面的问题，建议在可以使用其他模式的情况下，不要使用这种模式。</p><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>稳妥对象适合在一些安全的环境中（这些环境中会禁止使用this和new），或者防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但是有两点不同：意识新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , job</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 创建要返回的对象</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在这里定义私有的变量和函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(name);  <span class="comment">// 不使用this.name</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象</span></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">'nicholas'</span>, <span class="number">29</span> , <span class="string">'software engineer'</span>); <span class="comment">// 不使用new</span></span><br><span class="line">friend.sayName(); <span class="comment">// 'nicholas'</span></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>许多的OO语言都支持两种继承方法：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现主要是<strong>依靠原型链来实现的</strong>。[p162]</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链的基本思想是<strong>利用原型让一个引用类型继承另一个引用类型的属性和方法</strong>。回顾下构造函数、原型和实例的关系: 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了SuperType,重点哦</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中原型链如下：</p><p><img src="http://omu538iq8.bkt.clouddn.com/life/learn/read/javascript/prototype_chain.png" alt="life/learn/read/javascript/prototype_chain"></p><p>原型链继承带来两个问题：一是原型实际上变成了另一个类型的实例，于是，原先的实例属性也就变成了现在原型的属性，共享了属性。二是在创建子类型的实例时，不能在没有影响所有对象实例的情况下向超类型的构造函数传递参数。</p><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>借用构造函数解决原型链继承带来的不能向构造函数传递仓鼠的问题。这里使用到了apply()或者call()方法在新创建的对象上执行构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line">SubType.call(<span class="keyword">this</span>); <span class="comment">// 使用SubType.apply(this)同效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.color.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// 'red,blue,green,black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// 'red,blue,green'</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我在父类型构造函数中没有传参数，看者感兴趣的话可以自己加下参数来实验一番咯。</p><p>借用构造函数解决了原型链继承的确定，但是又没有接纳原型链的优点：共享。下面的组合继承结合了原型链和借用构造函数，容纳了两者的优点。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承的思路是<strong>使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 继承属性</span></span><br><span class="line">SuperType.call(<span class="keyword">this</span>,name);</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor =SubType; <span class="comment">// 避免重写构造函数指向错误</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'nicholas'</span> , <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// 'red,blue,green,black'</span></span><br><span class="line">instance1.sayName(); <span class="comment">// 'nicholas'</span></span><br><span class="line">instance1.sayAge(); <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'greg'</span> , <span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// 'red,blue,green'</span></span><br><span class="line">instance2.sayName(); <span class="comment">// 'greg'</span></span><br><span class="line">instance2.sayAge(); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，<code>成为了JavaScript中最常用的继承模式</code>。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。</p><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>原型式继承是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义的类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123; <span class="comment">// 传入一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype = o;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">'nicholas'</span>,</span><br><span class="line">friends: [<span class="string">'shelby'</span>,<span class="string">'court'</span>,<span class="string">'van'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">'greg'</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">'rob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">'linda'</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">'barbie'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends); <span class="comment">// 'shelby,court,van,rob,barbie'</span></span><br></pre></td></tr></table></figure><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是与原型继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即是创建了一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的做了所有工作一样返回对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123; <span class="comment">// 传入一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype = o;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> clone = object(original);</span><br><span class="line">clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">'nicholas'</span>,</span><br><span class="line">friends : [<span class="string">'shelby'</span>,<span class="string">'court'</span>,<span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">// 'hi'</span></span><br></pre></td></tr></table></figure><p>上面的例子中，新对象anotherPerson不仅具有person的所有属性和方法，而且还有了自己的sayHi()方法。</p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。寄生组合式继承能够解决这个问题。</p><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是<strong>不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型的原型的一个副本而已</strong>。寄生组合式继承的基本模式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> prototype = <span class="built_in">Object</span>(superType.prototype); <span class="comment">// 创建对象</span></span><br><span class="line">prototype.constructor = subType; <span class="comment">// 增强对象，防止下面重写constructor属性</span></span><br><span class="line">subType.prototype = prototype; <span class="comment">// 指定对象</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个完整的例子如下,相关插图见书[p173]:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> prototype = <span class="built_in">Object</span>(superType.prototype);</span><br><span class="line">prototype.constructor = subType;</span><br><span class="line">subType.prototype = prototype;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.color = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">SuperType.call(<span class="keyword">this</span>,age); <span class="comment">// 只在这调用了一次超类型的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType , SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">'nicholas'</span> , <span class="number">29</span>);</span><br></pre></td></tr></table></figure><p>上面的例子的高效处体现在它只调用了一次SuperType构造函数，并且避免了在SubType.prototype上创建不必要的，多余的属性。与此同时，原型链还能保持不变；因此还能正常使用instanceof和inPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。我的理解是，函数内的函数使用到外层函数的变量延长变量的生存时间，造成常驻内存。例子见下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 3</span></span><br><span class="line">baz(); <span class="comment">// 4</span></span><br><span class="line">baz(); <span class="comment">// 5</span></span><br><span class="line">baz(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>上面的例子中，外部的函数foo()执行完成之后，正常的情况下应该销毁a变量的，但是内部的返回的匿名函数使用到该变量，不能销毁。如果需要销毁的话，可以改写成下面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line">baz(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">baz = <span class="literal">null</span>; <span class="comment">// 将内部的匿名函数赋值为空</span></span><br></pre></td></tr></table></figure><h2 id="从闭包说起"><a href="#从闭包说起" class="headerlink" title="从闭包说起"></a>从闭包说起</h2><p>谈到了闭包，这让我想起了不久前刷知乎看到一篇<a href="https://zhuanlan.zhihu.com/p/25855075" target="_blank" rel="noopener">文章</a>。自己整理如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5,5,5,5,5,5</span></span><br></pre></td></tr></table></figure><p>上面的代码是输出了6个5，而这6个5是这样执行的，先输出全局中的<code>console.log(i)</code>，然后是过了1秒种后，瞬间输出了5个5（为什么用瞬间这个词呢，怕看者理解为每过一秒输出一个5）。解读上面的代码的话，可以通过狭义范围(es5)的理解：同步 =&gt; 异步 =&gt; 回调 （回调也是属于异步的范畴，所以我这里指明了狭义啦）。先是执行同步的for,遇到异步的setTimeout(setTimeout和setInterval属于异步哈)后将其放入队列中等待，接着往下执行全局的<code>console.log(i)</code>，将其执行完成后执行异步的队列。</p><p><strong>追问1:闭包</strong></p><p>改写上面的代码，期望输出的结果为：5 =&gt; 0,1,2,3,4。改造的方式一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(j);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5,0,1,2,3,4</span></span><br></pre></td></tr></table></figure><p>上面的代码巧妙的利用IIFE(Immediately Invoked Function Expression:声明即执行的函数表达式)来解决闭包造成的问题，闭包的解析看上面。</p><p>方法二：利用js中基本类型的参数传递是按值传递的特征，改造代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> output = <span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">output(i); <span class="comment">// 这里传过去的i值被复制了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5,0,1,2,3,4</span></span><br></pre></td></tr></table></figure><p>上面改造的两个方法都是执行代码后先输出5，然后过了一秒种依次输出0,1,2,3,4。</p><p>如果不要考虑全局中的<code>console.log(i)</code>输出的5，而是循环中输出的0,1,2,3,4。你还可以使用ES6的<code>let</code>块级作用域语法,实现超级简单:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0,1,2,3,4</span></span><br></pre></td></tr></table></figure><p>上面是过了一秒钟后，依次输出0,1,2,3,4。这种做法类似于无形中添加了闭包。那么，如果使用ES6语法的话，会怎样实现<code>5,0,1,2,3,4</code>呢？</p><p><strong>追问2:ES6</strong></p><p>改造刚开始的代码使得输出的结果是每隔一秒输出0,1,2,3,4，大概第五秒输出5。</p><p>在不使用ES6的情况下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(j);</span><br><span class="line">&#125;,<span class="number">1000</span>*j);</span><br><span class="line">&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>*i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0,1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p>上面的代码简单粗暴，但是不推荐。看题目是每隔一秒输出一个值，再回调实现最后的5输出，这个时候应该使用ES6语法来考虑，应该使用Promise方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;<span class="comment">// 这里的i声明不能改成let，改成let的话请看下一段代码</span></span><br><span class="line">(<span class="function">(<span class="params">j</span>)=&gt;</span>&#123;</span><br><span class="line">tasks.push(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123; <span class="comment">// 执行tasks</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(j);</span><br><span class="line">resolve(); <span class="comment">// 这里一定要resolve,否则代码不会按照预期执行</span></span><br><span class="line">&#125;,<span class="number">1000</span>*j);</span><br><span class="line">&#125;))</span><br><span class="line">&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// 执行完tasks，回调</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合要求的每隔一秒输出</span></span><br><span class="line"><span class="comment">// 0,1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p>如果是使用<code>let</code>，我的改造如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">tasks.push(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">resolve();</span><br><span class="line">&#125;, <span class="number">1000</span> * i);</span><br><span class="line">&#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(tasks.length);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0,1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p>上面的代码比较庞杂，可以将其颗粒话，模块化。对上面两段代码的带<code>var</code>那段进行改造后如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []; <span class="comment">// 这里存放异步操作的Promise</span></span><br><span class="line"><span class="keyword">const</span> output = <span class="function">(<span class="params">i</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>*i);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成全部的异步操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">tasks.push(output(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步操作完成之后，输出最后的i</span></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合要求的每隔一秒输出</span></span><br><span class="line"><span class="comment">// 0,1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p><strong>追问3:ES7</strong></p><p>既然ES6的Promise可以写，那么ES7是否可以写呢，从而让代码更加简洁易读？那就使用到到了异步操作的<code>async await</code>特性啦。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟其他语言中的sleep，实际上可以是任何异步操作</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">time</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(resolve , time);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合要求的每隔一秒输出</span></span><br><span class="line"><span class="comment">// 0,1,2,3,4,5</span></span><br></pre></td></tr></table></figure><h2 id="浏览器窗口位置"><a href="#浏览器窗口位置" class="headerlink" title="浏览器窗口位置"></a>浏览器窗口位置</h2><p>IE、Safari、Opera和Chrome都提供了screenLeft和screenTop属性，分别表示浏览器窗口相对于屏幕左上角和上边的位置[p197]。Firefox则以screenX和screenY属性来表示。为了兼容各个浏览器，可以入下面这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>)?<span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>)? <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure><h2 id="浏览器窗口大小"><a href="#浏览器窗口大小" class="headerlink" title="浏览器窗口大小"></a>浏览器窗口大小</h2><p>由于浏览器厂商以及历史的问题，无法确认浏览器本身的大小，但是可以取得视口的大小[p198]。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">'CSS1Compat'</span>)&#123; <span class="comment">// 标准模式下的低版本ie</span></span><br><span class="line">pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123; <span class="comment">// 混杂模式下的chrome</span></span><br><span class="line">pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例可以简写成下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line"><span class="keyword">var</span> pageHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight;</span><br></pre></td></tr></table></figure><h2 id="canvas中的变换"><a href="#canvas中的变换" class="headerlink" title="canvas中的变换"></a>canvas中的变换</h2><p>为绘制上下文应用变换，会导致使用不同的变换矩阵应用处理，从而产生不同的结果。[p453]</p><p>可通过下面的方法来修改变换矩阵:</p><ul><li>rotation(angle):围绕原点旋转图像angle弧度</li><li>scale(scaleX,scaleY)</li><li>translate(x,y): 将坐标原点移动到(x,y)。执行这个变换后，坐标(0,0)会变成之前由(x,y)表示的点。</li></ul><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>关于JSON，最重要的是要理解它是一种数据格式，不是一种编程语言。</p><h3 id="对象字面量和JSON格式比较"><a href="#对象字面量和JSON格式比较" class="headerlink" title="对象字面量和JSON格式比较"></a>对象字面量和JSON格式比较</h3><p>先来看下对象字面量demo写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">"nicholas"</span>,</span><br><span class="line">age : <span class="number">29</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 上面的代码也可以写成下面的</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"><span class="string">"name"</span> : <span class="string">"nicholas"</span>,</span><br><span class="line"><span class="string">"age"</span> : <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而上面的对象写成数据的话，就是下面这样了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"nicholas "</span>,</span><br><span class="line"><span class="attr">"age"</span>: <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 可到网站 https://www.bejson.com/ 验证</span><br></pre></td></tr></table></figure><p>⚠️ 与JavaScript对象字面量相比，JSON对象又两个地方不一样。首先，没有声明变量(JSON中没有变量的概念)。其次，没有分号(因为这不是JavaScript语句，所以不需要分号)。留意的是，对象的属性必须加双引号(不是单引号哦)，这在JSON中是必须的。</p><h3 id="stringify-和parse"><a href="#stringify-和parse" class="headerlink" title="stringify()和parse()"></a>stringify()和parse()</h3><p>可以这么理解：JSON.stringify()是从一个object中解析成JSON数据格式，而JSON.parse()是从一个字符串中解析成JSON数据格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">'nicholas'</span>,</span><br><span class="line">age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(person);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(jsonText);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;"name":"nicholas","age":29&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strPerson = <span class="string">'&#123;"name":"nicholas","age":29&#125;'</span>;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.parse(strPerson);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(jsonText); <span class="comment">// &#123; name: 'nicholas', age: 29 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h2><p>XMLHttpRequest对象用于在后台与服务器交换数据。它是Ajax技术的核心[p571]。</p><p>XMLHttpRequest对象能够使你：</p><ul><li>在不重新加载页面的情况下更新网页 </li><li>在页面已加载后从服务器请求数据</li><li>在页面已加载后从服务器接收数据</li><li>在后台向服务器发送数据</li></ul><p>XMLHttpRequest的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 创建XHR对象 =&gt; open()准备发送 =&gt; send()传送数据</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象，对浏览器做兼容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">'undefined'</span>)&#123; <span class="comment">// IE7+和其他浏览器支持</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> ActiveXObject != <span class="string">'undefined'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">'string'</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> versions = [<span class="string">'MSXML2.XMLHttp.6.0'</span>,<span class="string">'MSXML2.XMLHttp.3.0'</span>,<span class="string">'MSXML2.XMLHttp'</span>]; <span class="comment">// 低版的ie可能遇到三种不同版本的XMR对象</span></span><br><span class="line"><span class="keyword">var</span> i , len;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>,len = versions.length; i &lt; len ; i++)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">new</span> ActiveXObject(version[i]);</span><br><span class="line"><span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span> (ex)&#123;</span><br><span class="line"><span class="comment">// 跳过</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No XHR object available."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备发送数据</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"path/to/example.txt"</span>,<span class="literal">false</span>);<span class="comment">// 非异步，异步的话第三个参数改为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传送数据</span></span><br><span class="line">xhr.send(<span class="literal">null</span>); <span class="comment">// get方法不需要传数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断状态嘛，获取服务器返回的数据</span></span><br><span class="line"><span class="keyword">if</span>((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Request was nsuccessful : "</span> + xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><p>何为跨域呢？只要访问的资源的协议、域名、端口三个不全相同，就可以说是非同源策略而产生了跨域了，这是狭义的说法。广义的说法：通过XHR实现Ajax通信的一个主要限制，来源于跨域的安全策略；默认情况下,XHR对象只能访问包含它的页面位于同一个域中的资源[p582]。注：部分文字和代码引用自<a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a></p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS（Cross-Origin Resource Sharing，跨资源共享）定义了在必须访问跨资源时，浏览器与服务器应该如何沟通。其背后的基本思想，就是<strong>使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</strong> 复杂的跨域请求应当考虑使用它。</p><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无需设置，如果要带cookie请求：前后端都要设置。</p><p>1.前端设置</p><p>1.) 原生ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span>(<span class="params">method,url</span>)</span>&#123; <span class="comment">// 兼容处理，ie8/9需要用到window.XDomainRequest</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr)&#123; <span class="comment">// 其他的用到withCredentials</span></span><br><span class="line">xhr.open(method,url,<span class="literal">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> XDomainRequest != <span class="string">'undefined'</span>)&#123;</span><br><span class="line">xhr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">xhr.open(method , url);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">xhr = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get请求</span></span><br><span class="line"><span class="keyword">var</span> request = createCORSRequest(<span class="string">"get"</span>,<span class="string">"http://www.somewhere-else.com/page/"</span>);</span><br><span class="line"><span class="keyword">if</span>(request)&#123;</span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//  对request.responseText 进行处理 </span></span><br><span class="line">&#125;;</span><br><span class="line">request.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// post请求，带cookie</span></span><br><span class="line"><span class="keyword">var</span> requestXhr = createCORSRequest(<span class="string">"post"</span>,<span class="string">"http://www.somewhere-else.com/page/"</span>);</span><br><span class="line">requestXhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">requestXhr.send(<span class="string">"user=admin"</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.)jquery ajax </p><p>上面写了一大堆原生的，看得头都有点大了，还是使用jquery ajax 比较舒服:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">...</span><br><span class="line">xhrFields: &#123;</span><br><span class="line">withCredentials: <span class="literal">true</span> <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">&#125;,</span><br><span class="line">crossDomain: <span class="literal">true</span>, <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span></span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.) vue框架</p><p>在vue-resource封装的ajax组建中加入以下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.credentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>2.服务器设置</p><p>若后端设置成功，前端浏览器控制台上就不会出现跨域报错的信息，反之，说明没有成功。</p><p>1.） java后台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 导入包：import javax.servlet.http.HttpServletResponse;</span></span><br><span class="line"><span class="comment"> * 接口参数中定义：HttpServletResponse response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://www.domain1.com"</span>);  <span class="comment">// 若有端口需写全（协议+域名+端口）</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>2.) node后台</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据块接收中</span></span><br><span class="line">    req.addListener(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据接收完毕</span></span><br><span class="line">    req.addListener(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨域后台设置</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="string">'true'</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">            <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://www.domain1.com'</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">            <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>   <span class="comment">// HttpOnly:脚本无法读取cookie</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res.write(<span class="built_in">JSON</span>.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是JSON with padding(填充式JSON或参数式JSON)的简写，是应用JSON的一种新方法，在后来的web服务中非常流行。简单的跨域请求用JSONP即可。</p><p>通常为了减轻web服务器的负载，我们把js,css,img等静态资源分离到另一台独立域名的服务器，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p><p>1.前端实现</p><p>1.）原生实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">script.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 传参并指定回调执行函数为onBack</span></span></span><br><span class="line"><span class="javascript">script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 回调执行函数</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">onBack</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(res));</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务器返回如下（返回时即执行全局函数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onBack(&#123;<span class="string">"status"</span>: <span class="literal">true</span>,<span class="string">"user"</span>:<span class="string">"admin"</span>&#125;)</span><br></pre></td></tr></table></figure><p>2.）jquery ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url: <span class="string">'http://www.domain2.com:8080/login'</span>,</span><br><span class="line">type: <span class="string">'get'</span>,</span><br><span class="line">dataType: <span class="string">'jsonp'</span>, <span class="comment">// 请求方式为jsonp </span></span><br><span class="line">jsonpCallback: <span class="string">'onBack'</span>, <span class="comment">// 自定义回调函数名</span></span><br><span class="line">data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.）vue.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.jsonp(<span class="string">'http://www.domain2.com:8080/login'</span>,&#123;</span><br><span class="line">params: &#123;&#125;,</span><br><span class="line">jsonp: <span class="string">'onBack '</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.后端nodejs代码的示范：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> params = qs.parse(req.url.split(<span class="string">'?'</span>)[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">var</span> fn = params.callback;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonp返回设置</span></span><br><span class="line">res.writeHead(<span class="number">200</span>,&#123;<span class="string">"Content-Type"</span>:<span class="string">"text/javascript"</span>&#125;);</span><br><span class="line">res.write(fn + <span class="string">'('</span>+<span class="built_in">JSON</span>.stringify(params)+<span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080 ...'</span>);</span><br></pre></td></tr></table></figure><p>⚠️ jsonp缺点：</p><ol><li><p>jsonp只支持get请求而不支持post请求，也就是说如果想传给后台一个json格式的数据，此时问题就来了，浏览器回报一个http状态码415错误，告诉你请求格式不正确。</p></li><li><p>存在明显的安全性问题，容易收到xss攻击</p></li></ol><h3 id="WebSocket协议跨域"><a href="#WebSocket协议跨域" class="headerlink" title="WebSocket协议跨域"></a>WebSocket协议跨域</h3><p>WebSocket protocol 是 HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯。</p><p>原生的WebSocket API使用起来不太方便，示例中使用了<a href="https://socket.io/" target="_blank" rel="noopener">socket.io</a>，它很好的封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1.前端代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>user input：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> socket = io(<span class="string">'http://www.domain2.com:8080'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="javascript">socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'data from server: ---&gt; '</span> + msg); </span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端关闭</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Server socket has closed.'</span>); </span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    socket.send(<span class="keyword">this</span>.value);</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.node socket后台</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Content-type'</span>: <span class="string">'text/html'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 接收信息</span></span><br><span class="line">    client.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        client.send(<span class="string">'hello：'</span> + msg);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data from client: ---&gt; '</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开处理</span></span><br><span class="line">    client.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Client socket has closed.'</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="requestAnimationFrame-帧动画"><a href="#requestAnimationFrame-帧动画" class="headerlink" title="requestAnimationFrame()帧动画"></a>requestAnimationFrame()帧动画</h2><p>requestAnimationFrame 创建平滑的动画[p682]。在此之前都是使用setTimeout或者setInterval实现，requestAnimationFrame与它们相比：</p><ul><li>不需要时间间隔，会贴切浏览器的刷新频率</li><li>在切换到另外的页面时，会停止运行</li></ul><p>使用的示范如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"num"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  兼容浏览器</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>,<span class="string">'moz'</span>,<span class="string">'ms'</span>,<span class="string">'-o'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>;x &lt;vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; ++x)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">'cancelAnimationFrame'</span>] || <span class="built_in">window</span>[vendors[x] + <span class="string">'CancelRequestAnimationFrame'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.requestAnimationFrame)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> currTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">            <span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">16</span> - (currTime - lastTime));</span><br><span class="line">            <span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                callback;</span><br><span class="line">            &#125;,timeToCall);</span><br><span class="line">            lastTime = currTime - timeToCall;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.cancelAnimationFrame)&#123;</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>)</span>&#123;</span><br><span class="line">            clearTimeout(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的计数</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>,</span><br><span class="line"> timer;</span><br><span class="line">fn();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'num'</span>).innerText = ++num;</span><br><span class="line">timer = requestAnimationFrame(fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">cancelAnimationFrame(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/life/learn/read/javascript/javascript_high_level.jpg&quot; alt=&quot;life/learn/read/javascript/javascript_high_level&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近自己在休假，打算闭门几天将《JavaScript高级程序设计》(第3版)这本良心教材再回顾一遍。目前自己进入前端领域两年多，现在重读并记录下这本教材的“硬”知识点 😊 。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="读书" scheme="http://reng99.cc/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="javascript" scheme="http://reng99.cc/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>我的2018计划</title>
    <link href="http://reng99.cc/2018/02/21/my-2018-plans/"/>
    <id>http://reng99.cc/2018/02/21/my-2018-plans/</id>
    <published>2018-02-21T15:01:49.000Z</published>
    <updated>2018-05-28T12:08:09.041Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/life/plans/2018/plan_logo.jpg" alt="life/plans/2018/plan_logo.jpg"></p><p>嗖～嗖～嗖～～～🚀现在是农历正月初六的晚上十一点多，第二天就得上班了呢，一年的时间过得真是賊快，来不及感叹2017年自己做了什么，只想着眼现在，立flag啦，鬼知道我会在新的一年会遇到什么人和事情呢。希望一年后回头看不打脸咯…</p><a id="more"></a><h3 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h3><p>看完下面的推荐书籍中的3-5本：</p><ol><li>保罗.约翰逊 《文明的解析》</li><li>乔治.阿克洛夫 《动物精神》</li><li>南希.休斯顿 《断层线》</li><li>安德鲁.罗斯.索尔金 《大而不倒》</li><li>保罗.克利尔 《被掠夺的星球》</li><li>马特.里德利 《理智的乐观者》</li><li>丹.艾瑞里 《非理性的积极力量》</li><li>莱茵哈特.罗格夫 《这次不一样》</li><li>乔纳森.弗兰岑 《自由》</li><li>里查德.克拉克和罗伯特.克纳克 《网络战争》</li><li>巴塞维奇 《华盛顿规则》</li><li>查布里斯.西蒙斯 《看不见的大猩猩》</li><li>托尼.朱特 《乡土式微》</li><li>阿维沙伊.马加利特 《关于妥协和卑微的妥协》</li><li>奇普.希思 《瞬变》</li><li>刘易斯 《大空头》</li><li>查尔斯.默里 《人类成就》</li><li>瓦茨拉夫.斯米尔 《能源神话与现实》</li><li>南丹.尼莱卡尼 《印度畅想》</li><li>克莱.舍基 《未来是湿的》</li></ol><h3 id="深造"><a href="#深造" class="headerlink" title="深造"></a>深造</h3><p>好吧，过年回去已经跟家人达成协议，2018要把考研列入其中(虽然感觉2018年考进是不可能的，还是立下flag咯)，嗯，工作之余努力读书哦，除了程序猿一职，我还有一职—-永远都是学生哈哈哈。对了，英文提高很重要，这也涉及到下面的技能提升。</p><h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>作为一个码农，自己的码农技能总得上升一个阶段吧。将javascript的使用不仅仅局限于前端。自己的工作不仅仅是前端。相关的技能是html/html5,css/css3和javascript为主，java等为辅。</p><h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><p>下面的地点选择1-2进行旅游:</p><ol><li>泰国</li><li>新疆</li><li>云南</li><li>海南</li><li>成都</li><li>杭州</li><li>北京</li><li>潮汕</li><li>厦门</li><li>成都</li></ol><p>就此打住了，这么列下来，感觉自己2018年要累成狗。希望能完成这些模糊又肯定的目标，对了，希望在新的一年里面能够遇到对的那个人 😂</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/life/plans/2018/plan_logo.jpg&quot; alt=&quot;life/plans/2018/plan_logo.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;嗖～嗖～嗖～～～🚀现在是农历正月初六的晚上十一点多，第二天就得上班了呢，一年的时间过得真是賊快，来不及感叹2017年自己做了什么，只想着眼现在，立flag啦，鬼知道我会在新的一年会遇到什么人和事情呢。希望一年后回头看不打脸咯…&lt;/p&gt;
    
    </summary>
    
      <category term="诗和远方" scheme="http://reng99.cc/categories/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
    
      <category term="计划" scheme="http://reng99.cc/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
</feed>
