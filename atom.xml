<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Reng の 博客</title>
  
  <subtitle>If you don&#39;t think, then you shouldn&#39;t talk.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://reng99.cc/"/>
  <updated>2018-03-02T07:20:35.711Z</updated>
  <id>http://reng99.cc/</id>
  
  <author>
    <name>嘉明</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重读《JavaScript高级程序设计》</title>
    <link href="http://reng99.cc/2018/03/01/javascript-high-level/"/>
    <id>http://reng99.cc/2018/03/01/javascript-high-level/</id>
    <published>2018-03-01T09:09:19.000Z</published>
    <updated>2018-03-02T07:20:35.711Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/life/learn/read/javascript/javascript_high_level.jpg" alt="life/learn/read/javascript/javascript_high_level"></p><p>最近自己在休假，打算闭门几天将《JavaScript高级程序设计》(第3版)这本良心教材再回顾一遍。目前自己进入前端领域两年多，现在重读并记录下这本教材的“硬”知识点 😊 。另外，自己已经提交离职申请，3月底可入职新平台，哪位伯乐推荐下前端岗位过来下哈，感激不尽，个人线上简历请猛戳<a href="http://reng99.cc/about/">这里</a></p><a id="more"></a><h2 id="函数没有重载"><a href="#函数没有重载" class="headerlink" title="函数没有重载"></a>函数没有重载</h2><p>ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数类型和数量）不同即可[p66]。ECMAScript的类型是松散形的，没有签名，所以是没有重载的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">num,name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = load(<span class="number">100</span>); <span class="comment">// 200</span></span><br><span class="line"># 后面的函数声明覆盖掉前面的函数声明</span><br></pre></td></tr></table></figure><h2 id="基本的数据类型"><a href="#基本的数据类型" class="headerlink" title="基本的数据类型"></a>基本的数据类型</h2><p><strong>基本类型值</strong>指的是简单的数据段，而<strong>引用类型</strong>指那些可能由多个值构成的对象[p68]。这里指出来的基本的数据类型是说的es5的哈：<code>Undefined</code>,<code>Null</code>,<code>Boolean</code>,<code>Number</code>和<code>String</code>。</p><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>ECMAScript 中所有的函数的参数都是<code>按值传递</code>的[p70]。也就是说，把函数外部的值复制给函数内部的参数，就是把值从一个变量复制到另一个变量一样。<strong>基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。</strong>下面分开例子介绍两种不同类型为什么是按值传递。</p><h3 id="基本类型值"><a href="#基本类型值" class="headerlink" title="基本类型值"></a>基本类型值</h3><p>基本类型这个按值传递比较好理解，直接复制变量的值传递：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">num += <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = addTen(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 20 ，没有变化哈</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><h3 id="引用类型值"><a href="#引用类型值" class="headerlink" title="引用类型值"></a>引用类型值</h3><p>有些人认为引用类型的传参是按照引用来传的，那暂且认为他们的理解是正确的，那下面的示例结果怎么解析呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">obj.name = <span class="string">'嘉明'</span>;</span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">'庞嘉明'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// '嘉明'，为啥不是'庞嘉明'呢？</span></span><br></pre></td></tr></table></figure><p>如果是按照引用传的话，那么新建的对象<code>obj = new Object()</code>应该是指向堆内容的对象啊，那么改变它本有的<code>name</code>属性值应该生效，然而并没有生效。所以它也是<code>按值传递</code>滴。</p><h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h2><p>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁[p111]。解析器会率先读取函数声明，并使其执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">//TypeError: sum is not a function</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apply和call"><a href="#apply和call" class="headerlink" title="apply和call"></a>apply和call</h2><p>每个函数都包含两个非继承而来的方法：<code>apply()和call()</code>。这两个方法的<strong>用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值</strong>[116]。call和apply在对象中还是挺有用处的。</p><p>apply()方法和call()方法的作用是相同的，区别在于接收参数的方式不同。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是<strong>参数数组</strong>，这里的参数数组可以是Array的实例，也可以是arguments对象（类数组对象）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">// 传入arguments类数组对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,[num1 , num2]); <span class="comment">// 传入数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>call()方法接收的第一个参数和apply()方法接收的一样，变化的是其余的参数直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.call(<span class="keyword">this</span> , sum1 , sum2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>虽然Object构造函数或者对象字面量都可以用来创建单个对象，但是这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。[p144]</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式就是造一个模子产生一个个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name , age ,job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = name;</span><br><span class="line">o.age = age;</span><br><span class="line">o.job = job;</span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">'greg'</span> , <span class="number">27</span> , <span class="string">'doctor'</span>);</span><br></pre></td></tr></table></figure><p> 工厂模式解决了创建多个相似对象的问题（解决创建对象时产生大量重复代码），但是没有解决对象识别的问题（即怎么知道一个对象的类型，是Person还是Animal啊）。</p><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>下面使用构造函数创建特定类型的对象。这里是Person类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , job</span>)</span>&#123; <span class="comment">// 注意构造函数的首字母为大写哦</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'greg'</span> , <span class="number">27</span> , <span class="string">'doctor'</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.constructor == Person); <span class="comment">// true 可以理解为person1的创造者是Person，也就是对象的类型Person</span></span><br></pre></td></tr></table></figure><p>在创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（因此this指向了这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><p>构造函数解决了重复实例话问题（也就是创建多个相似对象的问题）和解决了对象识别的问题。但是，像上面那样，person1和person2共有的方法，实例化的时候都创建了，这未免多余了。当然可以将共有的方法提取到外面，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'greg'</span> , <span class="number">27</span> , <span class="string">'doctor'</span>);</span><br></pre></td></tr></table></figure><p>将sayName提取出来，就成了全局的方法了，然而这里只有Person类创建对象的时候才使用到，这样就大才小用了吧，所以提取出来到全局方法这种操作不推荐。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>创建的每个函数都有一个prototype（原型）属性，这个属性就是一个指针，指向一个对象，而这个对象的用途就是包含可以由特定类型的所有实例共享的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'nicholas'</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以有关系图如下：</p><p><img src="http://omu538iq8.bkt.clouddn.com/life/learn/read/javascript/prototype_object.jpg" alt="life/learn/read/javascript/prototype_object"></p><p>上面的Person.prototype不建议使用字面量来写Person.prototype={},虽让效果一样，但是这里重写了原本Person.prototype的对象，因此constructor属性会指向Ohject而不是Person。当然也是可以处理的啦，将指向指正确并指定’construtor’的枚举属性为<code>enumerable: false</code>。</p><p>原型模式解决了函数共享的问题，但是也带了一个问题：实例化中对象的属性是独立的，而原型模式这里共享了。</p><h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>创建自定义类型的最常见的方式，就是组合使用构造函数模式和原型模式。<strong>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age ,job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="keyword">this</span>.friends = [<span class="string">'shelby'</span> , <span class="string">'court'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'greg'</span> , <span class="number">27</span> , <span class="string">'doctor'</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">'van'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">// 'shelby,court,van'</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// 'shelby,court'</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>其他的OO语言，比如java，创建对象的类中是包含了自身的属性、方法和共有的属性、方法，如下小狗的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name )</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">System.out.println(<span class="string">'小狗的名字是: '</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">'小狗的年龄为: '</span> + age);</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 创建对象 */</span></span><br><span class="line">Dog dog = <span class="keyword">new</span> Dog(<span class="string">'tom'</span>);</span><br><span class="line"><span class="comment">/* 通过方法来设定age */</span></span><br><span class="line">dog.setAge(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/* 调用另外一个方法获取age */</span></span><br><span class="line">dog.getAge();</span><br><span class="line"><span class="comment">/* 也可以通过 对象.属性名 获取 */</span></span><br><span class="line">System.out.println(<span class="string">'变量值: '</span> + dog.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了看起来是类那么一会事，动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age ,job</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>)&#123;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>在前面几种模式都不适应的情况下，可以用寄生构造函数模式（数据结构中就使用到哈），寄生构造函数模式可以看成是工厂模式和构造函数模式的结合体。其基本思想是<strong>创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = name;</span><br><span class="line">o.age = age;</span><br><span class="line">o.job = job;</span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span>, <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line">friend.sayName(); <span class="comment">// nicholas</span></span><br></pre></td></tr></table></figure><p>关于寄生构造函数模式，需要说明：返回的对象与构造函数或者与构造函数的原型属性直接没有什么关系；也就是说，构造函数返回的对象与构造函数外部创建的对象没有什么区别。为此，不能依赖instanceof操作符来确定对象类型。由于存在上面的问题，建议在可以使用其他模式的情况下，不要使用这种模式。</p><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>稳妥对象适合在一些安全的环境中（这些环境中会禁止使用this和new），或者防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但是有两点不同：意识新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , job</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 创建要返回的对象</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在这里定义私有的变量和函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(name);  <span class="comment">// 不使用this.name</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象</span></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">'nicholas'</span>, <span class="number">29</span> , <span class="string">'software engineer'</span>); <span class="comment">// 不使用new</span></span><br><span class="line">friend.sayName(); <span class="comment">// 'nicholas'</span></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>许多的OO语言都支持两种继承方法：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现主要是<strong>依靠原型链来实现的</strong>。[p162]</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链的基本思想是<strong>利用原型让一个引用类型继承另一个引用类型的属性和方法</strong>。回顾下构造函数、原型和实例的关系: 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了SuperType,重点哦</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中原型链如下：</p><p><img src="http://omu538iq8.bkt.clouddn.com/life/learn/read/javascript/prototype_chain.png" alt="life/learn/read/javascript/prototype_chain"></p><p>原型链继承带来两个问题：一是原型实际上变成了另一个类型的实例，于是，原先的实例属性也就变成了现在原型的属性，共享了属性。二是在创建子类型的实例时，不能在没有影响所有对象实例的情况下向超类型的构造函数传递参数。</p><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>借用构造函数解决原型链继承带来的不能向构造函数传递仓鼠的问题。这里使用到了apply()或者call()方法在新创建的对象上执行构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line">SubType.call(<span class="keyword">this</span>); <span class="comment">// 使用SubType.apply(this)同效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.color.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// 'red,blue,green,black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// 'red,blue,green'</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我在父类型构造函数中没有传参数，看者感兴趣的话可以自己加下参数来实验一番咯。</p><p>借用构造函数解决了原型链继承的确定，但是又没有接纳原型链的优点：共享。下面的组合继承结合了原型链和借用构造函数，容纳了两者的优点。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承的思路是<strong>使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 继承属性</span></span><br><span class="line">SuperType.call(<span class="keyword">this</span>,name);</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor =SubType; <span class="comment">// 避免重写构造函数指向错误</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'nicholas'</span> , <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// 'red,blue,green,black'</span></span><br><span class="line">instance1.sayName(); <span class="comment">// 'nicholas'</span></span><br><span class="line">instance1.sayAge(); <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'greg'</span> , <span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// 'red,blue,green'</span></span><br><span class="line">instance2.sayName(); <span class="comment">// 'greg'</span></span><br><span class="line">instance2.sayAge(); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，<code>成为了JavaScript中最常用的继承模式</code>。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。</p><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>。。。</p><p style="color:red;text-align:center;">精力有限，未能一次性更新完,忘见谅…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/life/learn/read/javascript/javascript_high_level.jpg&quot; alt=&quot;life/learn/read/javascript/javascript_high_level&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近自己在休假，打算闭门几天将《JavaScript高级程序设计》(第3版)这本良心教材再回顾一遍。目前自己进入前端领域两年多，现在重读并记录下这本教材的“硬”知识点 😊 。另外，自己已经提交离职申请，3月底可入职新平台，哪位伯乐推荐下前端岗位过来下哈，感激不尽，个人线上简历请猛戳&lt;a href=&quot;http://reng99.cc/about/&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="读书" scheme="http://reng99.cc/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="javascript" scheme="http://reng99.cc/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>我的2018计划</title>
    <link href="http://reng99.cc/2018/02/21/my-2018-plans/"/>
    <id>http://reng99.cc/2018/02/21/my-2018-plans/</id>
    <published>2018-02-21T15:01:49.000Z</published>
    <updated>2018-02-21T16:28:11.254Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/life/plans/2018/plan_logo.jpg" alt="life/plans/2018/plan_logo.jpg"></p><p>嗖～嗖～嗖～～～🚀现在是农历正月初六的晚上十一点多，第二天就得上班了呢，一年的时间过得真是賊快，来不及感叹2017年自己做了什么，只想着眼现在，立flag啦，鬼知道我会在新的一年会遇到什么人和事情呢。希望一年后回头看不打脸咯…</p><a id="more"></a><h3 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h3><p>看完下面的推荐书籍中的3-5本：</p><ol><li>保罗.约翰逊 《文明的解析》</li><li>乔治.阿克洛夫 《动物精神》</li><li>南希.休斯顿 《断层线》</li><li>安德鲁.罗斯.索尔金 《大而不倒》</li><li>保罗.克利尔 《被掠夺的星球》</li><li>马特.里德利 《理智的乐观者》</li><li>丹.艾瑞里 《非理性的积极力量》</li><li>莱茵哈特.罗格夫 《这次不一样》</li><li>乔纳森.弗兰岑 《自由》</li><li>里查德.克拉克和罗伯特.克纳克 《网络战争》</li><li>巴塞维奇 《华盛顿规则》</li><li>查布里斯.西蒙斯 《看不见的大猩猩》</li><li>托尼.朱特 《乡土式微》</li><li>阿维沙伊.马加利特 《关于妥协和卑微的妥协》</li><li>奇普.希思 《瞬变》</li><li>刘易斯 《大空头》</li><li>查尔斯.默里 《人类成就》</li><li>瓦茨拉夫.斯米尔 《能源神话与现实》</li><li>南丹.尼莱卡尼 《印度畅想》</li><li>克莱.舍基 《未来是湿的》</li></ol><h3 id="深造"><a href="#深造" class="headerlink" title="深造"></a>深造</h3><p>好吧，过年回去已经跟家人达成协议，2018要把考研列入其中，嗯，工作之余努力读书哦，除了程序猿一职，我还有一职—-永远都是学生哈哈哈。对了，英文提高很重要，这也涉及到下面的技能提升。</p><h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>作为一个码农，自己的码农技能总得上升一个阶段吧。将javascript的使用不仅仅局限于前端。自己的工作不仅仅是前端。相关的技能是html/html5,css/css3和javascript为主，java等为辅。</p><h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><p>下面的地点选择1-2进行旅游:</p><ol><li>泰国</li><li>新疆</li><li>云南</li><li>海南</li><li>成都</li><li>杭州</li><li>北京</li><li>潮汕</li></ol><p>就此打住了，这么列下来，感觉自己2018年要累成狗。希望能完成这些模糊又肯定的目标，对了，希望在新的一年里面能够遇到对的那个人 😂</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/life/plans/2018/plan_logo.jpg&quot; alt=&quot;life/plans/2018/plan_logo.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;嗖～嗖～嗖～～～🚀现在是农历正月初六的晚上十一点多，第二天就得上班了呢，一年的时间过得真是賊快，来不及感叹2017年自己做了什么，只想着眼现在，立flag啦，鬼知道我会在新的一年会遇到什么人和事情呢。希望一年后回头看不打脸咯…&lt;/p&gt;
    
    </summary>
    
      <category term="诗和远方" scheme="http://reng99.cc/categories/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
    
      <category term="计划" scheme="http://reng99.cc/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>webpack从零构建vue项目</title>
    <link href="http://reng99.cc/2018/01/16/webpack-build-vue-project/"/>
    <id>http://reng99.cc/2018/01/16/webpack-build-vue-project/</id>
    <published>2018-01-16T03:20:37.000Z</published>
    <updated>2018-03-01T09:29:46.994Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/webpack_build_vue_project/banner.jpg" alt="frontend/webpack_build_vue_project/banner"></p><blockquote><p>看官别急  工作之余更新  预计2018.3.30(乐观的时间，因为自己时间感觉不够用)前完成本博文更新 可文末留言更新建议或打赏</p></blockquote><p>看者可以到自己几个月前搭建的一个小的<a href="https://github.com/reng99/webpack" target="_blank" rel="noopener">webapck项目</a>github仓库下简单看搭建过程啦，如果你在<a href="https://github.com/reng99/webpack" target="_blank" rel="noopener">webpack项目</a>中留颗星星那就更好了。</p><blockquote><p>当然本项目不会像之前的那么简单啦，注意的是本博文webpack的讲解版本是目前最新的版本–v3.10.0（截止2018.01.21），敬请期待…</p></blockquote><a id="more"></a><h2 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h2><p>官方描述：At its core, webpack is a static module bundler for modern JavaScript applications. When webpack processes your application, it recursively builds a dependency graph that includes every module your application needs, then packages all of those modules into one or more bundles.</p><p>鄙人的翻译：webpack的核心是现代javascript程序的静态模块打包工具。当webpack处理你的应用的时候，它会根据你的应用需要的模块递归的描绘出一个依赖图，然后打包这些模块到指定的一个或者多个文件中。</p><p>翻译不妥，还请指出。</p><h2 id="webpack核心概念"><a href="#webpack核心概念" class="headerlink" title="webpack核心概念"></a>webpack核心概念</h2><p>webpack的核心包括： 入口(entry)，出口(output)，加载器(loader)和插件(plugin)。</p><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>入口entry指明webpack应该从哪个文件开始解析去构建它内部的依赖图。入口的语法可以分为下面的这些 ：</p><p><strong>单一的入口</strong></p><p>使用方法： <code>entry: string|Array&lt;string&gt;</code></p><p>相关的demo如下 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">entry: <span class="string">'/path/to/my/entry/file.js'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p><strong>多入口（类型入口）</strong></p><p>使用方法： <code>entry:{[entryChunkName: string]: string|Array&lt;string&gt;}</code></p><p>相关的demo如下 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">entry: &#123;</span><br><span class="line">app: <span class="string">'/path/to/app.js'</span>,</span><br><span class="line">vendors: <span class="string">'/path/to/vendors.js'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出点output是告诉webpack它处理后的文件命名和文件应该存放在哪里。</p><p><strong>用法</strong></p><p>(1) 属性<code>filename</code>是用来告诉webpack输出到的文件</p><p>(2) 属性<code>path</code>是确定文件的绝对路径，一般是用path.resolve(__dirname,’directoryName’)</p><p><strong>单文件出口</strong></p><p>单文件出口就是webpack处理后只输入一个文件，demo如下: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">output: &#123;</span><br><span class="line">filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">path: <span class="string">'/path/to/project/assets'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p><strong>多文件输出</strong></p><p>如果想在多入口文件中输出对应的文件的话，就需要用到webpack带的<code>name</code>属性了，demo如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">entry: &#123;</span><br><span class="line">app: <span class="string">'/path/to/app.js'</span>,</span><br><span class="line">search: <span class="string">'/path/to/search.js'</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">filename: <span class="string">'[name].js'</span>,</span><br><span class="line">path: __dirname + '/dist'# 一般是存放在dist文件夹下啦</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行相关的命令行后，就会在<code>dist</code>文件下面看到<code>app.js和search.js</code>文件了。</p><h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><p>webpack它本身只能够识别javascript文件，那么要webpack来处理除了javascript文件之外的文件，就需要用到<code>loaders</code>了。简单来讲，<code>Loaders</code>能够转换你应用中所有类型的文件到依赖的视图里面。</p><p>在webpack的配置中，<code>Loaders</code>需要注意以下的两点:</p><p>(1) <code>test</code>属性定义哪种类型的文件应该被转换</p><p>(2) <code>use</code>属性指明哪种加载器应该用来转换文件</p><p>如下面的demo的rule字段中匹配后缀名为<code>.txt</code>的文件(假设你已经安装了raw-loader) ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const config = &#123;</span></span><br><span class="line"><span class="string">entry: '</span>/path/to/file.js<span class="string">',</span></span><br><span class="line"><span class="string">output: &#123;</span></span><br><span class="line"><span class="string">path: path.resolve(__dirname,'</span>dist<span class="string">'),</span></span><br><span class="line"><span class="string">filename: '</span>file.name.js<span class="string">'</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">module: &#123;</span></span><br><span class="line"><span class="string">rules: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">test: /\.txt$/,</span></span><br><span class="line"><span class="string">use: '</span>raw-loader<span class="string">'</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p><code>Plugin</code>范围可以从优化和压缩的方法到定义类似环境的变量。英文原话<code>Plugins range from bundle optimization and minification all the way to defining environment-like variables</code>。</p><p>如果你要使用插件，你需要使用<code>require()</code>方法将它添加到<code>plugins</code>的数组中，然后创建相关的实例。下面以<code>html-webpack-plugin</code>插件为例子(前提是你已经安装了这个插件):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">entry: <span class="string">'/path/to/entry/file.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">path: path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">filename: <span class="string">'bundle.js'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">test: <span class="string">'/\.txt$/'</span>,</span><br><span class="line">use: <span class="string">'raw-loader'</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line"><span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">template: <span class="string">'./src/index.html'</span></span><br><span class="line">&#125;)</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><h2 id="webpack项目搭建过程"><a href="#webpack项目搭建过程" class="headerlink" title="webpack项目搭建过程"></a>webpack项目搭建过程</h2><p>简单的讲解了<code>webpack</code>的核心概念，那么接下来就使用<code>webpack</code>来搭建项目吧。下面讲解整个的项目搭建的过程。😊</p><h3 id="项目的初始化"><a href="#项目的初始化" class="headerlink" title="项目的初始化"></a>项目的初始化</h3><p>通过命令行<code>npm init -y</code>的初始化项目，建议在桌面新建文件（因为后面好找啊）还有通过<code>npm init</code>进行项目的初始化（自己可以控制内容）。自己在osx系统上是经过下面的步骤建项目的，如果你使用的电脑是其他系统，有所出入，请留意。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop <span class="comment"># 进入桌面</span></span><br><span class="line">$ mkdir projectName &amp;&amp; <span class="built_in">cd</span> <span class="built_in">cd</span> projectName  <span class="comment"># 新建目录并进入</span></span><br><span class="line">$ npm init <span class="comment"># 开始初始化项目</span></span><br><span class="line">package name: as you like <span class="comment"># 填写包名称，默认projectName</span></span><br><span class="line">version: as you like <span class="comment"># 项目的版本号，默认1.0.0</span></span><br><span class="line">description: as you like  <span class="comment"># 关于项目的描述，默认为空</span></span><br><span class="line">entry point: as you like  <span class="comment"># 项目的入口文件，默认是index.js</span></span><br><span class="line"><span class="built_in">test</span> <span class="built_in">command</span>: as you like  <span class="comment"># 测试命令，默认为空</span></span><br><span class="line">git repository: relatived git repository that you like  <span class="comment"># 相关的git仓库，如果有请关联一个，这样好管理。默认为空</span></span><br><span class="line">keyword: as you like  <span class="comment"># 项目的关键词，默认为空</span></span><br><span class="line">author: your name  <span class="comment"># 项目的作者/发起人，默认为空</span></span><br><span class="line">license: license you write <span class="comment"># 相关的证书，默认是ISC</span></span><br><span class="line"></span><br><span class="line">Is this ok?(yes) <span class="comment"># 询问你设置是否确认，确认的话就按回车键。如果放弃请英文输入法输入n，再按下回车键，就放弃更改，回到最初状态了，再执行 npm init</span></span><br></pre></td></tr></table></figure><p>如果你直接执行<code>npm init -y</code>就会直接使用默认状态啦，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop</span><br><span class="line">$ mkdir projectName &amp;&amp; <span class="built_in">cd</span> projectName</span><br><span class="line">$ npm init -y</span><br><span class="line">Wrote to /Users/reng/Desktop/demo/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"projectName"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"keywords"</span>: [],</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人还是比较偏向<code>npm init</code>啦！</p><blockquote><p>有待补充</p></blockquote><h2 id="全栈项目"><a href="#全栈项目" class="headerlink" title="全栈项目"></a>全栈项目</h2><p>是什么全栈项目呢？说实在，自己还没想好 😂  看情况写或者不写</p><blockquote><p>有待补充</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack官网</a></p><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue官网</a></p><p style="color:red;text-align:center;">精力有限，未能一次性更新完,忘见谅…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/webpack_build_vue_project/banner.jpg&quot; alt=&quot;frontend/webpack_build_vue_project/banner&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;看官别急  工作之余更新  预计2018.3.30(乐观的时间，因为自己时间感觉不够用)前完成本博文更新 可文末留言更新建议或打赏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看者可以到自己几个月前搭建的一个小的&lt;a href=&quot;https://github.com/reng99/webpack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;webapck项目&lt;/a&gt;github仓库下简单看搭建过程啦，如果你在&lt;a href=&quot;https://github.com/reng99/webpack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;webpack项目&lt;/a&gt;中留颗星星那就更好了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然本项目不会像之前的那么简单啦，注意的是本博文webpack的讲解版本是目前最新的版本–v3.10.0（截止2018.01.21），敬请期待…&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="vuejs" scheme="http://reng99.cc/tags/vuejs/"/>
    
      <category term="mvvm" scheme="http://reng99.cc/tags/mvvm/"/>
    
      <category term="webpack" scheme="http://reng99.cc/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vuex 要点</title>
    <link href="http://reng99.cc/2018/01/01/vuex/"/>
    <id>http://reng99.cc/2018/01/01/vuex/</id>
    <published>2018-01-01T11:37:35.000Z</published>
    <updated>2018-01-15T13:50:46.070Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/vuejs/vuex/vuex_banner.jpg" alt="frontend/vuejs/vuex/vuex_banner"></p><p><code>vuex</code>是一个状态管理模式，通过用户的<code>actions</code>触发事件，然后通过<code>mutations</code>去更改数据（你也可以说状态啦 -&gt; state），最后通过<code>getters</code>对状态进行获取，更改页面展示的内容。哈哈 😄 ，详细的内容请接着往下看，如有不妥请文末留言啊。原创文章，转载请注明出处。</p><a id="more"></a><p>注意 ⚠️ 文章中涉及到项目代码是使用<code>Vue</code>官方提供的脚手架<code>vue-cli</code>进行搭建的，如果看者感兴趣，可以自行用<code>vue-cli</code>搭建项目，并进行代码的验证。</p><h2 id="Vuex是什么"><a href="#Vuex是什么" class="headerlink" title="Vuex是什么"></a>Vuex是什么</h2><p>官网介绍:<code>Vuex是一个专门为Vuejs应用程序开发的状态管理模式</code>。（类似react的redux）。<code>Vuex</code>采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex在构建中大型的应用比较适用，小型的应用用组件之间的通信就可以了，小型应用用上<code>Vuex</code>就显得比较臃肿了。</p><h2 id="Vuex的安装"><a href="#Vuex的安装" class="headerlink" title="Vuex的安装"></a>Vuex的安装</h2><p>因为自己是使用<code>npm</code>来辅助开发的，所以我也只说下通过<code>npm</code>安装<code>Vuex</code>的方法。其他的安装方法，请戳<a href="https://vuex.vuejs.org/zh-cn/installation.html" target="_blank" rel="noopener">传送门</a>。</p><p>进入你项目的根目录，然后执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install vuex --save </span><br><span class="line">或</span><br><span class="line">$ npm install vuex --save-dev</span><br></pre></td></tr></table></figure><p>然后在<code>store</code>主入口的<code>javascript文件，一般是store/index.js</code>中通过<code>use</code>进行引用，前提是你已经安装了<code>vue</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import Vuex from <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><p>为了方便在各个组件中使用<code>store</code>，需要在程序的根组件中将其<code>注入</code>到每个子组件。我们需要在实例化<code>Vue</code>的时候将<code>store</code>引入（实例化<code>Vue</code>的文件一般是main.js主入口文件）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import store from <span class="string">'/path/to/store/index.js'</span></span><br><span class="line"></span><br><span class="line">const initApp =new Vue(&#123;</span><br><span class="line">store: store</span><br><span class="line">&#125;).<span class="variable">$mount</span>(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在使用<code>Vuex</code>进行开发的过程中，你可以理解核心的概念只有<code>State</code>、<code>Action</code>和<code>Mutation</code>三个，就像本文章开篇给出的截图流程那样简单明了。但是，我们使用<code>Vuex</code>开发一个应用，肯定是想要方便管理等等。这里自己按照五个核心概念来谈谈，五个核心概念也是<a href="https://vuex.vuejs.org/zh-cn/core-concepts.html" target="_blank" rel="noopener">官网</a>推荐使用的。<code>Vuex</code>的五个核心概念除了上面指出的三个之外，还包括<code>Getter</code>和<code>Module</code>两个。先一句话来概括下它们 :</p><ul><li><p>State : 数据源的存放地</p></li><li><p>Getter : store的计算属性</p></li><li><p>Mutation : 处理数据逻辑，使得数据和视图分离（同步）</p></li><li><p>Action : 类似Mutation（异步），改变状态的话，还得触发Mutation</p></li><li><p>Module : 将store分解成模块</p></li></ul><p>下面来详细讲解各个核心概念咯 😊</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p><code>Vuex</code>是使用单一状态树，一个对象就包含了全部的应用层级状态。这也就表明，一个应用仅仅包含一个<code>store</code>的实例。</p><p>状态<code>State</code>对应于<code>Vue</code>对象中的data，因为两者是对应的关系，所以在这里可以称<code>状态==数据</code>的。如下代码指出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">name: <span class="string">''</span>,</span><br><span class="line"><span class="function"><span class="title">data</span></span>() &#123; // state对应的地方</span><br><span class="line"><span class="built_in">return</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>State</code>里面存放的数据是响应式的，<code>Vue</code>组件从<code>store</code>中读取数据，若是<code>store</code>中的数据发生改变，依赖这个数据的组件也会发生更新。也就是说数据和视图是同步的。</p><p><strong>局部状态</strong></p><p>虽然说<code>Vuex</code>的<code>Store</code>仓库让我们统一管理数据变得更加方便，但是代码一多也会变得冗长和不直观。有些组件的数据是自己严格使用，我们可以将<code>state</code>放在组件自身，作为局部数据，专供此组件使用。比如现在只想在一个组件中使用<code>emotion: happiness</code>，那就不必要在<code>store</code>的<code>state</code>中进行定义了，只在本组件初始化就行了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">emotion: <span class="string">'happiness'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取状态</strong></p><p>在<code>Vue</code>组件中获取<code>store</code>中的数据（状态），最直接的就是通过计算属性获取。因为在上面我将<code>store</code>注册到根组件上了，所以在这里直接通过<code>this.$store</code>就可以调用了。比如我获取状态（state）中的<code>count: 100</code> :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">count: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapState辅助函数</strong></p><p><code>mapState</code>辅助函数把全局的<code>State</code>映射到当前组件<code>computed</code>计算属性中，即是帮助我们生成计算属性。简化我们的代码操作，不需要使用<code>this.$store.state</code>获取了。以上面状态（state）中的<code>count: 100</code>为例子 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span> <span class="comment">// 注意别漏了引入</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">computed: </span><br><span class="line">mapState(&#123;</span><br><span class="line">count: <span class="function"><span class="params">state</span> =&gt;</span> state.count</span><br><span class="line">&#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>上面的<code>state</code>中我们了解到，在<code>store</code>仓库里，<code>state</code>是用来存储数据的。在多个组件中要进行使用同一种状态的话，对数据进行简单操作，我们可以通过在组件的computed中进行获取<code>this.$store.state.theDataName</code>。简单操作没问题，但是，我们进行其他的操作，比如<code>过滤操作</code>，我们就得写一堆的代码 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">filterData: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.$store.state.theDataName.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="comment">// do something ...</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在每个组件中复制这一大堆的代码，或者你单独新建一个文件把代码写进入，每个组件都引入（如果你不觉得很麻烦的话）。</p><p>而<code>Getter</code>可以把组件中共享状态抽取出来，这也是<code>Getter</code>存在的意义。我们可以认为，<code>Getter</code>是<code>Store</code>的计算属性。</p><p><strong>如何使用Getter</strong></p><p>为了方便管理，需要一个单独的<code>getters.js</code>的文件，假如已经有对数据进行过滤的函数了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">filterDatas (state,getter,rootState) &#123;</span><br><span class="line"><span class="comment">// do something ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么只要在相关的组件的<code>computed</code>中引入就可以了，是不是很方便啊 ：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">filterItems: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.filterDatas;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>mapGetters辅助函数</strong></p><p> <code>mapGetters</code>辅助函数仅仅是将<code>store</code>中的<code>getter</code>映射到局部计算属性，看情况使用，类似<code>mapState</code>。下面使用<code>mapGetter</code>改写上面的<code>filterItems</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span> <span class="comment">// 记得引入</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">computed: </span><br><span class="line">mapGetters(&#123;</span><br><span class="line"> filterItems: <span class="string">'filterDatas'</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p><a href="https://vuex.vuejs.org/zh-cn/mutations.html" target="_blank" rel="noopener">Vuex的中文官网</a>中明确指出<code>更改Vuex的store中的状态（state）的唯一的方法是提交mutation</code>。</p><p><code>Mutation</code>可以理解为：在<code>Mutation</code>里面装着一些改变数据方法的集合。即把处理数据逻辑方法全部放在<code>Mutation</code>里面，使得数据和视图分离。</p><p><strong>使用Mutation</strong></p><p><code>Mutation</code>的结构：每个mutation都有一个字符串的<code>事件类型(type)</code>和一个<code>回调函数(handler)</code>也可以理解为<code>{type:handler()}</code>，这和订阅发布有点类似。先是注册事件，当触发响应类型的时候调用<code>handle()</code>，调用<code>type</code>的时候需要用到<code>store.commit(&#39;typeName&#39;)</code>方法。比如我想在要触发<code>mutations.js</code>中的<code>INCREASE</code>处理函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutations.js</span></span><br><span class="line"><span class="keyword">const</span> INCREASE = <span class="string">'INCREASE'</span>; <span class="comment">// 不能漏</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">[INCREASE](state,data)&#123;</span><br><span class="line"><span class="comment">// change the state ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我注册了<code>store</code>到根组件，那么在<code>.vue</code>组件中就可以通过<code>this.$store.commit(&#39;INCREASE&#39;)</code>触发这个改变相关状态的处理函数了。如果在<code>actions.js</code>中调用，直接使用提供的<code>commit</code>参数进行<code>commit(&#39;INCREASE&#39;)</code>触发处理函数。</p><p><strong>提交载荷（Payload）</strong></p><p>可以向<code>store.commit</code>传入额外的参数，参数一般为<code>object</code>类型。我这里接着上面的示例，组件触发的时候传入一个<code>100</code>的数字到<code>data</code>里面 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">increase: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'INCREASE'</span>,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用mutation-types.js</strong></p><p>使用<code>mutation-types.js</code>(名称可根据爱好随便取)是为了方便管理项目<code>mutation</code>的类型。<a href="https://www.zhihu.com/question/58164683/answer/285394955" target="_blank" rel="noopener">我在知乎上也回答过为什么要使用mutation-types.js</a>，当然你完全没必要使用它，不过我自己喜欢使用它。将<code>使用mutation</code>内容中的<code>mutations.js</code>代码拆分为两部分，一部分是<code>mutation-types.js</code>，另一部分是<code>mutations.js</code>，示范如下 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREASE = <span class="string">'INCREASE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutations.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREASE&#125; <span class="keyword">from</span> <span class="string">'/path/to/mutation-type.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">[INCREASE](state,data)&#123;</span><br><span class="line"><span class="comment">// change the state ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapMutations辅助函数</strong></p><p>为了简化你的代码量，使得代码看起来逼格更高点，你可以使用<code>mapMutations</code>辅助函数将组件中的<code>methods</code>映射为<code>store.commit</code>调用(需要在根节点注入store哦)。demo来映射上面的<code>increase</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapMutations&#125; <span class="keyword">from</span> <span class="string">'vuex'</span> <span class="comment">// 不能漏哦</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">...mapMutations([</span><br><span class="line"><span class="string">'INCREASE'</span></span><br><span class="line">])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action 类似于 Mutation，不同点是 ：</p><ul><li><p>Action提交的是 mutation，而不是直接变更状态</p></li><li><p>Action是异步的，而Mutation是同步的</p></li></ul><p>详细的相似点可以回滚看<code>Mutation</code>的啦，或者直接戳<a href="https://vuex.vuejs.org/zh-cn/actions.html" target="_blank" rel="noopener">vue官网Store</a></p><p><strong>组件内分发Action</strong></p><p>因为我在全局组件中挂载了<code>store</code>，所以引用就可以这样写 -&gt; <code>this.$store.dispatch(&#39;dispatchEvent&#39;)</code>，当然你可以传参过去啦。比如：<code>this.$store.dispatch(&#39;dispatchEvent&#39;,param)</code>，param一般是obj类型的。</p><p><strong>mapActions辅助</strong></p><p>为了简化操作，Action像Mutaion一样有一个映射的函数<code>mapActions</code>。使用方法也类似Mutation，demo如下 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapActions&#125; <span class="keyword">from</span> <span class="string">'vuex'</span> <span class="comment">// 不能漏哦</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">...mapActions([</span><br><span class="line"><span class="string">'INCREASE'</span></span><br><span class="line">])</span><br><span class="line">或</span><br><span class="line">...mapActions([</span><br><span class="line">increase: <span class="string">'INCREASE'</span></span><br><span class="line">])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>由于vue中使用单一的状态树，当管理的项目中大型的时候，所有的状态都集中在一个对象中会变得比较复杂，难以管理，显得项目比较臃肿。为了解决这些问题，我们可以使用<code>vuex提供的Module功能</code>，将store分割成模块。每个模块都有自己的state、mutation、action、getter。现在假设你的应用的功能包括<code>登录和音乐</code>两个功能模块页面，那么store的结构可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- module</span><br><span class="line">- music</span><br><span class="line">actions.js</span><br><span class="line">getters.js</span><br><span class="line">index.js// music module 的入口文件</span><br><span class="line">mutations.js</span><br><span class="line">state.js</span><br><span class="line">- user</span><br><span class="line">actions.js</span><br><span class="line">getters.js</span><br><span class="line">index.js// user module的入口文件</span><br><span class="line">mutations.js</span><br><span class="line">state.js</span><br><span class="line">actions.js</span><br><span class="line">index.js// store 的入口文件</span><br><span class="line">mutation-types.js// 管理所有的mutations</span><br><span class="line">mutations.js</span><br><span class="line">state.js</span><br></pre></td></tr></table></figure><p><strong>模块的局部状态</strong></p><p>对于模块内部的mutation，接收的第一个参数是<code>state</code>，也就是接收本模块的局部状态，比如上面的music模块，我在其state.js中写上 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">music: &#123;</span><br><span class="line">list: [],</span><br><span class="line">total: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在同级的<code>mutations.js</code>中有 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../../mutation-types'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">[types.UPDATE_MUSIC](state,data)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(state.music.total);<span class="comment">// 打印出100</span></span><br><span class="line">...other handle</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命名空间</strong></p><p>默认情况下，模块<code>内部</code>的action、mutation 和 getter是注册在全局命名空间的 -&gt; 这样使得多个模块能够对mutation和action作出响应。</p><p>如果看者希望你写的模块具有更高的封装度和复用性，你可以通过添加<code>namespaced:true</code>的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。比如上面的music模块 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">'./state'</span>     <span class="comment">//state</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">'./getters'</span> <span class="comment">//getters</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span>    <span class="comment">//actions</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span>     <span class="comment">//mutations</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//modules</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">namespaced: <span class="literal">true</span>, <span class="comment">// 添加命名空间</span></span><br><span class="line">state,</span><br><span class="line">getters,</span><br><span class="line">actions,</span><br><span class="line">mutations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的情况请戳<a href="https://vuex.vuejs.org/zh-cn/modules.html" target="_blank" rel="noopener">vuex官网modules</a></p><h2 id="store结构"><a href="#store结构" class="headerlink" title="store结构"></a>store结构</h2><p><a href="https://vuex.vuejs.org/zh-cn/structure.html" target="_blank" rel="noopener">vuex的官网谈项目结构</a>，我这里谈<code>store结构</code>，因为我觉得每个人的项目的结构布局有所不同，但是<code>vuex</code>可以是一个模版化的使用。当然，这模版化的使用遵循了官网所定的规则：</p><ul><li><p>应用层级的状态应该集中在单个 store对象中</p></li><li><p>提交mutation是更改状态（state）的唯一方法，并且这个过程是同步的</p></li><li><p>异步逻辑都应该封装到action里面</p></li></ul><p>整理的store结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── ...</span><br><span class="line">│</span><br><span class="line">└── store</span><br><span class="line">├── actions.js// 根级别的 action</span><br><span class="line">├── index.js// 我们组装模块并导出 store 的地方</span><br><span class="line">├── mutation-types.js// store所有mutations管理</span><br><span class="line">├── mutations.js// 根级别的 mutation</span><br><span class="line">├── state.js// 根级别的 state</span><br><span class="line">└── modules</span><br><span class="line">├── moduleA</span><br><span class="line">├── moduleB</span><br><span class="line">└── moduleC</span><br><span class="line">├── actions.js  // moduleC 的 action</span><br><span class="line">├── getters.js// moduleC 的 getter</span><br><span class="line">├── index.js// moduleC 的 入口</span><br><span class="line">├── mutations.js// moduleC 的 mutation</span><br><span class="line">└── state.js// moduleC 的 state</span><br></pre></td></tr></table></figure><p>上面的结构比较通用，模版化，我在接下来的<code>完整小项目</code>中就是使用上面的<code>store结构</code>来管理啦 😝</p><h2 id="完整小项目"><a href="#完整小项目" class="headerlink" title="完整小项目"></a>完整小项目</h2><p>自己在上面讲了一大推的<del>废话</del>，嗯哈，为了证明那不是<del>废话</del>，下面就结合上面讲的知识点来一个综合的<code>min-demo</code>吧，欢迎指正啊！ @~@</p><h3 id="是什么项目呢"><a href="#是什么项目呢" class="headerlink" title="是什么项目呢"></a>是什么项目呢</h3><p>思来想去，自己还是觉得做一个简单版本的<code>todo</code>项目好点，理由如下：</p><ul><li><p>个人时间精力邮箱(main reason)</p></li><li><p>todo项目 -&gt; 麻雀虽小，五脏俱全</p></li></ul><p>项目包含一个简单的登录页面，然后跳转到<code>todo小项目</code>的页面。如图所示：</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/vuejs/vuex/min-demo-login.png" alt="frontend/vuejs/vuex/min-demo-login"></p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/vuejs/vuex/min-demo-todo.png" alt="frontend/vuejs/vuex/min-demo-todo"></p><p>在登录页面，会要求你填写非空的内容进入，我这里填了自己的名字啦。在<code>todo页面</code>，你就需要在输入框输入你要做的事情啦，事情的添加默认是未做的状态。当然，允许进行时间的状态进行设置和事件的删除啦。成品可查看下面最终的效果<code>gif动效</code>，就酱 @～@</p><h3 id="项目的初始化"><a href="#项目的初始化" class="headerlink" title="项目的初始化"></a>项目的初始化</h3><p>⚠️ 本项目在mac系统上使用<code>vue-cli</code>的基础上搭建<code>(搭建日期2018.01.14)</code>的小项目，其完整的覆盖了vue的全家桶了 -&gt; 使用的vue版本是<code>^2.5.2</code>，vuex的版本是<code>^3.0.1</code>，vue-router的版本也是<code>^3.0.1</code>。如果你使用低版本，请参考低版本的相关说明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装 vue-cli</span></span><br><span class="line">$ npm install --global vue-cli</span><br><span class="line"><span class="comment"># 进入桌面</span></span><br><span class="line">$ <span class="built_in">cd</span> desktop</span><br><span class="line"><span class="comment"># 初始化项目min-demo</span></span><br><span class="line">$ vue init webpack min-demo</span><br><span class="line"></span><br><span class="line">? Project name min-demo<span class="comment"># 项目名称</span></span><br><span class="line">? Project description A Vue.js project<span class="comment"># 项目描述</span></span><br><span class="line">? Author reng99  <span class="comment"># 项目作者</span></span><br><span class="line">? Vue build standalone</span><br><span class="line">? Install vue-router? Yes<span class="comment"># 是否使用路由</span></span><br><span class="line">? Use ESLint to lint your code? No<span class="comment"># 是否启动语法检查</span></span><br><span class="line">? Set up unit tests No<span class="comment"># 是否配置单元测试</span></span><br><span class="line">? Setup e2e tests with Nightwatch? No<span class="comment"># 是否配置集成测试</span></span><br><span class="line">? Should we run `npm install` <span class="keyword">for</span> you after the project has been created? (recom</span><br><span class="line">mended) npm<span class="comment"># 选择那种包管理工具进行安装依赖，共三种选择：npm,yarn,no thanks 我选择了npm</span></span><br><span class="line"></span><br><span class="line">   vue-cli · Generated <span class="string">"min-demo"</span>.</span><br><span class="line"><span class="comment"># 等待安装依赖的完成</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 进入项目</span></span><br><span class="line">$ <span class="built_in">cd</span> min-demo</span><br><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line">$ npm run dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果一切正常，就会在浏览器的http://localhost:8080的地址页面有相关的vue界面展示出来</span></span><br></pre></td></tr></table></figure><p>当然，使用脚手架搭建的项目，没有自动集成<code>vuex</code>，这就需要你进入项目的根目录，执行<code>npm install vuex --save</code>命令来安装啦。</p><h3 id="项目的实现"><a href="#项目的实现" class="headerlink" title="项目的实现"></a>项目的实现</h3><p>嗯嗯，下面我将改写在<code>vue-cli</code>搭建的项目，以符合我自己期望。改写的代码就不全给出来了啊，关键的项目代码还是会贴一下的。😝</p><p>这个项目的结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build/<span class="comment">#webpack 的配置项</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── config/</span><br><span class="line">│   ├── index.js<span class="comment"># 项目的主要配置</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── node_modules/<span class="comment"># 相关依赖</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.js<span class="comment"># 应用的主入口</span></span><br><span class="line">│   ├── App.vue     <span class="comment"># 引用的根组件</span></span><br><span class="line">│   ├── components/ </span><br><span class="line">│   │   ├── Login.vue<span class="comment"># 登录组件</span></span><br><span class="line">│   │   └── Todo.vue<span class="comment"># todo组件</span></span><br><span class="line">│   ├── store/ </span><br><span class="line">│   │   ├── modules/<span class="comment"># todo组件</span></span><br><span class="line">│   │   │  └── todo</span><br><span class="line">│   │   │      ├── actions.js<span class="comment"># todo的actions</span></span><br><span class="line">│   │   │      ├── getters.js<span class="comment"># todo的getters</span></span><br><span class="line">│   │   │      ├── index.js<span class="comment"># todo的入口</span></span><br><span class="line">│   │   │      ├── mutations.js<span class="comment"># todo的mutations</span></span><br><span class="line">│   │   │      └── state.js<span class="comment"># todo的状态</span></span><br><span class="line">│   │   ├── actions.js<span class="comment"># 根actions</span></span><br><span class="line">│   │   ├── index.js<span class="comment"># store入口文件</span></span><br><span class="line">│   │   ├── mutation-types.js<span class="comment"># 整个store中的mutation的管理</span></span><br><span class="line">│   │   ├── mutations.js<span class="comment"># 根mutations</span></span><br><span class="line">│   │   └── state.js<span class="comment"># 根的状态</span></span><br><span class="line">│   ├── router/ </span><br><span class="line">│   │   └── index.js<span class="comment"># 路由文件</span></span><br><span class="line">│   └── assets/<span class="comment">#  模块的资源</span></span><br><span class="line">│       └── ...</span><br><span class="line">├── static/  <span class="comment"># 静态资源存放的地方</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── .babelrc                    <span class="comment"># 语法转换babel的相关配置</span></span><br><span class="line">├── .editorconfig<span class="comment"># 编辑器IDE的相关配置</span></span><br><span class="line">├── .gitignore                  <span class="comment"># 提交到github忽略的内容配置</span></span><br><span class="line">├── .postcssrc.js               <span class="comment"># css的处理配置postcssrc</span></span><br><span class="line">├── index.html                  <span class="comment"># index html模版</span></span><br><span class="line">├── package.json                <span class="comment"># 相关的执行命令和依赖配置</span></span><br><span class="line">└── README.md                   <span class="comment"># 项目的说明文件</span></span><br></pre></td></tr></table></figure><p>⚠️ 项目重点在<code>src</code>文件夹内</p><p>在<code>/src/components/Login.vue</code>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"login"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">'login'</span>&gt;</span><br><span class="line">      &lt;div class=<span class="string">'login-title'</span>&gt;简单模拟登录&lt;/div&gt;</span><br><span class="line">      &lt;div class=<span class="string">'login-body'</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">'hint'</span> v-show=<span class="string">'hintFlag'</span>&gt;输入的文字不能为空&lt;/div&gt;</span><br><span class="line">        &lt;input placeholder=<span class="string">'请输入任意文字...'</span> <span class="built_in">type</span>=<span class="string">'text'</span> v-model=<span class="string">'loginTxt'</span>/&gt;</span><br><span class="line">        &lt;div class=<span class="string">"btn"</span> @click=<span class="string">'login'</span>&gt;登录&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Login'</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      hintFlag: <span class="literal">false</span>,</span><br><span class="line">      loginTxt: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">login</span></span> () &#123;</span><br><span class="line">      var vm = this;</span><br><span class="line">      <span class="keyword">if</span>(vm.loginTxt.trim()==<span class="string">''</span>)&#123;</span><br><span class="line">        vm.hintFlag = <span class="literal">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        // 进入todo的页面</span><br><span class="line">        vm.hintFlag = <span class="literal">false</span>;</span><br><span class="line">        // 触发获取登录名</span><br><span class="line">        vm.<span class="variable">$store</span>.dispatch(<span class="string">'createUsername'</span>,vm.loginTxt);</span><br><span class="line">        vm.<span class="variable">$router</span>.push(<span class="string">'/todo'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch:&#123;</span><br><span class="line">    loginTxt(curVal)&#123;</span><br><span class="line">      var vm = this;</span><br><span class="line">      <span class="keyword">if</span>(curVal.trim()==<span class="string">''</span>)&#123;</span><br><span class="line">        vm.hintFlag = <span class="literal">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        vm.hintFlag = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=<span class="string">'less'</span>&gt;</span><br><span class="line">  <span class="comment">#login&#123;</span></span><br><span class="line">    margin-top: 100px;</span><br><span class="line">    .login&#123;</span><br><span class="line">      width: 400px;</span><br><span class="line">      margin: 0 auto;</span><br><span class="line">      &amp;-title&#123;</span><br><span class="line">        color: <span class="comment">#999;</span></span><br><span class="line">        font-size: 22px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        margin-bottom: 20px;</span><br><span class="line">      &#125;</span><br><span class="line">      &amp;-body&#123;</span><br><span class="line">        width: 360px;</span><br><span class="line">        padding: 40px 20px 60px 20px;</span><br><span class="line">        background: <span class="comment">#ededed;</span></span><br><span class="line">        input&#123;</span><br><span class="line">          width: 100%;</span><br><span class="line">          display: block;</span><br><span class="line">          height: 40px;</span><br><span class="line">          text-indent: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .btn&#123;</span><br><span class="line">          width: 100%;</span><br><span class="line">          text-align: center;</span><br><span class="line">          height: 40px;</span><br><span class="line">          line-height: 40px;</span><br><span class="line">          background: <span class="comment">#09c7d1;</span></span><br><span class="line">          color: <span class="comment">#fff;</span></span><br><span class="line">          margin-top: 20px;</span><br><span class="line">          cursor: pointer;</span><br><span class="line">        &#125;</span><br><span class="line">        .hint&#123;</span><br><span class="line">          color: red;</span><br><span class="line">          font-size: 12px;</span><br><span class="line">          text-align: center;</span><br><span class="line">          padding-bottom: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在上面的组件中，自己原封不动的将里面的代码复制过来了，你应该可以看出，这个<code>.vue</code>文件中结合了三块的东西，分别是<code>html</code>的模版、<code>javascript</code>代码和运用less预处理器编写的<code>css</code>代码。</p><p>在<code>/src/components/Todo.vue</code>组件的结构依旧是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"todo"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">'username'</span>&gt;欢迎您！&lt;span&gt;&#123;&#123;username&#125;&#125;&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;</span><br><span class="line">      &lt;div class=<span class="string">"input"</span>&gt;</span><br><span class="line">        &lt;input placeholder=<span class="string">'请输入要做的事情...'</span> <span class="built_in">type</span>=<span class="string">'text'</span> v-model=<span class="string">'eventTxt'</span>/&gt;</span><br><span class="line">        &lt;button @click=<span class="string">"addEvent"</span>&gt;增加&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'ToDo'</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      noDataFlag: <span class="literal">true</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span></span>()&#123;</span><br><span class="line">    var vm = this;</span><br><span class="line">    <span class="keyword">if</span>(vm.username == <span class="string">''</span>)&#123;</span><br><span class="line">      vm.<span class="variable">$router</span>.push(<span class="string">'/'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">username</span></span>()&#123;</span><br><span class="line">      <span class="built_in">return</span> this.<span class="variable">$store</span>.getters.username;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    delEvent (id) &#123;</span><br><span class="line">      this.<span class="variable">$store</span>.dispatch(<span class="string">'delEvent'</span>,id);</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  watch:&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=<span class="string">'less'</span>&gt;</span><br><span class="line">  <span class="comment">#todo&#123;</span></span><br><span class="line">    margin-top: 100px;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在路由的文件中，因为知识涉及了两个页面的路由跳转，这里也全贴出来吧 –</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'@/components/Login'</span></span><br><span class="line"><span class="keyword">import</span> ToDo <span class="keyword">from</span> <span class="string">'@/components/ToDo'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'Login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/todo'</span>,</span><br><span class="line">      name: <span class="string">'ToDo'</span>,</span><br><span class="line">      component: ToDo</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>关于<code>store</code>，这是一个重点，我打算详细说啦。首先当然得从整个<code>store</code>的入口文件讲起啦。在<code>store/index.js</code>中，我是这样引用的 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span><span class="comment">// 引入vue依赖</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'Vuex'</span><span class="comment">// 引入vuex依赖</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">'./state'</span><span class="comment">// 引入根状态</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span><span class="comment">// 引入根actions</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span><span class="comment">// 引入根mutations</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> todo <span class="keyword">from</span> <span class="string">'./modules/todo/index'</span><span class="comment">// 引入todo模块</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)<span class="comment">// 引入vuex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  modules:&#123;</span><br><span class="line">    todo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在根的<code>store</code>的<code>mutation-types.js</code>文件中，管理着整个项目的状态管理函数 –&gt; 包括创建用户名、添加要做的事情、删除创建的事情、显示事件的状态(全部，已经做，没有做)和标记事件(已经做的事件标记为未做，未做的事件标记为已经做)。代码展示如下 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CREATE_USERNAME = <span class="string">'CREATE_USERNAME'</span>  <span class="comment">// 创建用户名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_EVENT = <span class="string">'ADD_EVENT'</span>  <span class="comment">// 添加事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DEL_EVENT = <span class="string">'DEL_EVENT'</span>  <span class="comment">// 删除事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ALL_EVENT = <span class="string">'ALL_EVENT'</span>  <span class="comment">// 全部事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UNDO_EVENT = <span class="string">'UNDO_EVENT'</span>  <span class="comment">// 没做事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DONE_EVENT = <span class="string">'DONE_EVENT'</span>  <span class="comment">// 已做事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MARK_UNDONE = <span class="string">'MARK_UNDONE'</span> <span class="comment">// 标记为未做</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MARK_DONE = <span class="string">'MARK_DONE'</span> <span class="comment">// 标记为已做</span></span><br></pre></td></tr></table></figure><p><code>store/state.js</code>的作用在你听完<code>store/todo/state.js</code>的讲解后你应该会明白。在模块<code>todo</code>的state中，自己定义了此模块的相关的数据结构，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 事件列表</span></span><br><span class="line">  list:[</span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//   id: 0,  相关的id</span></span><br><span class="line">    <span class="comment">//   content:'',  // 事件的内容</span></span><br><span class="line">    <span class="comment">//   flag: 1 // 是否完成,1是完成，0是未完成</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  ],</span><br><span class="line">  allList:[],</span><br><span class="line">  increase: <span class="number">0</span>,</span><br><span class="line">  total: <span class="number">0</span>,</span><br><span class="line">  done: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的这些数据结构，你可以说是状态吧，是为了给<code>mutation和getters</code>进行操作。对了，你也许注意到了<code>store</code>根目录中没有<code>getters.js</code>文件。因为，这是分散模块管理项目，为什么还需要呢，如果你想保留，你可以自己新建一个，按照自己的习惯进行管理项目呗。</p><p>上个段落以及前面某部分内容已经谈及了<code>mutations</code>的作用，本项目中使用mutation就是为了改变自己在<code>todo/state.js</code>定义的状态，比如改变<code>allList:[]</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../../mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  [types.ADD_EVENT] (state,data)&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">      id: state.increase++,</span><br><span class="line">      content: data,</span><br><span class="line">      flag: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    state.allList.push(obj);</span><br><span class="line">    state.list = state.allList;</span><br><span class="line">    state.total = state.allList.length;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>todo/getter.js</code>就是为了将<code>vuex</code>中的状态获取，方便显示在页面的啦，在本项目中，自己超级简单的使用了下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  list (state,getters,rootState) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.list;</span><br><span class="line">  &#125;,</span><br><span class="line">  username (state,getters,rootState) &#123;</span><br><span class="line">    <span class="keyword">return</span> rootState.username;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个是关于<code>todo/actions.js</code>，这是页面中的用户的事件去发送事件，使得产生<code>mutations</code>去改变状态(state.js)，最终使得页面展示的内容(getters)发生改变。这里以一个派遣添加事件为例子 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../../mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addEvent = <span class="function">(<span class="params">&#123;commit,state,rootState&#125;,query</span>) =&gt;</span> &#123;</span><br><span class="line">  commit(types.ADD_EVENT,query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，整篇文章都说整个store是挂载在根组件上的，那么是在哪里呢？答案就是<code>src/main.js</code>文件啦，文件内的代码如下 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="最终的效果"><a href="#最终的效果" class="headerlink" title="最终的效果"></a>最终的效果</h3><p>好吧，自己利用了一个下午搭建项目并简单思考了相关的逻辑，简单实现项目，其最终的效果如下<code>gif动图</code>啦 :</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/vuejs/vuex/min-demo.gif" alt="frontend/vuejs/vuex/min-demo"></p><p>嗯，项目是不是很简单，所以就不放源码上去了 😂 。其实自己觉得源码实现不够严谨啦，毕竟只是花了短短一个下午和晚上从设计到实现… 逃：）</p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://vuex.vuejs.org/" target="_blank" rel="noopener">vuex官网</a></p><p style="color:red;text-align:center;">（ 完 @~@ ）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/vuejs/vuex/vuex_banner.jpg&quot; alt=&quot;frontend/vuejs/vuex/vuex_banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vuex&lt;/code&gt;是一个状态管理模式，通过用户的&lt;code&gt;actions&lt;/code&gt;触发事件，然后通过&lt;code&gt;mutations&lt;/code&gt;去更改数据（你也可以说状态啦 -&amp;gt; state），最后通过&lt;code&gt;getters&lt;/code&gt;对状态进行获取，更改页面展示的内容。哈哈 😄 ，详细的内容请接着往下看，如有不妥请文末留言啊。原创文章，转载请注明出处。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="vuejs" scheme="http://reng99.cc/tags/vuejs/"/>
    
      <category term="mvvm" scheme="http://reng99.cc/tags/mvvm/"/>
    
  </entry>
  
  <entry>
    <title>第二届前端体验大会 -- 本固枝荣</title>
    <link href="http://reng99.cc/2017/12/24/2ndTencent-frontend-meeting/"/>
    <id>http://reng99.cc/2017/12/24/2ndTencent-frontend-meeting/</id>
    <published>2017-12-24T03:31:10.000Z</published>
    <updated>2017-12-31T11:42:03.746Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/banner.jpg" alt="meeting/tencent_20171223/banner"></p><p>第二届前端体验大会，是至今为止，我参加的最棒的一次前端体验大会，不枉我从广州过去深圳啊。<del>目前只参加过一次大型的前端体验大会</del> 😝。在一天的时间里面，自己收获到了很多的东西。作为一个非典型的程序员，杂七杂八的就不谈了，还是谈技术来得简单粗暴一点。</p><a id="more"></a><h2 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h2><p>本会议的主题是<code>本固枝荣</code>，开场白的彪叔已经很好的解释了主题：基础牢固，才能更好的玩转前端（概括起来就这样吧）。在开场白的时候，彪叔介绍的前端的前三年的调查报告，着实让我一惊 -&gt; 原来前端的市场是酱紫啊，作为一个涉水不深的前端菜鸡来说，还是可以定m个小目标的。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/biaoshu_skills.jpg" alt="meeting/tencent_20171223/biaoshu_skills"></p><h2 id="一个UI的自我修养"><a href="#一个UI的自我修养" class="headerlink" title="一个UI的自我修养"></a>一个UI的自我修养</h2><p>腾讯的QQ音乐的设计天团研发经理主要是针对<code>一个UI开发的自我修养</code>来讲述了前端开发人员需要有发现问题，定位问题，解决问题的能力（概括不到位的话，大佬不要怂我 😂 ）。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaojian_skills.jpg" alt="meeting/tencent_20171223/xiaojian_skills"></p><h2 id="感知性能优化"><a href="#感知性能优化" class="headerlink" title="感知性能优化"></a>感知性能优化</h2><p>在众多嘉宾分享的话题中，我最喜欢的就是潇滨前辈讲解的<code>感知性能优化</code>的话题。在前端开发中，我们需要对自己做出来的产品进行优化，怎么进行优化呢，前辈经过三个层次进行说明：<code>资源感知</code>，<code>代码感知</code>和<code>用户感知</code>。这里也推荐雅虎的七个领域的35条优化原则，请戳<a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">传送门</a><br><strong>资源感知</strong>我们写的页面的<code>img,js,html,css</code>等都可以成为资源，我们在优化的时候，需要考虑到控制请求，控制资源的大小，控制缓存等。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaobin_skills_resource.jpg" alt="meeting/tencent_20171223/xiaobin_skills_resource"></p><p><strong>感知代码</strong>在代码的层面，我们可以通过对请求加载数进行延迟或者按需加载来控制代码。一个产品的首页首次渲染很是重要，在代码层面对样式的前置，js后置等进行优化。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaobin_skills_code01.jpg" alt="meeting/tencent_20171223/xiaobin_skills_code01"></p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaobin_skills_code02.jpg" alt="meeting/tencent_20171223/xiaobin_skills_code02"></p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaobin_skills_code03.jpg" alt="meeting/tencent_20171223/xiaobin_skills_code03"></p><p><strong>用户感知</strong>用户在产品中起到至关重要的作用，也许你的产品在电脑的模拟器上没有什么问题。但是是真的没有问题吗？这就需要站到用户的角度进行思考，如果用户的使用的网络是3g的怎么样等等。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaobin_skills_user.jpg" alt="meeting/tencent_20171223/xiaobin_skills_user"></p><p>整个感知优化的流程，可以用大佬ppt里面的图片进行总结，如下:</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaobin_skills_process.jpg" alt="meeting/tencent_20171223/xiaobin_skills_process"></p><h2 id="那些年我们所遗忘的XSS黑魔法"><a href="#那些年我们所遗忘的XSS黑魔法" class="headerlink" title="那些年我们所遗忘的XSS黑魔法"></a>那些年我们所遗忘的XSS黑魔法</h2><p>至于前端方面的安全，<code>志龙</code>前辈演示了xss的黑魔法，自己一脸懵逼，因为接触前端安全这一块一直是个梗。在xss黑魔法中，哪里有用户输入，哪里就可能有前端的安全漏洞，当然，前辈不仅演示了如何攻击，还演示了如何防攻啦。自己很想加入他们的团队，貌似能力不足啊…</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/zhilon_part.jpg" alt="meeting/tencent_20171223/zhilon_part"></p><h2 id="前端监控系统"><a href="#前端监控系统" class="headerlink" title="前端监控系统"></a>前端监控系统</h2><p>监控系统是<code>幸福生活的保障</code>。一个产品的异常都需要进行监控，这些就是问题的来源。监控系统对异常进行监控，进行错误信息自动上报，性能数据自动上报，进行数据的打点，最终显示出系列告警的错误日志数据。<code>郑超</code>前辈指出<code>人</code>是监控系统的关键组成部分。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/zhengchao_part01.jpg" alt="meeting/tencent_20171223/zhengchao_part01"></p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/zhengchao_part02.jpg" alt="meeting/tencent_20171223/zhengchao_part02"></p><h2 id="跨界-成长：非典型程序员之路"><a href="#跨界-成长：非典型程序员之路" class="headerlink" title="跨界-成长：非典型程序员之路"></a>跨界-成长：非典型程序员之路</h2><p><code>某磊</code>前辈作为全场嘉宾中唯一一个文科生<del>（自己猜的）</del>出身的程序猿。在会场上分享了自己如何在<code>钱途</code>[逃：)]和<code>热情</code>的支撑下成为前端大神的经历。很喜欢他会场的一句话：<code>你生命中的每个点（经历的事），在你生命的某一个时刻终将连成线</code>。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/luolei_part.jpg" alt="meeting/tencent_20171223/luolei_part"></p><p>作为一个非典型的程序猿，你的世界不应该只有代码和办公室，你应该到处走走。美妙的代码只是你生命中的一部分，生命中其他美妙的部分等待着你去发现、挖掘。嗯，我也是一个非典型的程序猿，打代码仅仅是人生乐趣的一部分。 😊 </p><h2 id="高性能React替代方案"><a href="#高性能React替代方案" class="headerlink" title="高性能React替代方案"></a>高性能React替代方案</h2><p>现在前端比较热门的框架有三个，分别是<code>react</code>、<code>vue</code>和<code>angular</code>。京东的<code>某澈</code>前辈对三种框架进行了比较选择了react。然后基于他们京东的产品和业务，对react进行了改写，支持<code>IE8</code>版本等，他们改写<code>react</code>的<code>github仓库</code>请戳<a href="https://github.com/NervJS/nerv" target="_blank" rel="noopener">传送门</a>。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/yuche_part.jpg" alt="meeting/tencent_20171223/yuche_part"></p><p>每个公司的情况不同，我们的大佬就选择了<code>vue</code>。经过一年的<code>vue</code>的锻炼，自己貌似已经把<code>react</code>知识点忘记了。但愿<code>react</code>别来个变脸 -&gt; 改协议了…</p><h2 id="如何开发知晓榜工具类第一的小程序"><a href="#如何开发知晓榜工具类第一的小程序" class="headerlink" title="如何开发知晓榜工具类第一的小程序"></a>如何开发知晓榜工具类第一的小程序</h2><p>最后一位分享嘉宾是<code>某博</code>前辈讲的微信小程序。因为自己没开发过微信小程序，听不懂他在讲啥（我的锅），全程感觉就是围绕<code>websocket</code>和使用场景规模来讲。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/libo_part.jpg" alt="meeting/tencent_20171223/libo_part"></p><p>如果需要学习微信小程序的时候只能靠后期了，也许找的资源比他讲解的还好(幻想中…)</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>会议的结尾，本会议的负责任<code>某帅</code>讲了自己的进入腾讯的幸酸的经历。嗯，是半开玩笑的那种。然后就是很形式的会议的闭幕的发言啦，感觉可以忽略。如果让自己用一个字还总结这次会议的话，那就是<code>棒</code>；两个字的话，那就是<code>很棒</code>；三个字的话，那就是<code>非常棒</code>。感谢主办方的精彩呈现 👏</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>作为一个非典型的程序猿，好吧，我说下参加本次会议的其他点吧：</p><ul><li><p>嗯，主持人很会带气氛的说，特别是男的主持人(会场一对主持人，男帅女靓)，怂一下主持人 -&gt; 会场总说自己穷，穷的人在这里还没说话呢 😢</p></li><li><p>腾讯的工作环境真是超级棒的，能在这里工作是多么的幸福呢，希望自己有机会进入腾讯工作吧</p></li><li><p>腾讯的饭堂很赞，举办方免费开了会议还提供免费的午餐，真是有心了</p></li><li><p>会议的抽奖礼品很实在哦，大奖是服务器的优惠卷（价值9000）。好吧，我也很幸运，中了幸运奖–貌似是布娃娃吧，会后忘记自己还中奖来着，直接离场忘拿了</p></li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li><p>本文的截图来自嘉宾的演讲稿</p></li><li><p>本文内容仅代表自己参加<code>本固枝荣</code>会议的观点，不喜勿喷</p></li><li><p>文中使用了嘉宾的名字，如果某嘉宾觉得本人使用不妥，可以文末留言，我将打码 😝</p></li></ul><p>一张会议的合影图结束本文（原图太大，放上压缩后的图片，原图可以私信我，我还保留的话就发你了）</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/meeting_persons.png" alt="meeting/tencent_20171223/meeting_persons"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/banner.jpg&quot; alt=&quot;meeting/tencent_20171223/banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;第二届前端体验大会，是至今为止，我参加的最棒的一次前端体验大会，不枉我从广州过去深圳啊。&lt;del&gt;目前只参加过一次大型的前端体验大会&lt;/del&gt; 😝。在一天的时间里面，自己收获到了很多的东西。作为一个非典型的程序员，杂七杂八的就不谈了，还是谈技术来得简单粗暴一点。&lt;/p&gt;
    
    </summary>
    
      <category term="技术交流" scheme="http://reng99.cc/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="会议" scheme="http://reng99.cc/tags/%E4%BC%9A%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>git的学习汇总</title>
    <link href="http://reng99.cc/2017/12/13/git-learning/"/>
    <id>http://reng99.cc/2017/12/13/git-learning/</id>
    <published>2017-12-13T14:12:02.000Z</published>
    <updated>2018-01-02T12:22:00.599Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/tools/git/git-banner.jpg" alt="tools/git/git-banner"></p><p>这篇博文是自己在学习git过程中的思考总结。本文仅仅代表个人的看法，如有不妥地方还请本文文末留言。 😊 </p><a id="more"></a><h2 id="GIT是什么"><a href="#GIT是什么" class="headerlink" title="GIT是什么"></a>GIT是什么</h2><p><code>GIT</code>是一个免费并且开源的分布式版本控制系统，能够高速有效的处理或小或大的项目。(以上的话是自己翻译<a href="https://git-scm.com/" target="_blank" rel="noopener">github官网</a>)</p><p>至今，自己用过了window系统的<code>TortoiseSVN</code>, mac系统的<code>CornerStone</code>,最近的大半年也在用<code>GIT</code>(主要管理自己的<a href="https://github.com/reng99" target="_blank" rel="noopener">github项目</a>)。比较下来，还是GIT优势比较明显<del>，虽然目前为止没有用GIT开发过团队项目</del>。</p><p><strong>GIT跨平台</strong></p><p><code>GIT</code>可以在不同的操作系统中使用。也许你注意到了，我在window上和mac系统上工作的时候是使用两个不同的svn。如果我在linux上工作会不会又是一个呢。</p><p><strong>GIT是分布式版本控制系统,而svn是集中式版本控制系统</strong></p><p><code>集中式版本控制系统</code>是集中放在中央服务器上面的，而团队的人需要从中央服务器上面拉取最新的代码，然后进行开发，最后推送到中央服务器上面，就像串联的电路。而<code>分布式版本控制系统</code>没有中央服务器，团队的每个人的电脑就是一个完整的版本库，就好像并联的电路（自我理解）。</p><p><code>集中式版本控制系统</code>必须联网才能工作，如果是在局域网内还好，带宽足够大，速度足够快，但是遇到网速慢的话，那心里就一万个羊驼🐑在蹦腾了。</p><p><code>集中式版本控制系统</code>安全性比较低，如果中央系统崩溃了，那就有点悲催了。当然你不嫌麻烦，可以定期备份的啦。而<code>分布式中央系统</code>就比较安全，团队的每个成员的电脑就是一个完整的版本库。如果其中一个坏掉了，你可以从团队另外一个的人员电脑那里拷贝一份就行了。对了，<code>GIT</code>也会有一台中央的机子，主要是为了方便团队的交流，它是可以不存在的。</p><h2 id="GIT安装"><a href="#GIT安装" class="headerlink" title="GIT安装"></a>GIT安装</h2><p><code>GIT</code>支持不同的系统，看者可以在链接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a>中，找到和自己电脑系统匹配的<code>GIT</code>版本，下载安装包后根据提示进行安装。当然，<code>GIT</code>还提供图形界面管理工具，看者也可以在链接中下载<code>GUI Clients</code>，如下图所示–<br><img src="http://omu538iq8.bkt.clouddn.com/tools/git/git_install.png" alt="tools/git/git_install"><br>根据提示安装完成后，要验证是否安装成功。看者可打开命令行工具，输入<code>git --version</code>命令,如果安装成功，控制台输出安装的版本号（当然，安装前就应该输入git –version查看是否安装了git），我这里安装的<code>GIT</code>版本是<code>2.10.0</code>。</p><h2 id="GIT配置"><a href="#GIT配置" class="headerlink" title="GIT配置"></a>GIT配置</h2><p><code>GIT</code>在使用前，需要进行相关的配置。每台计算机上面只需要配置一次，程序升级的时候会保留配置信息。当然，看者可以在任何时候再次通过运行命令行来修改它们。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>设置<code>GIT</code>的用户名称和邮件地址，这个很重要，因为每个<code>GIT</code>的提交都会使用这些信息，并且它会写入到每一次的提交中。你可以在自己的仓库中使用<code>git log</code>，控制台上面显示的每次的提交都有<code>Author</code>字段，它的值就是<code>用户名称 &lt;邮件地址&gt;</code>。方便查看某次的提交的负责人是谁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"你的用户名"</span></span><br><span class="line">$ git config --global user.email 你的邮箱地址</span><br></pre></td></tr></table></figure><p>⚠️ <code>GIT</code>一般和<code>github</code>配合使用，看者应该设置用户名称为你的<code>github</code>用户名。当然，还有和<code>gitlab</code>等配合使用…</p><p>⚠️ 如果配置中使用了<code>--global</code>选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，<code>GIT</code>都会使用这些信息。但是，当你想针对特定项目使用不同的用户名称与邮件地址的时候，可以在那个仓库目录下运行不使用<code>global</code>选项的命令来配置。</p><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>通过<code>git config --list</code>命令可以列出所有<code>GIT</code>能找到的配置。如下：（我的git版本为2.10.0）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">user.name=reng99</span><br><span class="line">user.email=1837895991@qq.com</span><br><span class="line">color.ui=<span class="literal">true</span></span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当然，你可以通过<code>git config &lt;key&gt;</code>来检查<code>GIT</code>的某一项配置。比如<code>$ git config user.name</code>。</p><h3 id="帮助中心"><a href="#帮助中心" class="headerlink" title="帮助中心"></a>帮助中心</h3><p>在使用<code>GIT</code>的时候，遇到问题寻求帮助的时候，可以运行<code>git help</code>或<code>git --help</code>或<code>git</code>命令来查看。在控制台上会展示相关的帮助啦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">usage:</span><br><span class="line">...</span><br><span class="line">start a working area (see also: git <span class="built_in">help</span> tutorial)</span><br><span class="line">...</span><br><span class="line">work on the current change (see also: git <span class="built_in">help</span> everyday)</span><br><span class="line">...</span><br><span class="line">examine the <span class="built_in">history</span> and state (see alse: git <span class="built_in">help</span> revisions)</span><br><span class="line">...</span><br><span class="line">grow,mark and tweak your common <span class="built_in">history</span></span><br><span class="line">...</span><br><span class="line">collaborate (see also: git <span class="built_in">help</span> workflows)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>更加详细的内容，请点击<a href="https://git-scm.com/docs/git-help" target="_blank" rel="noopener">传送门</a></p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>版本库又名仓库(repository)，可以理解成一个目录，这个目录里面所有文件都可以被<code>GIT</code>管理起来，每个文件的修改、删除，<code>GIT</code>都能跟踪，以便任何时刻都能可以追踪历史，或者在将来某个时刻可以还原。</p><p>创建一个版本库，首先得选择一个存放目录的地方，我这里选择了桌面，并且创建一个空的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop</span><br><span class="line">$ mkdir -p learngit</span><br><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/Users/reng/desktop/learngit</span><br></pre></td></tr></table></figure><p><code>mkdir -p dirnanme</code>是创建一个子目录，这里的<code>-p</code>确保目录的名称存在，如果目录不存在的就新建一个，如果你确定目录不存在，直接使用<code>mkdir dirname</code>就可以了。<code>pwd(Print Working Directory)</code>是显示当前目录的整个路径名。</p><p>然后，通过命令行<code>git init</code>，将创建的目录变成<code>GIT</code>可以管理的仓库:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init </span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/reng/Desktop/learngit/.git/</span><br></pre></td></tr></table></figure><p>初始化好仓库后就可以愉快的玩耍了，但是，得先来了解下<code>GIT</code>整个工作流程先。</p><h2 id="GIT工作流程"><a href="#GIT工作流程" class="headerlink" title="GIT工作流程"></a>GIT工作流程</h2><p>为了更好的学习，自己用<code>Axure RP 8</code>粗略的画了下流程图，如下–<br><img src="http://omu538iq8.bkt.clouddn.com/tools/git/git_brief_process.png" alt="tools/git/git_brief_process"></p><p>本地仓库(repo)包含工作区和版本库,那么什么是工作区和版本库呢？基本的流程又是什么呢？</p><h3 id="工作区和版本库"><a href="#工作区和版本库" class="headerlink" title="工作区和版本库"></a>工作区和版本库</h3><p>我们新建一个仓库，就像我们新建的<code>learngit</code>仓库，现在在里面添加一个文件<code>README.md</code>，用sublime打开<code>learngit</code>目录。此时会出现如下图的情况(当然你设置了其他东西例外)–<br><img src="http://omu538iq8.bkt.clouddn.com/tools/git/working_version_area.png" alt="tools/git/working_version_area"><br>如上图，出现的内容就是工作区（ 电脑上能看到的此目录下的内容），这里工作区只有<code>README.md</code>一个文件。工作区有一个隐藏的目录<code>.git</code>，这个不算工作区，而是<code>GIT</code>的版本库。版本库又包括暂存区和GIT仓库。暂存区是一个文件，保存了下次将提交的文件列表信息，而GIT仓库目录是<code>GIT</code>用来保存项目的元数据和对象数据库的地方。这是<code>GIT</code>中最重要的部分，从其他计算机克隆仓库的时候，拷贝的就是这里的数据。当执行<code>git add .</code>或者<code>git add path/to/filename</code>的时候，文件从工作区转到暂存区；执行<code>git commit -m&quot;here is the message described the file you add&quot;</code>的时候,文件从缓存区添加到GIT仓库。</p><h3 id="基本的工作流"><a href="#基本的工作流" class="headerlink" title="基本的工作流"></a>基本的工作流</h3><p>基本的<code>GIT</code>工作流可以简单总结如下–</p><ol><li>在工作区目录中修改文件</li><li>暂存区中暂存文件，将文件的快照放入暂存区域</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到GIT仓库目录</li></ol><h2 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h2><p>到目前为止，在自己创建的本地仓库–<code>learngit</code>中已经初具形态了。进入<code>learngit</code>，执行<code>ls</code>，可看到目前仓库中已有的文件README.md。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop/learngit</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br></pre></td></tr></table></figure><p>上面展示了本地<code>learngit</code>内的相关的内容。运行下<code>git status</code>查看现在的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>这时候会提示没有内容可以提交，工作区是干净的。因为我之前已经提交(git commit)过了。上面还提示了目前是位于主分支上面，<code>GIT</code>在初始化(git init)的时候会自动创建一个<code>HEAD</code>指针指向默认<code>master</code>分支，也只有一个分支，看者可以通过<code>git branch</code>查看。</p><p>现在，在<code>README.md</code>上添加一些内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br></pre></td></tr></table></figure><p>此刻再通过<code>git status</code>查看当前状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>这时候显示出一堆的东西，告诉我们现在是位于主分支上面，然后告诉我们修改的文件啊，可以使用的命令进行下一步的操纵。那么我们来进行下一步的操作了，<code>git add . 或者 git add README.md</code>将修改的文件添加到暂存区域。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br></pre></td></tr></table></figure><p>对了，有时候需要在添加的之前（执行git add .  或者 git add path/to/filename）的时候，需要看下修改了哪些内容可以执行下<code>git diff</code>。那么，现在先回退到修改的前一个版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD README.md</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">MREADME.md</span><br><span class="line">$ git checkout -- README.md</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br></pre></td></tr></table></figure><p>回退正确，现在像上次那样添加内容<code>### first change</code>，然后执行命令<code>git diff</code>来查看更改的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 75759ec..0bc52b9 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,3 @@</span><br><span class="line">-<span class="comment">## content</span></span><br><span class="line">\ No newline at end of file</span><br><span class="line">+<span class="comment">## content</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">### first change</span></span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>现在就显示了修改前的内容–<code>-</code>前为修改前的内容，和修改后的内容–<code>+</code>前修改后的内容。查看完之后，觉得没有问题了，就可以进行添加(git add)，提交(git commit)。当然，一般不常用git diff的，因为自己修改的东西自己心里总有点数吧，可能合作中团队的其他人需要查看文件前后的不同点就需要用到<code>git diff</code>啦。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>为了方便讲解下版本回退，我先将上面添加的<code>### first change</code>提交以下–<code>git add . &amp;&amp; git commit -m &quot;add first change&quot;</code>。下面通过<code>git log</code>就可以查看自己提交的记录了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67</span><br><span class="line">Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">Date:   Sun Dec 17 17:11:53 2017 +0800</span><br><span class="line"></span><br><span class="line">    init README.md</span><br><span class="line">    </span><br><span class="line">$ git add . &amp;&amp; git commit -m <span class="string">"add first change"</span></span><br><span class="line">[master 0ac49ba] add first change</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 0ac49bae6ab55df9c05d0770de347665a2568f31</span><br><span class="line">Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">Date:   Mon Dec 18 15:26:06 2017 +0800</span><br><span class="line"></span><br><span class="line">    add first change</span><br><span class="line"></span><br><span class="line">commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67</span><br><span class="line">Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">Date:   Sun Dec 17 17:11:53 2017 +0800</span><br><span class="line"></span><br><span class="line">    init README.md</span><br></pre></td></tr></table></figure><p>在上面中，自己先执行了<code>git log</code>来显示提交的日志，显示只有一条，然后执行了add和commit的命令，打印的内容是现实主分支、commit的id、commit的信息、多少个文件的更改、多少个插入以及多少个删除。之后再次执行<code>git log</code>打印日志，显示了两次提交。⚠️ 注意：当提交(commit)的次数较多之后，控制台会显示不下（最多现实4条）那么多的条数，可以通过按键盘的<code>向上或向下</code>键查看日志的内容，需要退出查看日志命令的话，在<code>英文输入法的状态按下q</code>，意思就是quit(退出)。</p><p>版本的回退就是改变<code>HEAD</code>指针的指向。通过<code>git reset --hard HEAD^</code>返回上一个版本，通过<code>git reset --hard HEAD^^</code>返回上上个版本…由此推论，往上100个版本的话就是100个<code>^</code>，当然，这样你数到明天也未必数得正确，所以写成<code>git reset --hard HEAD~100</code>。另外一种是，你知道提交的id，例如<code>commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67</code>的前7位就是commit的id(5c2639e)，执行<code>git reset --hard 5c2639e</code>就回到此版本啦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ reng$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 5c2639e init README.md</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67</span><br><span class="line">Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">Date:   Sun Dec 17 17:11:53 2017 +0800</span><br><span class="line"></span><br><span class="line">    init README.md</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br></pre></td></tr></table></figure><p>现在你已经回到了最初的版本，这里演示的是通过<code>HEAD</code>，你也可以通过<code>commit id</code>来实现的。执行上面的代码后，<code>README.md</code>文件里面只有一<code>### content</code>文字内容,但是过了段时间后，你想恢复到原先的版本，通过<code>git log</code>命令行，控制台显示的以前的信息，通过它找不到回退前的<code>commit id</code>，怎么办？<code>GIT</code>提供一个<code>git reflog</code>显示提交的历史记录，在那里可以查看提交的id、<code>HEAD</code>的指针历史和操作的信息记录。下面演示回退到最新的版本（也就是commit -m “add first change”）–</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67</span><br><span class="line">Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">Date:   Sun Dec 17 17:11:53 2017 +0800</span><br><span class="line"></span><br><span class="line">    init README.md</span><br><span class="line">$ git reflog</span><br><span class="line">5c2639e HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">0ac49ba HEAD@&#123;1&#125;: commit: add first change</span><br><span class="line">5c2639e HEAD@&#123;2&#125;: commit (initial): init README.md</span><br><span class="line">$ git reset --hard 0ac49ba</span><br><span class="line">HEAD is now at 0ac49ba add first change</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first</span></span><br></pre></td></tr></table></figure><p>现在又回到了最新的版本，又能够愉快的玩耍了。😊</p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p><code>GIT</code>比其他版本控制系统设计优秀，其中一点是–<code>GIT</code>跟踪并管理的是修改，而非文件。</p><p>下面在<code>README.md</code>内添加信息<code>### second change</code>。之后看下变化后的文件的状态和差异等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">$ git add README.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br></pre></td></tr></table></figure><p>此时，对<code>README.md</code>进行第三次的修改，添加内容<code>### third change</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### third change</span></span><br><span class="line">$ git commit -m <span class="string">"test file modify"</span></span><br><span class="line">[master 18f86ba] <span class="built_in">test</span> file modify</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>上面的演示流程是这样的<code>第一次修改(#### second change) -&gt; git add -&gt; 第二次修改(### third change) -&gt; git commit</code>。但是最后查看状态的时候(git status)，第二次的修改并没有被提交上去。因为<code>GIT</code>管理的是修改，当使用<code>git add</code>命令的时候，在工作区的第一次修改被放入暂存区，准备提交，但是在工作区的第二次修改并没有放入到暂存区，而<code>git commit</code>是将暂存区的修改提交到<code>GIT仓库</code>，所以第二次修改的内容是不会被提交的。这也是说明为什么可以多次添加(git add)，一次提交(git commit)的原因了。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>文件的撤销修改分成三种情况，一种是修改在工作区的内容，一种是修改在暂存区的内容，另一种是修改在<code>GIT</code>仓库的内容。也许会有看者说，不能修改在远程库中的内容吗？有啊，就是<code>git add</code>-&gt;<code>git commit</code>-&gt;<code>git push</code>将远程仓库的内容覆盖被，不过团队人在克隆远程库下来的时候，还是可以查看到你提交的错误内容的。我们现在只针对本地仓库的三种情况谈下自己的看法–</p><p><strong>情况一：撤销工作区的内容</strong></p><p>在管理修改中，自己的工作区还是没有提交，此时想放弃当前工作区的编辑内容执行<code>git checkout -- file</code>。接着上面的内容，我这里的工作区内有的内容是<code>### third change</code>，现在我要放弃第三次修改，只要执行<code>git checkout -- README.md</code>就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### third change</span></span><br><span class="line">$ git checkout -- README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p><strong>情况二：撤销暂存区的内容</strong></p><p>当你不但改乱了工作区的某个文件的内容，还添加(git add)到了暂存区时，想丢弃修改，那么得分两步来撤销文件。先是通过<code>git reset HEAD file</code>，将暂存区的文件退回到工作区，然后通过<code>git checkout -- file</code>放弃修改改文件的内容。为了方便演示，我这里的暂存区没什么内容，所以添加内容<code>### tentative content</code>并将它添加到缓存区。之后，演示将缓存区的内容撤回–</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### tentative content</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">$ git reset HEAD README.md</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">MREADME.md</span><br><span class="line">$ git checkout -- README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p><strong>情况三：撤销GIT仓库的内容</strong></p><p>如果你不仅添加(git add)了内容到暂存区并且提交(git commit)了内容到<code>GIT仓库</code>中了。你需要撤销上一次的内容，也就是要回退到上一个版本，执行<code>git reset --hard HEAD^</code>就可以啦，详细的内容查看<code>版本回退</code>。如下–</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 0ac49ba add first change</span><br><span class="line">$ cat READMEmd</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br></pre></td></tr></table></figure><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库的使用能够提高你和团队的工作效率，无论何时何地，团队的人员都可以在联网的情况下将代码进行拉取，修改和更新。因为我是使用<code>github</code>来管理项目的，所以我的远程仓库是放在github里面。这里默认看者已经安装了<code>github</code>，当然也可以用码云、gitlab等。</p><h3 id="本地库添加到远程库"><a href="#本地库添加到远程库" class="headerlink" title="本地库添加到远程库"></a>本地库添加到远程库</h3><p>这点很容易，登录自己注册的<a href="https://github.com/" target="_blank" rel="noopener">github</a>，如果打不开，请开下VPN。进入自己的首页(<a href="https://github.com/username)，点击`+`号创建(new" target="_blank" rel="noopener">https://github.com/username)，点击`+`号创建(new</a> repository)一个名为<code>learngit</code>的仓库(注意哦⚠️ 名称是本地仓库已经初始化过的，我这里本地有个同名初始化的learngit仓库)，其他的字段自选来填写。点击<code>Create repository</code>创建此远程仓库。紧接着就是进行本地仓库和远程仓库的关联啦，<code>github</code>很友好的提示了你怎么进行一个远程仓库的关联。</p><p><img src="http://omu538iq8.bkt.clouddn.com/tools/git/related_github_step1.png" alt="tools/git/related_github_step1"><br><img src="http://omu538iq8.bkt.clouddn.com/tools/git/related_github_step2.png" alt="tools/git/related_github_step2"><br><img src="http://omu538iq8.bkt.clouddn.com/tools/git/related_github_step3.png" alt="tools/git/related_github_step3"></p><p>现在按照上图来关联下远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/reng99/learngit.git</span><br><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 456 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/reng99/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch master <span class="built_in">set</span> up to track remote branch master from origin.</span><br></pre></td></tr></table></figure><p>注意⚠️ 第一次向远程仓库（关联）push的时候是<code>$ git push -u origin master</code>，不能忽略<code>-u</code>，以后的push不用带<code>-u</code>。至此，打开你的github的相关的仓库就可以看到添加了<code>README.md</code>文件，我这里地址是<code>https://github.com/reng99/learngit</code>，因为我是使用markdown语法写的，控制台显示的内容和仓库的显示内容有所区别啦。<del>(⚠️ 后期我将learngit仓库删除啦，所以你访问链接是找不到这个仓库的，毕竟不想放一个没什么内容的仓库在我的github上)</del>。</p><h3 id="远程库克隆到本地"><a href="#远程库克隆到本地" class="headerlink" title="远程库克隆到本地"></a>远程库克隆到本地</h3><p>从远程仓库克隆东西到本地同样很简单，只需要进入你想克隆的仓库，将仓库的<code>url</code>复制下来（当然你也可以复制window.location.href的内容），运行<code>git clone address</code>。现在我将本地桌面的<code>learngit</code>的仓库删除，然后从远程将<code>learngit</code>克隆到本地。</p><p><img src="http://omu538iq8.bkt.clouddn.com/tools/git/git_clone_repository.png" alt="tools/git/git_clone_repository"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop</span><br><span class="line">$ rm -rf learngit</span><br><span class="line">$ find learngit</span><br><span class="line">find: learngit: No such file or directory</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/reng99/learngit</span><br><span class="line">Cloning into <span class="string">'learngit'</span>...</span><br><span class="line">remote: Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (6/6), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p>成功将<code>gitlearn</code>从远程克隆下来，接下来又可以愉快的玩耍啦。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支管理允许创建另一条线/方向上开发，能够让你在不影响他人工作的情况下，正常的工作。当在自己创建的分支中完成自己的功过后，合并到主分支就行了(git init初始化的时候已经默认创建了master主分支)。一般团队的合作是不在主分支上进行的，个人项目除外（个人理解）。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>当前<code>learngit</code>仓库上只有一个分支，那就是<code>master</code>分支，看者可以通过<code>git branch</code>命令来查看当前的分支，<code>git branch branchName</code>命令来创建一个新的分支，我这里创建的是<code>dev</code>分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop/learngit</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">$ git branch dev</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>现在已经创建了<code>dev</code>分支，有两个分支了，分支前面带有一个星号的分支说明是当前的正在工作的分区。执行上面的分支后，可以简单的画下现在的情况了，有个<code>HEAD</code>指针指向主分支的最新点，刚才新创建的<code>dev</code>分支我这里默认是一个<code>dev</code>的指针指向了<code>dev</code>分支的最新点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">.HEAD指针</span><br><span class="line">.│</span><br><span class="line">├────────*master</span><br><span class="line">└────────dev</span><br><span class="line">│</span><br><span class="line">dev指针</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>我们一般是很少在主分支进行工作的，所以在创建出新的分支之后，我们就切换到新的分支进行相关的工作。可以通过<code>git checkout branchName</code>切换到已经存在的分支工作，通过分支前面的<code>*</code>可查看目前位于哪个分支内。现在我切换到创建的<code>dev</code>分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>在创建好分支后，我们在新的分支上工作完成后，就需要往主分支上进行合并啦。我修改了分支<code>dev</code>上的<code>README.md</code>的内容，就是添加文字<code>### new branch content</code>。合并分支可以分成两个合并的方式，一种是本地合并到materz主分支之后，推送(push)到远程库，一种是直接将分支推送到远程库，在远程库进行合并。</p><p><strong>本地合并推送</strong></p><p>在合并分支前，需要切换到要合并到哪个分支(一般是master主分支)，通过<code>git merge branchName</code>将需要的合并的分支合并到当前分支，我是将<code>dev</code>分支合并到<code>master</code>分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">MREADME.md</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ git merge dev</span><br><span class="line">$ Already up-to-date.</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"merge dev branch"</span></span><br><span class="line">[master d705e73] merge dev branch</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 282 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/reng99/learngit</span><br><span class="line">   0ac49ba..d705e73  master -&gt; master</span><br></pre></td></tr></table></figure><p>合并之后,此时，<code>HEAD</code>指针就指向了<code>dev</code>指针，也就是两者同时指向了<code>master</code>主分支的最新处。具体的内容参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="noopener">传送门</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">├────────*master</span><br><span class="line">└────────dev</span><br><span class="line">│</span><br><span class="line">dev指针 ── HEAD指针</span><br></pre></td></tr></table></figure><p><strong>远程库推送合并</strong></p><p>远程库内合并的话，要先将<code>dev</code>的分支推送到远程库，然后在远程库进行合并。我这里在<code>dev</code>分支上添加了<code>### add new branch content into again</code>然后demo演示推送(git push origin dev)以及合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"add dev branch commit again"</span></span><br><span class="line">[dev dc817c4] add dev branch commit again</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 300 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/reng99/learngit</span><br><span class="line"> * [new branch]      dev -&gt; dev</span><br></pre></td></tr></table></figure><p>接下来就是进入<a href="https://github.com/reng99/learngit" target="_blank" rel="noopener">我的远程learngit仓库</a>进行合并，你会看到下面图示的提示。点击<code>Compare &amp;&amp; pull request</code>，然后写点相关的<code>comment</code>（选填），点击<code>Create pull request</code>。之后在绿色勾的提示下<code>Merge pull request</code>，紧接着点击<code>Confirm merge</code>按钮确定合并此分支，这时候返回主分支就可以看到<code>dev</code>内合并的内容了(后期我改动了dev的内容)。看者如果看得不明白，自己上手尝试一下呗！</p><p><img src="http://omu538iq8.bkt.clouddn.com/tools/git/merge_branch.png" alt="tools/git/merge_branch"></p><p>完成后，你会看到<code>learngit</code>仓库的<code>Pull requests</code>量为1，<code>branches</code>量为2。你可以点击进入分支，在<code>ALL branches</code>里面查看分支的具体内容。</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>在创建了分支，然后将分支的内容合并到主分支后，分支的使命就完成了，你就可以将分支删除了，这里的删除个人认为可以是两种，一种是本地仓库的分支删除，一种是远程仓库的分支的删除。当然啦，留着分支也没啥，可以留着呗<del>，自己认为有点碍眼</del>。</p><p><strong>本地分支的删除</strong></p><p>在本地的<code>learngit</code>的目录下，执行命令行<code>git branch -D branchName</code>就可以删除了。我这里删除的是<code>dev</code>分支。注意⚠️ ，删除的分支不应该是当前工作的分支，需要切换到其他分支，我这里切换的是<code>master</code>分支，毕竟我只有两个分支呢。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git branch -D dev</span><br><span class="line">error: Cannot delete branch <span class="string">'dev'</span> checked out at <span class="string">'/Users/reng/desktop/learngit'</span></span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line">$ git branch -D dev</span><br><span class="line">Deleted branch dev (was dc817c4).</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p><strong>远程库分支的删除</strong></p><p>删除远程库的分支，只要执行<code>git push origin :branchName</code>命令就行了。现在我要删除我远程库中的<code>dev</code>分支，执行<code>git push origin :dev</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :dev</span><br><span class="line">To https://github.com/reng99/learngit</span><br><span class="line"> - [deleted]         dev</span><br></pre></td></tr></table></figure><p>此时，打开我的远程库<a href="https://github.com/reng99/learngit" target="_blank" rel="noopener">learngit</a>，发现之前的<code>Pull requests</code>量为0，<code>branch</code>量为1。</p><h3 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h3><p>通过<code>git branch -m oldBranchName newBranchName</code>来重命名分支。我这里没有分支了，现在创建一个<code>reng</code>分支，然后将它重命名为<code>dev</code>分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">$ git branch reng</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  reng</span><br><span class="line">$ git branch -m reng dev</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>在我们开发的时候，不知道分支和分支之间的进度情况是什么，难免会产生冲突。当产生冲突的时候，就得将冲突的内容更正，然后提交。为了方便演示，我将本地的<code>learngit</code>删除，重新拉取远程的<code>gitlearn</code>仓库(因为我不知道我之前在本地仓库做的修改是啥，对了，我将远程的分支删除了，只剩下master主分支)。克隆下来后，如果还存在本地分支，也将它删除，之后我将在<code>master</code>和<code>dev</code>分支中重新填充里面的<code>README.md</code>的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/reng99/learngit.git</span><br><span class="line">Cloning into <span class="string">'learngit'</span>...</span><br><span class="line">remote: Counting objects: 43, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (17/17), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 43 (delta 4), reused 38 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (43/43), <span class="keyword">done</span>.</span><br><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"add master branch content"</span></span><br><span class="line">[master 1cfa0aa] add master branch content</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 271 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/reng99/learngit.git</span><br><span class="line">   d2f936f..1cfa0aa  master -&gt; master</span><br><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"add dev branch content"</span></span><br><span class="line">[dev 80faf6d] add dev branch content</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"change master content"</span></span><br><span class="line">[master ec18715] change master content</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line">$ git merge dev</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> README.md</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p><code>README.md</code>文件中冲突内容–</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD (当前更改)</span><br><span class="line"><span class="comment">## master content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line">=======</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev (传入更改)</span><br></pre></td></tr></table></figure><p>手动修改了<code>README.md</code>文件中冲突的内容–</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br></pre></td></tr></table></figure><p> 然后命令行执行–</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"fix confict content"</span></span><br><span class="line">[master dd848b4] fix confict content</span><br><span class="line">$ git <span class="built_in">log</span> --graph</span><br><span class="line">*   commit 980788b7690d8bcf14610072fc072460bee7e9f1</span><br><span class="line">|\  Merge: c49d09e 2929dca</span><br><span class="line">| | Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| | Date:   Thu Dec 21 11:14:10 2017 +0800</span><br><span class="line">| | </span><br><span class="line">| |     fix confict content</span><br><span class="line">| |   </span><br><span class="line">| * commit 2929dca91ef8f493adba7744cdad19656538334f</span><br><span class="line">| | Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| | Date:   Thu Dec 21 11:11:49 2017 +0800</span><br><span class="line">| | </span><br><span class="line">| |     add dev branch content</span><br><span class="line">| |   </span><br><span class="line">* | commit c49d09e33e7098d67b59c845d18e9c6f8a8f4fea</span><br><span class="line">|/  Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">|   Date:   Thu Dec 21 11:12:50 2017 +0800</span><br><span class="line">|   </span><br><span class="line">|       change master content</span><br><span class="line">|  </span><br><span class="line">* commit b07f0be8280e4e437cccf2a3f8fac6beef03ff41</span><br><span class="line">| Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| Date:   Thu Dec 21 11:10:51 2017 +0800</span><br><span class="line">| </span><br><span class="line">:</span><br></pre></td></tr></table></figure><p>上面操作过程是，我先从远程库中克隆<code>learngit</code>仓库到本地，目前的本地<code>learngit</code>的分支只有<code>master</code>分支，然后我在<code>master</code>分支的<code>README.md</code>中添加相关的文字(见代码)，接着把它推送到远程库。然后创建并切换<code>dev</code>分支，在<code>README.md</code>文件中添加新内容(见代码)，接着将它提交到<code>GIT仓库</code>。又切换到<code>master</code>分支，修改<code>README.md</code>到内容(见代码)，提交到<code>GIT仓库后</code>开始执行<code>merge</code>命令合并<code>dev</code>分支的内容。此时，产生了冲突，这就需要手动将冲突的内容解决，重新<code>commit</code>到<code>GIT仓库</code>，最后你就可以提交到远程库了(这步我没有演示，也就是git push origin master一行命令行的事情)。最后我还使用<code>git log ----graph</code>打印出整个分支合并图(从下往上看)，方便查看。⚠️ 此时退出<code>git log --graph</code>是书写英文状态按键盘的<code>q</code>键。</p><p>说这么多，目的只有一个 –&gt; 产生冲突后，需要手动调整😊</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>先放上一张分支管理策略图，然后再慢慢讲解相关的内容…</p><p><img src="http://omu538iq8.bkt.clouddn.com/tools/git/manager_branch_tactics.png" alt="tools/git/manager_branch_tactics"></p><p>在分支管理中，我们不断的新建分支，开发，合并分支，删除分支的操作。这里需要注意合并分子的操作，之前我们进行分支的时候是直接将<code>dev</code>开发的分支使用<code>git merge dev</code>进行合并，这样有个缺点：我们看不出分支信息。因为在默认情况下，合并分支的时候，<code>GIT</code>是使用了<code>Fast Foward</code>的模式，在这种模式下，删除分支后，会丢掉分支的信息。下面我重新克隆下我远程<code>learngit</code>仓库，然后创建并更改<code>dev</code>分支的信息，使用默认的模式进行合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line"><span class="comment">### new dev branch content</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"add new dev contentt"</span></span><br><span class="line">[dev 750e1f1] add new dev content</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ git merge dev</span><br><span class="line">Updating 980788b..750e1f1</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">$ git <span class="built_in">log</span> --graph</span><br><span class="line">* commit 750e1f17854872eed4d6cff8315e404079ecb18f</span><br><span class="line">| Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| Date:   Fri Dec 22 10:05:36 2017 +0800</span><br><span class="line">| </span><br><span class="line">|     add new dev content</span><br><span class="line">|    </span><br><span class="line">*   commit 980788b7690d8bcf14610072fc072460bee7e9f1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的合并就是将master分支上面的<code>HEAD</code>指向<code>dev</code>指针，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录是从上往下</span></span><br><span class="line">- before merge</span><br><span class="line">master</span><br><span class="line">* (begin)</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">*</span><br><span class="line">\</span><br><span class="line"> \</span><br><span class="line">  *</span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  * (end)</span><br><span class="line"> dev</span><br><span class="line"> </span><br><span class="line">- after merge</span><br><span class="line">master</span><br><span class="line">* (begin)</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">*</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">* </span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">* (end)</span><br></pre></td></tr></table></figure><p>为了保留分支的情况，保证版本演进的清晰，我们就得使用普通模式合并，也就是在<code>Fast Foward</code>的模式基础上加上<code>--no-ff</code>参数，即<code>git merge --no-ff branchName</code>，不过我们一般加上你合并的相关信息，即<code>git merge --no-ff -m &quot;your msg here&quot; banchName</code>。现在更改<code>dev</code>分支的内容，再进行合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line"><span class="comment">### new dev branch content</span></span><br><span class="line"><span class="comment">### merge with no-ff</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"add no-ff mode content"</span></span><br><span class="line">[dev 80b628c] add no-ff mode content</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">$ git merge dev --no-ff -m <span class="string">"merge with no-ff"</span> dev</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> README.md | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">$ git <span class="built_in">log</span> --graph</span><br><span class="line">*   commit 98746d93a9b64ea02b8ff1c7f0fa5e915405c0e6</span><br><span class="line">|\  Merge: 750e1f1 80b628c</span><br><span class="line">| | Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| | Date:   Fri Dec 22 14:39:32 2017 +0800</span><br><span class="line">| | </span><br><span class="line">| |     merge with no-ff</span><br><span class="line">| |   </span><br><span class="line">| * commit 80b628c334618711b77da81fa805ffc246a2cf7d</span><br><span class="line">|/  Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">|   Date:   Fri Dec 22 14:38:17 2017 +0800</span><br><span class="line">|   </span><br><span class="line">|       add no-ff mode content</span><br><span class="line">|  </span><br><span class="line">* commit 750e1f17854872eed4d6cff8315e404079ecb18f</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使用<code>--no-ff</code>参数的普通模式合并，会执行正常合并，在<code>master</code>主分支上面会生成一个新的节点，如下（<strong>我上面的分支管理策略图里面的合并就是使用了普通的模式</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录是从上往下</span></span><br><span class="line">- --no-ff合并</span><br><span class="line">master</span><br><span class="line">* (before)</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">*</span><br><span class="line">|\ </span><br><span class="line">| \</span><br><span class="line">|  *dev</span><br><span class="line">|  |</span><br><span class="line">|  |</span><br><span class="line">|  *</span><br><span class="line">| /</span><br><span class="line">|/</span><br><span class="line">* (after)</span><br></pre></td></tr></table></figure><p>我们在开发中，分支管理可以分成master主分支、dev开发分支、feature功能分支、release预发布分支、hotfixes修补bug分支。其中功能分支、预发布分支和修补bug分支可以归为<code>临时分支</code>。<code>临时分支</code>在进行分支的合并之后就可以被删除了。下面就一一讲解自己眼中的各种分支。</p><h4 id="主分支master"><a href="#主分支master" class="headerlink" title="主分支master"></a>主分支master</h4><p>主分支是在你初始化仓库的时候(git init)，自动生成的一个master分支，删除不了的哦（演示待会给）。主分支是有且仅有一个，也是发布上线的分支，团队合作的最终代码都会在master主分支上面体现出来。也许你也注意到了分支管理策略图里面的主分支会被打上<code>TAG</code>的标签，这是为了方便到某个时间段对版本的查找，标签tag的学习总结后面给出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录是从上往下</span></span><br><span class="line">master</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">*(tag 1.0)</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">*(tag 1.1)</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">*(tag 1.2)</span><br></pre></td></tr></table></figure><p>下面代码演示下不能放删除master的情况:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line">$ git branch -D master</span><br><span class="line">error: Cannot delete branch <span class="string">'master'</span> checked out at <span class="string">'/Users/reng/desktop/learngit'</span></span><br></pre></td></tr></table></figure><h4 id="开发分支develop"><a href="#开发分支develop" class="headerlink" title="开发分支develop"></a>开发分支develop</h4><p>在开发的过程中，项目合作者应该保持自己本地有一个开发环境的分支，在进行分支开发之前，需要进行<code>git pull</code>拉取<code>master</code>主分支的最新内容，或者通过其他的方法。在获取到最新的内容之后才可以进行本地的新功能的开发。在开发完成后将内容<code>merge</code>到主分支之后，不用将<code>dev</code>分支删除，因为你开发的就是在这里进行，何必删除后再新建一个开发环境的分支呢。</p><p>接着上面的情况，我目前已经拥有了<code>dev</code>开发分支:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h4 id="功能（特性）分支feature"><a href="#功能（特性）分支feature" class="headerlink" title="功能（特性）分支feature"></a>功能（特性）分支feature</h4><p>一个软件就是一个个功能叠加起来的，在软件的开发中，我们总不能在主分支开发，将主分支搞乱吧。当然，你可以在dev分支中开发，一般新建功能分支来开发，然后功能开发完再合并到dev分支，之后删除功能分支。需要的时候就可以将<code>dev</code>开发分支合并到<code>master</code>主分支，这样就随时保证<code>dev</code>分支功能的完整性。</p><p>下面演示功能分支<code>user</code>开发（随便写点内容）的合并（这里也演示了合并到master主分支，跳过了release分支的测试），删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ git branch user</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  user</span><br><span class="line">$ git checkout user</span><br><span class="line">Switched to branch <span class="string">'user'</span></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line"><span class="comment">### new dev branch content</span></span><br><span class="line"><span class="comment">### merge with no-ff</span></span><br><span class="line"><span class="comment">### function user</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"function user was acheive"</span></span><br><span class="line">[user 26beda3] <span class="keyword">function</span> user was acheive</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ git merge --no-ff -m <span class="string">"merge user feature"</span> user</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> README.md | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 3 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">$ git merge --no-ff -m <span class="string">"merge dev branch"</span> dev</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> README.md | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">$ git <span class="built_in">log</span> --graph</span><br><span class="line">*   commit f15a1e9012635fc21e944ab76c4cd4bbd539f82f</span><br><span class="line">|\  Merge: 98746d9 0ca83c6</span><br><span class="line">| | Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| | Date:   Fri Dec 22 16:35:43 2017 +0800</span><br><span class="line">| | </span><br><span class="line">| |     merge dev branch</span><br><span class="line">| |     </span><br><span class="line">| *   commit 0ca83c654df64724743a966f5f0989477e504cbc</span><br><span class="line">| |\  Merge: 80b628c 26beda3</span><br><span class="line">| | | Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| | | Date:   Fri Dec 22 16:33:27 2017 +0800</span><br><span class="line">| | | </span><br><span class="line">| | |     merge user feature</span><br><span class="line">| | |    </span><br><span class="line">| | * commit 26beda3b8246e047f10ac0461ca11d1a6f132819</span><br><span class="line">| |/  Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| |   Date:   Fri Dec 22 16:31:41 2017 +0800</span><br><span class="line">| |   </span><br><span class="line">| |       <span class="keyword">function</span> user was acheive</span><br><span class="line">| |     </span><br><span class="line">* |   commit 98746d93a9b64ea02b8ff1c7f0fa5e915405c0e6</span><br><span class="line">|\ \  Merge: 750e1f1 80b628c</span><br><span class="line">| |/  Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">:</span><br><span class="line">$ git branch -D user</span><br><span class="line">Deleted branch user (was 26beda3).</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h4 id="预发布分支release"><a href="#预发布分支release" class="headerlink" title="预发布分支release"></a>预发布分支release</h4><p>在进行一系列的功能的开发和合并后，在满足迭代目标的时候，就可以打包送测了。这里就需要一个预发布分支release。预发布分支是指在发布正式版本之前（ 即合并到master分支之前，可查看上面分支管理策略图），需要一个有预发布的版本（可以理解为灰度环境）进行测试。</p><p>预发布环境是从<code>dev</code>分支上面分出来的，预发布结束之后，必须合并到<code>dev</code>和<code>master</code>分支上面。这里我就不演示了，跟功能分支差不多，就是合并的时候要合并到<code>dev</code>和<code>master</code>上，这时候<code>dev</code>分支和<code>master</code>的同步的代码，就不需要将<code>dev</code>分支合并到<code>master</code>了。最后将预发布分支删除掉。</p><h4 id="修复bug分支-bug-hotfixes"><a href="#修复bug分支-bug-hotfixes" class="headerlink" title="修复bug分支 bug/hotfixes"></a>修复bug分支 bug/hotfixes</h4><p>在写代码的过程中，由于种种原因 -&gt; 比如功能考虑不周全，版本上线时间有限，产品突然改需求等，我们写的代码就出现一些或大或小的bug或者需要紧急修复。那么我们就可以使用bug分支（其实就是新建一个分支处理bug而已啦，命名随意起的），然后在这个分支上处理编码出现的问题。我在<code>分支管理策略图</code>上面已经展示了一种出现bug的情况 -&gt; 就是在测试发布版本看似没问题的情况下，将<code>release</code>版本整合到<code>master</code>和<code>dev</code>中，这时候火眼精金发现了遗留的一个bug，然后新建一个<code>bug分支</code>处理，再合并到<code>master</code>和<code>dev</code>中，之后将<code>bug分支</code>移除啦。</p><p>在开发的过程中，无论咋样都是这样 : 新建bug分支 -&gt; 把分支合并 -&gt; 删除分支，这里的demo就不演示了，可以参考上面的<code>功能（特性）分支feature</code>。</p><p>这里需要注意⚠️的一点，当在开发的过程中，开发到一定的程度，需要停下来需改紧急的bug，那么需要停下手头的工作需改bug啦。这时候需要将工作现场储藏(stash功能)起来，等以后回复现场了后接着工作。现在我在原先的<code>gitlearn</code>仓库中<code>README.md</code>文件文末添加<code>### modify content</code>内容来进行演示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop</span><br><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line"><span class="comment">### new dev branch content</span></span><br><span class="line"><span class="comment">### merge with no-ff</span></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: 80b628c add no-ff mode content</span><br><span class="line">HEAD is now at 80b628c add no-ff mode content</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>然后过段时间(这里省略修改的演示)，代码已经修改好合并后，需要回到最新的内容区域进行工作，这就需要还原最新的内容了，demo如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: 80b628c add no-ff mode content</span><br><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (9e85bcc8435ae38c17db59ddc3cd8401af404827)</span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>⚠️ <code>git stash</code>不仅可以隐藏工作区的内容，也可以隐藏暂存区的内容。<code>git stash list</code>是查看隐藏的列表。<code>git stash pop</code>是将隐藏的内容恢复并删除，<code>git stash pop</code>相当于<code>git stash apply &amp;&amp; git stash drop</code>，这里的<code>git stash apply</code>是恢复隐藏内容，<code>git stash drop</code>是删除隐藏内容。</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>简单谈下自己git协作的过程吧。在负责人将搭建好的仓库上传到远程的仓库后（一般是包含了master默认的分支和dev分支），自己将远程仓库克隆到本地，然后在本地的仓库上新建一个<code>dev分支</code>，将远程的dev分支重新拉取下<code>git pull origin dev</code>，开发完成后就可以提交自己的代码到<code>远程的dev分支了</code>，如果提交之前或者之后需要修改bug或者添加新的需求的话，需要新建一个相关的分支并完成开发，将他们合并到<code>本地dev</code>分支后上传到<code>远程dev</code>分支。如果新建的<code>远程仓库中只有master分支</code>，我是这样处理的：依然要在本地新建一个<code>dev</code>分支，然后在完成特定版本的开发后，将分支合并到<code>本地master分支</code>然后再推送到<code>远程master</code>分支，本地的<code>dev分支</code>保留哦。我自己比较偏向于第一种情况。</p><p>注意⚠️ 如果<code>master</code>主分支有内容更新的话，而你又在分支上开发，如果要拉取主分支最新的内容，直接<code>git pull origin master</code>就行了。</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本前，为了唯一确定时刻的版本，我们通常在版本库中打一个标签(tag)，方便在发布版本以后，可以在某个时刻将某个历史的版本提取出来（因为标签tag也是版本库的一个快照）。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>创建标签是默认在你切换的分支最新提交处创建的。我这里在本地桌面的<code>learngit仓库</code>的<code>master分支</code>上打一个<code>v1.0标签</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop/learngit</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ git tag</span><br><span class="line">$ git tag v1.0</span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>当然，你可以在非新commit的地方进行标签。这就需要你查找到需要打标签处的commit的id，然后执行<code>git tag tagName commitId</code>。这里我随意找master分支中的commit id进行标签<code>v0.9</code>的标签创建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">f15a1e9 merge dev branch</span><br><span class="line">0ca83c6 merge user feature</span><br><span class="line">26beda3 <span class="keyword">function</span> user was acheive</span><br><span class="line">98746d9 merge with no-ff</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现在在commit id为 <code>98746d9</code>处打标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 98746d9</span><br><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>在上面创建标签，我们已经有了标签<code>v0.9 v1.0</code>。有时候我们标签打错了，需要进行删除，那么就得更改啦，运用<code>git tag -d tagName</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag <span class="string">'v0.9'</span> (was 98746d9)</span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">$ git tag v0.8 80b628c -m <span class="string">"version 0.8"</span></span><br><span class="line">$ git tag</span><br><span class="line">v0.8</span><br><span class="line">v1.0</span><br><span class="line">$ git show v0.8</span><br><span class="line">$ git show v0.8</span><br><span class="line">tag v0.8</span><br><span class="line">Tagger: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">tag v0.8</span><br><span class="line">Tagger: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">Date:   Wed Dec 27 16:07:46 2017 +0800</span><br><span class="line"></span><br><span class="line">version 0.8</span><br></pre></td></tr></table></figure><p>在上面的演示中，我删除了v0.9，然后在创建v0.8的时候追加了打标签的信息，之后使用<code>git show tagName</code>查看签名信息。</p><p>我们还可以进行分支切换标签，类似于分支的切换，我这里打的两个标签的内容是不同的，我可以通过观察内容的改表来得知时候成功切换标签了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.8</span><br><span class="line">v1.0</span><br><span class="line">$ git checkout v1.0</span><br><span class="line">HEAD is now at f15a1e9... merge dev branch</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line"><span class="comment">### new dev branch content</span></span><br><span class="line"><span class="comment">### merge with no-ff</span></span><br><span class="line"><span class="comment">### function user</span></span><br><span class="line">$ git checkout v0.8</span><br><span class="line">Previous HEAD position was f15a1e9... merge dev branch</span><br><span class="line">HEAD is now at 80b628c... add no-ff mode content</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line"><span class="comment">### new dev branch content</span></span><br><span class="line"><span class="comment">### merge with no-ff</span></span><br></pre></td></tr></table></figure><p>在确认好标签后，就可以像远程推送标签了，我这里推送<code>v1.0</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/reng99/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>上面是使用<code>git push origin tagName</code>推送特定的<code>tag</code>到远程库，但是我们能不能推送全部的tag呢？答案是肯定的，看者可以通过<code>git push origin --tags</code>进行推送。有时候，我们推送了<code>tag标签到远程库中了</code>，现在想删除掉怎么办？这个就略微麻烦点，我们不能像上面提到的删除本地库的标签那样，通过<code>git tag -d tagName</code>那样，而是通过<code>git push origin :refs/tags/tagName</code>，这里不演示，如果看者感兴趣可以自己来把弄一下哦。</p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰官方网站–Git教程</a></p><p><a href="http://wwwman.yiibai.com/git/" target="_blank" rel="noopener">易百教程–Git教程</a></p><p><a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a></p><p><a href="http://s3.51cto.com/wyfs02/M02/12/44/wKiom1MA0v-horoSAAS4v41ef_U068.jpg" target="_blank" rel="noopener">分支管理模型图</a></p><p><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">Git分支管理策略 - 阮一峰的网络日志</a></p><p style="color:red;text-align:center;">完结 @~@</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/tools/git/git-banner.jpg&quot; alt=&quot;tools/git/git-banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇博文是自己在学习git过程中的思考总结。本文仅仅代表个人的看法，如有不妥地方还请本文文末留言。 😊 &lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://reng99.cc/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://reng99.cc/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>桂林阳朔旅游</title>
    <link href="http://reng99.cc/2017/12/04/tourist-guiLin-and-yangShuo/"/>
    <id>http://reng99.cc/2017/12/04/tourist-guiLin-and-yangShuo/</id>
    <published>2017-12-04T08:04:20.000Z</published>
    <updated>2017-12-13T01:59:49.345Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/guilin_banner.jpg" alt="life/tourist/guilin/guilin-banner"></p><p>桂林市区的两江四湖的夜景很美丽，还有桂林市区的一些步行街走起来挺舒服的。然后就是阳朔啦，我喜欢那山里的清新的空气(哈哈哈，不过，我更喜欢家里海边的空气)。在山里面就好像与世隔绝，可能一个人在喧闹的城市呆久了，都会喜欢吧。⚠️ 多图博文，手机党要留意咯。</p><a id="more"></a><p>此次的桂林阳朔之旅三个人一起游玩放松，一个是好友从柳州过来桂林，另一个本身就在桂林读研究生，还有我啦–从广州这边过去呗，一共在那边呆三天，两天桂林市区(2017.12.01 &amp;&amp; 2017.12.03)和一天阳朔(2017.12.02)。</p><p>这次不像<code>丹霞山旅游</code>的流水帐那样写游记啦，仅仅谈下个人在阳朔的感受，桂林市区的没啥好谈的，毕竟是市区，都那样。</p><p>也许在广州呆的时间久了的原因，去到阳朔有不一样的体验—-第一次进山的新鲜感。第一次来阳朔，除了玩了一下当地人推荐的旅游的项目，比如坐竹筏游漓江啊。我比较喜欢租电驴(电动摩托)在山间闲逛一个下午的那段经历。哈哈,带着感冒开了一个下午。</p><p>开着电驴，进入山里面闲逛，没有目标，没有时间观念，抛离城市的喧闹与繁华。山里面的空气超级好，活脱一个天然的氧吧。自己开开停停，哎呀，这里的风景不错哦，那座山还行哦，这湖賊好看，这里有活动…嗯，我们就缺了个单反，还有如果朋友再高点，再瘦点，脸再…哈哈哈，我就有模特啦，不过手机拍出来的效果还不赖啦<del>(本博文的照片都是用自己的手机拍的啦)</del>。在阳朔的山间看到了一个新人在取景拍婚纱照，看到了骑着自行车的几个外国人在标着<code>村上春树</code>字样的山间小屋前面停下来欣赏，吃了当地阿婆自己种的柚子(虽然有些皱皮，时间久了，但是还是挺美味的啦)，感受到了山里人慢节奏的生活…嗯，没有更多的详细内容，要具体展开的话，我可以写一万字，看者可以亲自去体会下啦。</p><p>下面放上自己觉得还可以的照片啦—-</p><p><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/three_person_feet.jpg" alt="three_person_feet"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/hotel.jpg" alt="hotel"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/mountain01.jpg" alt="mountain01"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/mountain02.jpg" alt="mountain02"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/mountain03.jpg" alt="mountain03"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/motorcycle.jpg" alt="motorcycle"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/boat_and_mountain.jpg" alt="boat_and_mountain"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/school_grass.jpg" alt="school_grass"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/guilin_street_evening.jpg" alt="guilin_street_evening"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/two_towns.jpg" alt="two_towns"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/wedding_scene.jpg" alt="wedding_scene"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/delicious_food.jpg" alt="delicious_food"></p><p>文章的结尾简单谈下自己的一些攻略：</p><ol><li>广州出发的话，要提前坐交通工具到广州南站坐高铁，自己就是刚踩点过了安检，感觉就是在作死啊</li><li>广州南站出发到桂林，建议买到桂林站<del>(其次是桂林北)</del>，因为你可以在那边比较方便在繁华的地方租到房子，费用大概¥ 100/晚。当然啦，选择旅游淡季去，并且选择网购旅店，实体店买贵了¥40（我选择在西城步行街那里的青皮树酒店住下，网购¥99/晚，在那里可以逛夜市，并且离两江四湖比较近）</li><li>从桂林市区去阳朔的话，选择滴滴顺风车<del>（免费为滴滴打了一波广告）</del>，选择滴滴，当然是因为实惠啦，如果正常坐大巴过去阳朔的话，时间和金钱成本有所提升（看者可以自行比较呢）,我们从西城步行街滴滴顺风车过去阳朔的时间是一个小时左右，费用是¥33/人。从阳朔回来也是坐滴滴的顺风车。</li><li>在阳朔玩的时候，可以租借电驴（电动摩托）去玩，我们当初是¥40元/辆<del>滴滴司机说淡季一般是¥30/辆，看你砍价啦，我们从¥50/辆降到¥40/辆</del>，其他的景点看兴趣选择，进山必须是电驴啊，骑自行车踩累死你啦。</li><li>偶尔光顾阳朔街边的老奶奶老爷爷大叔大婶（请允许我这样称呼，年轻人没看到几个在路边摆摊的）</li><li>就餐的话，在桂林我推荐的是<code>椿记烧鹅</code>（倒数第二张餐厅图就是它）,在阳朔只要不在西街的饭店里面吃就行<del>(我们在饭店里面被坑了一次，东西贵而且味道不咋样，本来朋友要拉我走的，我都还没反应过来就点餐了)</del></li></ol><p>先就这么多攻略吧，后期如果有发现其他实用的我再放上去啦！😊 欢迎看者补充啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/guilin_banner.jpg&quot; alt=&quot;life/tourist/guilin/guilin-banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;桂林市区的两江四湖的夜景很美丽，还有桂林市区的一些步行街走起来挺舒服的。然后就是阳朔啦，我喜欢那山里的清新的空气(哈哈哈，不过，我更喜欢家里海边的空气)。在山里面就好像与世隔绝，可能一个人在喧闹的城市呆久了，都会喜欢吧。⚠️ 多图博文，手机党要留意咯。&lt;/p&gt;
    
    </summary>
    
      <category term="诗和远方" scheme="http://reng99.cc/categories/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
    
      <category term="旅游" scheme="http://reng99.cc/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>vue2.0 踩坑记</title>
    <link href="http://reng99.cc/2017/11/27/vue-attention/"/>
    <id>http://reng99.cc/2017/11/27/vue-attention/</id>
    <published>2017-11-27T13:10:52.000Z</published>
    <updated>2018-01-20T03:12:02.965Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/vuejs/attention/vue_attention_logo.jpg" alt="frontend/vuejs/attention/vue_attention_logo"></p><p>自己接触vuejs将近一年，在这段时间里面，一共参与了公司以vuejs技术为框架的两个项目—-工单系统（公司内部项目，不方便贴链接）和淘米淘手游交易平台移动端（未上线）。本文是自己在使用vuejs开发过程中踩到的坑，特此记录下来的文章。嗯，希望对相关的技术爱好者有所帮助啦<del>（如果你知道我在讲什么的话）</del> 😊</p><a id="more"></a><p>对了，在开始写文章之前，先说明下: 文章里面的代码，是在<code>.vue</code>后缀的文件中实现的，在脚手架<code>vue-cli</code>搭建的项目上已经验证过，如有疑问，请自行验证或者在文章底部留言功能那里留言(仅支持<a href="https://github.com/" target="_blank" rel="noopener">github</a>账号用户),或者邮箱留言(1837895991@qq.com)哦。</p><h2 id="父组件传递消息给子组件"><a href="#父组件传递消息给子组件" class="headerlink" title="父组件传递消息给子组件"></a>父组件传递消息给子组件</h2><p>使用props，下面先来看一个简单的例子:</p><p>父组件: parent.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"parent"</span>&gt;</span><br><span class="line">        &lt;child-component :title=<span class="string">'parentTitle'</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> childComponent <span class="keyword">from</span> <span class="string">'@/components/path/to/childComponent.vue'</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                parentTitle: <span class="string">'title form parent'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            childComponent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">    #parent&#123;&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>子组件: childComponent.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"child"</span>&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    export default &#123;</span></span><br><span class="line"><span class="regexp">        data () &#123;</span></span><br><span class="line"><span class="regexp">            return &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        props: &#123;</span></span><br><span class="line"><span class="regexp">            title: &#123;</span></span><br><span class="line"><span class="regexp">                type: String,   /</span><span class="regexp">/ 可设置类型</span></span><br><span class="line"><span class="regexp">                default: 'title from child'     /</span><span class="regexp">/ 默认值</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    #child&#123;&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>最后显示的结果是父亲传过来的消息，即信息为<code>title form parent</code>的h1标题。在父组件向子组件传递消息的过程中，首先，父亲需要拿到子组件<code>&lt;child-component /&gt;</code>,然后告诉子组件我要传递一个title给你<code>:title=&#39;parentTitle&#39;</code>，注意查收。接着，子组件通过<code>props</code>新建一个title的属性，并将数据读取到数据填充到相应的位置。详情看<a href="https://cn.vuejs.org/v2/guide/components.html#Prop" target="_blank" rel="noopener">官网Prop</a></p><h2 id="子组件传递消息给父组件"><a href="#子组件传递消息给父组件" class="headerlink" title="子组件传递消息给父组件"></a>子组件传递消息给父组件</h2><p>子组件是通过<code>$emit</code>向父组件发送事件和相关的数据，来传递信息给父组件。</p><p>子组件(child.vue)的demo代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=<span class="string">"child"</span>&gt;</span><br><span class="line">&lt;button @click=<span class="string">"toParent"</span>&gt;向父组件传递消息&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">name: "child",</span></span><br><span class="line"><span class="regexp">data () &#123;</span></span><br><span class="line"><span class="regexp">return &#123;</span></span><br><span class="line"><span class="regexp">message: 'message from children'</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">methods: &#123;</span></span><br><span class="line"><span class="regexp">toParent () &#123;</span></span><br><span class="line"><span class="regexp">var vm = this;</span></span><br><span class="line"><span class="regexp">vm.$emit('child-say',vm.message);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>父组件demo代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=<span class="string">"parent"</span>&gt;</span><br><span class="line">&lt;child-component :child-say=<span class="string">"parentEvent"</span> /&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import childComponent from '@/</span>components/path/to/child.vue<span class="string">';</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">name: '</span>parent<span class="string">',</span></span><br><span class="line"><span class="string">data () &#123;</span></span><br><span class="line"><span class="string">return &#123;</span></span><br><span class="line"><span class="string">msg : '</span><span class="string">'</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">methods: &#123;</span></span><br><span class="line"><span class="string">parentEvent: function (data) &#123; // data 是子组件传过来的数据</span></span><br><span class="line"><span class="string">var vm = this;</span></span><br><span class="line"><span class="string">vm.msg = data;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">components: &#123;</span></span><br><span class="line"><span class="string">childComponent</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码的过程是，点击了子组件里面的<code>向父组件传递消息</code>的按钮，将子组件里面的<code>message</code>信息放在<code>$emit</code>里面发送给父组件，而父组件在引用的子组件中新建一个事件来接受传过来的信息，然后在父组件中创建的方法对<code>data</code>里面的msg进行数据的改写。最终在页面上显示出的<code>h1</code>标题信息为<code>message from children</code>，即是子组件里面的信息。嗯，官网相关<a href="https://cn.vuejs.org/v2/api/#vm-emit" target="_blank" rel="noopener">传送门</a></p><h2 id="绑定HTML-Class"><a href="#绑定HTML-Class" class="headerlink" title="绑定HTML Class"></a>绑定HTML Class</h2><p>类名结合style的使用一般是用来动态改变样式，所以要用到<code>v-bind:class</code><br>简写<code>:class</code>。</p><p>demo如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"default-bg"</span> :<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123;'active-bg':flag&#125;"</span> @click=<span class="string">"changeBtnBg"</span>&gt;按钮&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">data () &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">flag : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">changeBtnBg: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">vm.flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">.default-bg&#123;</span></span><br><span class="line"><span class="regexp">background: red;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">.active-bg&#123;</span></span><br><span class="line"><span class="regexp">background: blue;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，实现了一个<code>红色按钮通过点击自身实现变成绿色按钮的功能</code>。首先，自己给到一个默认的红色的按钮，并且在按钮上绑定了<code>changeBtnBg</code>的方法，用于控制标志符<code>flag</code>的布尔值。值得注意的是，<code>:class</code>通过<code>flag</code>的真假值来决定是否改变按钮的背景色为定义的绿色。官网相关请戳<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#main" target="_blank" rel="noopener">这里</a></p><h2 id="v-model引用的数据需初始化"><a href="#v-model引用的数据需初始化" class="headerlink" title="v-model引用的数据需初始化"></a>v-model引用的数据需初始化</h2><p>也许你遇到这个问题，命名写了<code>&lt;input type=&quot;text&quot; v-model=&quot;inputMsg&quot; /&gt;</code>,可是相关的数据绑定<code>&lt;div&gt;&lt;/div&gt;</code>却没有消息，并报错。这是因为你还没有初始化相关的数据啊。正确的姿势应该像下面👇</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"inputMsg"</span>/&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;inputMsg&#125;&#125;&lt;div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">data () &#123;</span></span><br><span class="line"><span class="regexp">return &#123;</span></span><br><span class="line"><span class="regexp">inputMsg : ''  /</span><span class="regexp">/ 记得初始化数据哦</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h2 id="style中的scoped"><a href="#style中的scoped" class="headerlink" title="style中的scoped"></a>style中的scoped</h2><p>也许你注意到了我上面的代码中，在每个<code>&lt;style&gt;&lt;style&gt;</code>的元素中添加了<code>scoped</code>。scoped是用来限定样式的作用的范围，防止此组件里面的样式和其他组件的同名的样式产生冲突。比如—-</p><p>component1.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1 id = <span class="string">"title"</span>&gt;component1<span class="string">'s title&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string">&lt;style scoped&gt;</span></span><br><span class="line"><span class="string">#title&#123;</span></span><br><span class="line"><span class="string">color: red;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure><p>component2.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1 id=<span class="string">"title"</span>&gt;component2<span class="string">'s title&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string">&lt;style scoped&gt;</span></span><br><span class="line"><span class="string">#title&#123;</span></span><br><span class="line"><span class="string">color: blue;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的两个组将<code>component1.vue &amp;&amp; component2.vue</code>中，虽然都有相同的id，但是对各自没什么影响。简单说，加上scoped之后，样式的编写只对本组件有效。</p><p style="color:red;text-align:center;">精力有限，未能一次性更新完,忘见谅…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/vuejs/attention/vue_attention_logo.jpg&quot; alt=&quot;frontend/vuejs/attention/vue_attention_logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;自己接触vuejs将近一年，在这段时间里面，一共参与了公司以vuejs技术为框架的两个项目—-工单系统（公司内部项目，不方便贴链接）和淘米淘手游交易平台移动端（未上线）。本文是自己在使用vuejs开发过程中踩到的坑，特此记录下来的文章。嗯，希望对相关的技术爱好者有所帮助啦&lt;del&gt;（如果你知道我在讲什么的话）&lt;/del&gt; 😊&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="vuejs" scheme="http://reng99.cc/tags/vuejs/"/>
    
      <category term="mvvm" scheme="http://reng99.cc/tags/mvvm/"/>
    
  </entry>
  
  <entry>
    <title>丹霞山旅游</title>
    <link href="http://reng99.cc/2017/11/26/tourist-danXia-mountain/"/>
    <id>http://reng99.cc/2017/11/26/tourist-danXia-mountain/</id>
    <published>2017-11-26T08:10:53.000Z</published>
    <updated>2017-11-26T16:12:43.848Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/tickets.jpg" alt="life/tourist/danxia/tickets"></p><p>由于公司的项目–<a href="https://www.taomitao.com/" target="_blank" rel="noopener">淘米淘手游交易平台</a>,自己已经有三个月没有离开过广州游玩了。刚好项目自己负责的部分已经ok，然后好友约了周末(2017.10.28～2017.10.29)去韶关爬丹霞山，自己不假思索的答应了！</p><a id="more"></a><p>我们是四个人一同前往—-两位女生两位男生，同行的四个人中，我只认识我的好友(那个肥嘟嘟脸的男生)，不认识两位女生，因为在旅行完之后没有联系了，忘了她们的名字了，暂且用女生A(戴帽子笑起来很甜的女生)和女生B(一直被吐槽摆不好poss的女生😂 )来区分吧。四人组见下图 :<br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/we.jpg" alt="life/tourist/danxia/we"></p><p>女生A : 好美啊！空气很好<br>女生B : 周末来得值啊，下次还来<br>好友 : 这山爬得都不累<br>我 : 能在这里住真是超级幸福的<br>…<br>以下省略若干在归途中的对话。是啊，这趟来得很ok啊，重阳节在这么美的地方爬山，真的是超级满足的呢。</p><p>我们这两天的计划是，去山顶上看日落和日出，剩下的时间就是在山间闲逛，感受自然。计划如此，除了没能在山顶（人太多，登不上阳元山的顶部看日落，只能够在山腰山看日落了）。</p><p>我们早上从广州火车站出发，坐火车直达韶关东，然后坐大巴去丹霞山，买了低配版的门票（150元/人的48小时有效的票）进入丹霞山里面，在兜兜转转后还是女生B电话给来过的同事请教攻略，果断的拒接了在景区山脚下拉客的旅店店主，坐着<code>免费的公交</code>（其实费用包含在票价里面了）兜兜转转的去到被推荐的景区里面当地人的旅店住下。此刻必须赞一下店主啊—-因为我们选好房间后，直接将随身带的行李放到各自的房间后就去吃午餐了没登记个人信息，但是店主知道有人介绍过来的并没有叫我们返回登记，还有店主很是热心的比划着路线给我们。对了，我们住的店是<a href="http://hotels.ctrip.com/hotel/4216382.html?isFull=F#ctm_ref=hod_sr_lst_dl_n_1_1" target="_blank" rel="noopener">放假啦客栈</a>，租了两间双人房（100元/天，ps:当地人的房子改装的租房，整片区域的价格都差不多）。</p><p>来到丹霞山的第一天，简单的吃了顿午饭，我们一行四人就奔着看日出的地点<code>长老峰</code>那里踩点去了，因为观日出的地方<code>阳元山</code>在另一边，得提前熟悉下呢。然后我们就坐车返回原地走路去<code>阳元山</code>看日落，可能我们去的比较晚又加上那天是<code>重阳节</code>,人多得我们上不了山顶，只能在山腰上观看了。对了，比较逗的是，爬<code>阳元山</code>的女生A因为山路陡恐高症瞬间爆发，腿软难以前行。<br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/sunset.jpg" alt="life/tourist/danxia/sunset"></p><p>第二天早上，我们五点就起床等车去<code>长老峰</code>看日出，这个点，公交的站点已经聚集了些人，此时天空还是可以看到星星几点。我们被送到长老峰不远处的终点站，大概是5:40分开始刷票进入长老峰，并沿着路灯一路爬上山顶。漆黑的凌晨借助着微弱的灯光，小心翼翼的爬着陡峭的山路，一大早就出着汗，还是第一次。我们爬到山顶的时候，有很多的人已经在山顶的平台了，我们很是难挤到里面去（对了，有人山顶上依靠帐篷过夜的）。选好一个不错的位置，在天边泛白的时候，踮着脚尖，看着太阳慢慢的奔出来，很是满足。<br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/sunrise1.jpg" alt="life/tourist/danxia/sunrise1"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/sunrise2.jpg" alt="life/tourist/danxia/sunrise2"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/sunrise3.jpg" alt="life/tourist/danxia/sunrise3"></p><p>之后，在日出一段时间后，我们便下山根据地图，依据着店主推荐的路线去逛下其他的风景，神奇的是，我们真能走，又闲逛了好远的地方，期间自己还担任了女生A的摄影师，哈哈哈，我的拍照技术还是ok的啦。四人组边走边聊，从本来有些约束到自然交流，在山间中走动，那山很俊，那林很绿，那水很清，倍感轻松😄<br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/idiom1.jpg" alt="life/tourist/danxia/idiom1"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/idiom2.jpg" alt="life/tourist/danxia/idiom2"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/idiom3.jpg" alt="life/tourist/danxia/idiom3"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/idiom4.jpg" alt="life/tourist/danxia/idiom4"></p><p>对了，在吃的方面，我们在同一家店吃了走地鸡，味道棒棒的（原谅我忘记了店名），还有客家三宝这道菜，自己蛮喜欢的。</p><p>时间到了29号三四点的时候，我们就启程离开景区回广州了，结束丹霞山的两日游。</p><p>在本次的游玩中，自己整理了点旅游攻略，希望对见者有帮助或者重游的时候有提示：</p><ul><li>提前两三天联系景区的旅店老板，定好房间。有下面的原因：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 景区内和景区外的住房的价格是相差不大的，尽量在景区内订房，这样会节省你很多的时间</span><br><span class="line">2. 需要提前联系旅店的老板帮你定景区的票，这样会为你省下不少的经费（吐槽下，外来人的票价和当地人的票价相差太远）</span><br><span class="line">3. 寻找有去过丹霞山的朋友，取一下当初居住的旅店的老板的联系方式，在那里订房会得到一定程度的照顾</span><br></pre></td></tr></table></figure><ul><li><p>两天时间丹霞山游玩足够</p></li><li><p>过去韶关的话，如果经济条件还可以的话，还是不要选择火车吧</p></li><li><p>不要在什么国庆节啊节日过去，尽量选择周末</p></li><li><p>多多欣赏自然风光，拍照不游玩，游玩不拍照</p></li><li><p>学好拍照技术出去玩会更加惬意哦(带上专业的摄像机更好呢)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/tickets.jpg&quot; alt=&quot;life/tourist/danxia/tickets&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于公司的项目–&lt;a href=&quot;https://www.taomitao.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;淘米淘手游交易平台&lt;/a&gt;,自己已经有三个月没有离开过广州游玩了。刚好项目自己负责的部分已经ok，然后好友约了周末(2017.10.28～2017.10.29)去韶关爬丹霞山，自己不假思索的答应了！&lt;/p&gt;
    
    </summary>
    
      <category term="诗和远方" scheme="http://reng99.cc/categories/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
    
      <category term="旅游" scheme="http://reng99.cc/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
</feed>
