<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Reng の 博客</title>
  
  <subtitle>If you don&#39;t think, then you shouldn&#39;t talk.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://reng99.cc/"/>
  <updated>2018-03-25T09:52:09.966Z</updated>
  <id>http://reng99.cc/</id>
  
  <author>
    <name>嘉明</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小结http</title>
    <link href="http://reng99.cc/2018/03/11/summerize-http/"/>
    <id>http://reng99.cc/2018/03/11/summerize-http/</id>
    <published>2018-03-11T05:25:22.000Z</published>
    <updated>2018-03-25T09:52:09.966Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/network/http/http_banner.jpg" alt="network/http/http_banner"></p><p>了解http是前端工程师必备的一个技能哈，虽然现在自己不是很了解，但是根据查阅的资料，自己谈下自己的总结啦！路漫漫兮其修远…</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Web使用一种名为HTTP(HyperText Transfer Protocol，超文本传输协议)的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定。可以说，Web是建立在HTTP协议上通信的。</p><h3 id="HTTP是干什么的？"><a href="#HTTP是干什么的？" class="headerlink" title="HTTP是干什么的？"></a>HTTP是干什么的？</h3><p>http是数据传输协议（超文本传输协议），用来沟通客户端和服务器。</p><h3 id="什么是资源"><a href="#什么是资源" class="headerlink" title="什么是资源?"></a>什么是资源?</h3><p>网络上的一切内容皆资源，无论是静态文件还是动态生成的代码等。</p><h3 id="什么是媒体类型"><a href="#什么是媒体类型" class="headerlink" title="什么是媒体类型?"></a>什么是媒体类型?</h3><p>最初设计MIME（Multipurpose Internet Mail Extension，多用途英特网邮件扩展）是为了解决在不同的电子邮件系统之间搬迁报文时存在的问题。MIME在电子邮件系统中工作得非常好，因此HTTP也采纳了它，用它来描述并标记多媒体内容。</p><p>其实多媒体类型就是一种数据类型的标记，用来告诉接收端，接收到的数据是什么类型，让接收端知道怎么才能处理该文件。常见的标记方式就是MIME(见上解析)，MIME描述了文件的主要类型以及特定子类型，例如：<code>&quot;Content-Type&quot;:&quot;text/html&quot;</code>，其中<code>text</code>描述的文件主要类型是文本，而其特定类型是html文档！</p><h3 id="怎么理解URI以及它的子集（URL-URN）"><a href="#怎么理解URI以及它的子集（URL-URN）" class="headerlink" title="怎么理解URI以及它的子集（URL,URN）"></a>怎么理解URI以及它的子集（URL,URN）</h3><p>URI（Uniform Resource Identifier，统一资源标志符）的作用就是在网络上确定唯一资源，这就好比，在中国，身份证能唯一确定一个人一样。知道身份证号，就一定能确定一个人的信息。</p><p>URL（Uniform Resource Locator，统一资源定位符）是跟资源在网络上的位置有关，比如文章的banner图的位置为<code>http://omu538iq8.bkt.clouddn.com/network/http/http_banner.jpg</code>，广义上讲，我们说的URI就是指URL。</p><p>URN（Uniform Resource Name，统一资源名称）是作为特定内容的唯一名称使用的，与目前的资源所在地无关。URN是未来的趋势(试想一下人不可能是在一个地理位置不动吧，而ID_card的一定不会变的)，不过貌似具体实施还在商讨中。</p><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务就是<strong>一次http连接（不包括tcp/ip连接，只包括一次http报文发送与接收）</strong>的整个过程，由请求命令和响应结果组成。中间数据格式是http报文。本文的banner图示就是一次http的事务。我们平常打开一个网站，里面包括很多事务，比如：请求网页文档、请求某张图片以及请求某个视频/音频。</p><h3 id="方法指什么？"><a href="#方法指什么？" class="headerlink" title="方法指什么？"></a>方法指什么？</h3><p>HTTP方法会告诉服务器要执行什么动作（获取一个web页面、运行一个网关程序、删除一个文件等）。这些方法包括<code>GET , PUT , DELETE , POST , HEAD</code> 。</p><h3 id="状态码有什么用？"><a href="#状态码有什么用？" class="headerlink" title="状态码有什么用？"></a>状态码有什么用？</h3><p>状态码是一个三位数字的代码，告知客服端请求是否成功，或者是否需要采取其他动作。状态码带着一个原因短语，方便人解读，比如<code>304 Not Modified ，当发送GET请求资源返回上面的代码时候，可以解读成：客户端已经执行了GET，但文件没发生改变（和上次请求的资源一模一样）</code>。</p><h3 id="简单介绍一些报文"><a href="#简单介绍一些报文" class="headerlink" title="简单介绍一些报文"></a>简单介绍一些报文</h3><p>首先报文是<strong>http协议一种纯文本的数据格式</strong>，分为请求报文和响应报文，两种报文都具有类似的结构，分别由三部分构成：<code>起始行、首部、主体</code>。起始行描述了报文干了什么；首部描述报文传输的具体细节；主体描述传输的实际内容。</p><h3 id="什么是TCP-IP-更HTTP有什么关系？"><a href="#什么是TCP-IP-更HTTP有什么关系？" class="headerlink" title="什么是TCP/IP?更HTTP有什么关系？"></a>什么是TCP/IP?更HTTP有什么关系？</h3><p>TCP/IP是全世界的计算机和网络设备常用的层次化交换网络协议集。简单说，HTTP协议是一个应用层协议，位于TCP/IP协议的上一层，TCP/IP协议的主要作用就是过滤掉每个计算机的差异性，隐藏相关弱点，使得对于HTTP协议来说提供的都是”相同的”接口。</p><h3 id="在一次网络请求中，经历了哪些过程？"><a href="#在一次网络请求中，经历了哪些过程？" class="headerlink" title="在一次网络请求中，经历了哪些过程？"></a>在一次网络请求中，经历了哪些过程？</h3><p>(a).浏览器从RUL中通过解析出服务器的主机名</p><p>(b).浏览器将服务器的主机名转换成服务器的IP地址</p><p>(c).浏览器将端口号(如果有的话，默认是80)从URL中解析出来</p><p>(d).浏览器建立一条与web服务器的TCP连接</p><p>(e).浏览器向服务器发送一条HTTP请求报文</p><p>(f).服务器向浏览器回送一条HTTP响应报文</p><p>(g).关闭连接，浏览器显示文档</p><h3 id="HTTP协议有哪些版本？"><a href="#HTTP协议有哪些版本？" class="headerlink" title="HTTP协议有哪些版本？"></a>HTTP协议有哪些版本？</h3><p><strong>HTTP/0.9：</strong>这个协议有很多严重的设计缺陷；</p><p><strong>HTTP/1.0：</strong>使用广泛；</p><p><strong>HTTP/1.0+：</strong>是非官方的<code>HTTP/1.0</code>的扩展版本；</p><p><strong>HTTP/1.1：</strong>是目前正在广泛使用的版本，修复相关的设计缺陷，增加相关特性；</p><p><strong>HTTP-NG（又名HTTP/2.0）：</strong>将来使用与否正在商讨中</p><h3 id="Web的一些结构组件"><a href="#Web的一些结构组件" class="headerlink" title="Web的一些结构组件"></a>Web的一些结构组件</h3><p>上面有介绍了两个应用程序（Web浏览器和Web服务器）是如何互相发送报文来实现基本事务处理的。下面将列其他一些比较重要的应用程序，如下：</p><p><strong>代理：</strong>位于客户端和服务器之间的HTTP中间实体。具体来说就是代理位于客户端和服务器之间，接收所有客户端的HTTP请求，并把这些请求转发给服务器（可能会对请求进行修改之后转发）。对于用户来说，这些应用程序就是一个代理，代表用户访问服务器。代理的主要作用有过滤、屏蔽等，比如，在企业中对下载的应用程序进行病毒检测，<br>或者对小学生屏蔽一些成人才能看的内容。（注意⚠️ 代理即可以代表服务器对客户端进行响应，又可以代表客户端对服务器进行请求）</p><p><strong>缓存(cache)：</strong>HTTP的仓库，使常用页面的副本可以保存在离客户端更近的地方。首先说明一下：缓存某种意义上来说是一种代理服务器。它主要使用代表服务器对客户端进行响应。发送于预先缓存好的资源的副本（浏览器上就有缓存哈）。这样会加快事务响应速度、同时也会减少服务器的负载、减轻带宽等问题。</p><p><strong>网关(gateway)：</strong>是连接其他应用程序的特殊的web服务器。网关是一种特殊的服务器，面对客户端时好像它就是服务器，而对于服务器，它又充当客户端的角色，它的主要作用就是协议转换。例如下面的HTTP/FTP网关。</p><p><img src="http://omu538iq8.bkt.clouddn.com/network/http/gateway.png" alt="network/http/gateway"></p><p><strong>隧道(tunnel)：</strong>对HTTP通信报文进行盲转发的特殊代理。HTTP隧道通常用来在一条或多条HTTP数据，转发时不会窥探数据。</p><p><strong>Agent代理：</strong>发起自动HTTP请求的半只能Web客户端。说白了就是我们平时所说的浏览器，以及web机器人、爬虫等。</p><h2 id="URL和资源"><a href="#URL和资源" class="headerlink" title="URL和资源"></a>URL和资源</h2><p>上面提到过，URN还没成熟，说的URI可以等同说URL，即<code>URI == URL , URI !== URL</code>。</p><h3 id="URL的语法"><a href="#URL的语法" class="headerlink" title="URL的语法"></a>URL的语法</h3><p>下面是URL的组成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;<span class="comment">#&lt;frag&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># scheme:方法描述了请求资源时用了什么协议，用“:”与url其它部分隔开；</span></span><br><span class="line"><span class="comment"># user:用户名描述了访问是带的用户名</span></span><br><span class="line"><span class="comment"># password:密码描述了用户名后面可能跟的密码，用“:”跟用户名隔开；</span></span><br><span class="line"><span class="comment"># host:主机描述了网站主机名或ip地址，如果前面有用户名和密码，用@分开；</span></span><br><span class="line"><span class="comment"># post:服务器当前正在监听的端口，http默认为80，https默认为443;</span></span><br><span class="line"><span class="comment"># path:路劲描述了资源在服务器上的位置，用‘/’跟前面部分隔开；</span></span><br><span class="line"><span class="comment"># params:参数描述了请求需要附加的参数，用“;”与其他部分隔开；</span></span><br><span class="line"><span class="comment"># query:查询是用来激活服务器程序去执行某些操作，比如查询数据库等，用“?”与其余部分隔开；</span></span><br><span class="line"><span class="comment"># frag/fragments:片段只在客户端使用，不发送到服务器端；</span></span><br></pre></td></tr></table></figure><h3 id="URL快捷方式"><a href="#URL快捷方式" class="headerlink" title="URL快捷方式"></a>URL快捷方式</h3><p>URL快捷方式描述了一个程序如何通过相对地址解析处绝对地址的过程以及在浏览器地址栏输入部分URL浏览器自动补全主机名的一种机制。</p><p>相对地址转换为绝对地址：首先会根据一个基础地址来得到出协议、主机名、端口等。</p><p>浏览器扩展地址主要通过主机名扩展和历史扩展等方式实现自动地址补全。</p><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><p><strong>为什么需要编码？</strong></p><p>主要从URL的一致性、安全性、以及完整性来强调需要对URL字符进行编码。比如因为一个URL连接的两端可能出现的机器种类很多，为了让大家能够解析出一个相同的url，所以有必要对某些不安全的URL字符进行转义。</p><p><strong>URL字符集由什么编码构成？</strong></p><p>早起的URL是由US-ASCII码编码，但是随着网络全世界的流行，有很多字符是US-ASCII不能编码的，因为US-ASCII码最多只能编译127个字符。通过转义序列，就可以用US-ASCII字符集的有限子集字符值或数据进行编码了。</p><p><strong>编码机制？</strong></p><p>为了避开安全字符集表示法带来的限制，人们设计了一种编码机制，用来在URL中表示各种不安全的字符。这种编码机制就是通过一种“转义”表示法来表示不安全字符的，这种转义表示法包含一个百分号（%），后面跟着两个表示字符的ASCII码的十六进制数。</p><p><strong>哪些字符不建议在URL里面使用？</strong></p><p>在URL中，有几个字符被保留起来，有着特殊的含义。有些字符不在定义的US-ASCII可打印字符集中。还有些字符会与某些因特网网关和协议产生混淆，因此不赞成使用，比如“%”。</p><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>如果说HTTP是因特网的信使，那么<code>HTTP 报文</code>就是它用来搬东西的包裹了。我们将了解：</p><ol><li>报文是如何流动的</li><li>HTTP报文的三个组成部分（起始行、首部和实体的主体部分）</li><li>请求和响应报文直接的区别</li><li>请求报文支持的各种功能（方法）</li><li>和响应报文一起返回的各种状态码</li><li>各种各样的HTTP首部都是用来干什么的</li></ol><h3 id="报文流"><a href="#报文流" class="headerlink" title="报文流"></a>报文流</h3><p>HTTP报文是以一种类似的流方式来发送数据的，所以报文流讲述了HTTP报文的一些客观状态，相关的术语：流入、流出形容事物的处理。HTTP报文任何时候是从上流流入，其中经过的节点既可能是上流，也有可能是下流，如果从某个节点流出，那么相对于此节点流入的那个节点就是上游，翻过它就是下游。</p><h3 id="报文的组成部分"><a href="#报文的组成部分" class="headerlink" title="报文的组成部分"></a>报文的组成部分</h3><p>报文是由三部分组成：<code>起始行、首部、主体</code>。起始行和首部都是ASCII文本，而主体可以是任意类型文件，比如二进制，视频等。且起始行和首部都以一个<code>crlf</code>作为结束符，并且首部与主体之间应始终存在一个以crlf序列作为结束的<code>空行</code>。当然了，为了兼容老版本的http，这里有时并不是那么严格要求非要crlf同时存在。</p><h3 id="请求报文和响应报文直接的区别"><a href="#请求报文和响应报文直接的区别" class="headerlink" title="请求报文和响应报文直接的区别"></a>请求报文和响应报文直接的区别</h3><p>两者的报文语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求报文 </span></span><br><span class="line">&lt;method&gt;&lt;request-URL&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 响应报文</span></span><br><span class="line">&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure><p>上面的请求报文和响应报文的字段解析如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method是客户端希望执行的动作，如GET、POST等</span></span><br><span class="line"><span class="comment"># request-URL是指请求资源的路径</span></span><br><span class="line"><span class="comment"># version报文版本号，格式为http/&lt;major&gt;.&lt;minor&gt;，分别代表主要版本和次要版本号，其含义应分开理解</span></span><br><span class="line"><span class="comment"># status就是用一个三位的数字表示当前事务处于什么状态，便于开发者处理</span></span><br><span class="line"><span class="comment"># reason-phrase原因短语，方便查看状态码的意思</span></span><br><span class="line"><span class="comment"># headers首部是一个包含零个或多个的键值对，键值对以crlt隔开，而键，值之间以":"隔开，期间包含一个可选的空格</span></span><br><span class="line"><span class="comment"># 任意格式组成的数据块，也是实际发送的内容</span></span><br></pre></td></tr></table></figure><h3 id="请求报文支持的方法"><a href="#请求报文支持的方法" class="headerlink" title="请求报文支持的方法"></a>请求报文支持的方法</h3><p><strong>安全方法</strong></p><p>能在服务器端操作的就是非安全方法，比如DELETE、PUT、POST，不在服务器端游操作的就是安全方法，比如GET、HEADER。当然了，安全方法并非不能在服务器端有操作，这是开发者可以控制的。</p><p><strong>GET</strong></p><p>用来请求服务器端发送某个资源。</p><p><strong>HEADER</strong></p><p>此方法跟GET方法类似，区别就是不返回主体。HEAD请求的回应部分的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标志的资源的信息。常用于测试超链接的有效性，是否可以访问，以及最近是否更新。</p><p><strong>PUT</strong></p><p>用于向服务器端修改、插入数据。</p><p><strong>POST</strong></p><p>用于向服务器端发送数据。常用于表单的提交，用于登录注册页面。</p><p><strong>TRACK</strong></p><p>用于向服务器端请求报文在发送过程中经过了什么修改，主要是用来测试。</p><p><strong>OPTIONS</strong></p><p>用来请求服务器告知其支持什么功能。</p><p><strong>DELETE</strong></p><p>用于向服务器删除某个指定的资源。</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><table><thead><tr><th>#</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><p><strong>常见的状态码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br><span class="line"><span class="comment"># 表示从客户端发过来的请求在服务器端被正常处理了</span></span><br><span class="line"></span><br><span class="line">204 No Content</span><br><span class="line"><span class="comment"># 表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分</span></span><br><span class="line"></span><br><span class="line">206 Partial Content</span><br><span class="line"><span class="comment"># 表示客户端进行了范围请求</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">301 Moved Permanently</span><br><span class="line"><span class="comment"># 永久性重定向。该状态码表示请求的资源已经被删除，重新分配了新的URI，以后应使用资源现在所指的URI</span></span><br><span class="line"></span><br><span class="line">302 Found</span><br><span class="line"><span class="comment"># 临时性重定向。该状态码表示请求分配的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。和301状态相似，但是302代表的资源不是被永久转移，只是临时性质的。</span></span><br><span class="line"></span><br><span class="line">303 See Other</span><br><span class="line"><span class="comment"># 该状态码表示由于请求对应的资源存在着另一个URI，应该使用GET方法定向获取请求的资源。</span></span><br><span class="line"></span><br><span class="line">304 Not Modified</span><br><span class="line"><span class="comment"># ⚠️ 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304虽然被划分到3XX类别里面，但是和重定向没有关系。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">400 Bad Request</span><br><span class="line"><span class="comment"># 表示请求报文中存在语法错误。</span></span><br><span class="line"></span><br><span class="line">401 Unauthorized</span><br><span class="line"><span class="comment"># 表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。</span></span><br><span class="line"></span><br><span class="line">403 Forbidden</span><br><span class="line"><span class="comment"># 表示对请求资源的访问被服务器拒绝了。</span></span><br><span class="line"></span><br><span class="line">404 Not Found</span><br><span class="line"><span class="comment"># 表示服务器上无法找到请求的资源。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">500 Internal Server Error</span><br><span class="line"><span class="comment"># 表明服务器端执行请求时发生了错误</span></span><br><span class="line"></span><br><span class="line">503 Server Unavailable</span><br><span class="line"><span class="comment"># 表明服务器暂时处于负载或者正在进行停机维护，无法处理请求。</span></span><br></pre></td></tr></table></figure><p>更多的状态码请自行百度。</p><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><p>首部和方法配合工作，共同决定了客户端和服务器能够做什么事情。首部分为通用首部、请求首部、响应首部、主体首部、扩展首部！具体的信息请查看《HTTP权威指南》。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>web缓存是可以自动保存常见文档副本的http设备。当web请求抵达缓存时，如果本地有<code>已缓存的副本</code>，就可以从本地存储设备而不是原始服务器中提取这个文档。使用缓存的优点有：</p><ol><li>缓存减少了冗余的数据传输，节省了你的网络费用。</li><li>缓存缓解了网络的瓶颈问题。不需要更多的带宽就能更快的加载页面。</li><li>缓解降低了对原始服务器的要求。服务器可以更加快地响应，避免过载的出现。</li><li>缓存降低了距离时延，因为从较远的地方加载页面会更慢些。</li></ol><h3 id="冗余的数据传输"><a href="#冗余的数据传输" class="headerlink" title="冗余的数据传输"></a>冗余的数据传输</h3><p>每次从服务器上拿数据（客户端频繁访问同一个页面），那么带来的后果就是：服务端多次发送重复的数据浪费流量、耗费昂贵的网络带宽从而减低传输速率、加大服务器的负载。而有了缓存之后，这些问题可以迎刃而解。</p><h3 id="带宽瓶颈"><a href="#带宽瓶颈" class="headerlink" title="带宽瓶颈"></a>带宽瓶颈</h3><p>很多本地的网络客户端提供的带宽比远程服务器提供的带宽要宽。客户端会以路径上最慢的网速访问服务器，这样本地的带宽优势就没有体现出来。如果在客户端方向配置一个高速缓存服务器，那么就可以很快得到响应，由此也可以看出带宽对报文传输速率的影响。</p><h3 id="瞬间拥塞"><a href="#瞬间拥塞" class="headerlink" title="瞬间拥塞"></a>瞬间拥塞</h3><p>瞬间拥塞描述的是一种情况：一个爆炸性的新闻和热点事件，如果没有配置缓存的情况下，那么在短时间内，服务器会收到突变的请求增长，负荷会爆炸性增长，肯定会吃不消。但是又了缓存，可以大大分担服务器的负载数量。</p><h3 id="距离时延"><a href="#距离时延" class="headerlink" title="距离时延"></a>距离时延</h3><p>距离时延说明的一个问题就是传输数据过程这个过程需要的时间，而且路程越长，那么需要的时间也会越多，即时延越长。所以在距离客户端较近的地方部署缓存服务器，减少了传输路程，那么就减少了传输时延。平时使用的cdn就是这个原理啦。</p><h3 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h3><ul><li><p><strong>缓存命中与缓存未命中：</strong>一次http事务请求如果是从得到的响应是从缓存得到的原始副本，那么这样的过程就称之为缓存命中。如果缓存没有响应的副本，而要去请求原始服务，那么久把这个过程称之为缓存未命中。</p></li><li><p><strong>http再验证：</strong>原始响应内容是在变化的，所以缓存应该在文档<code>过期时间</code>之后去验证缓存的副本是不是新鲜的，这个过程就叫做http再验证。如果再验证之后得知副本是新鲜的，那么原始服务器就会返回<code>304 not modified</code>。此时，称之为再验证命中或者缓存慢命中。如果得知缓存不是新鲜的，那么服务器返回<code>200 ok</code>。此时，称之为再验证未命中。如果原始对象被删除，返回<code>404 not found</code>响应。响应的缓存副本要删除。</p></li><li><p><strong>命中率：</strong>指由缓存返回副本事务在全部事务中所占的比例，称之为缓存命中率。这个数据实际意义不是很大，而字节命中率从资源大小总量的角度说明缓存命中所占的比例。因为它从数据流量的角度出发，所以实际中这个数据的意义挺大的。</p></li><li><p><strong>区分命中和未命中：</strong>简单来说，http没有相应的机制来告知客户端响应是从缓存得到的还是从原始服务器得到的。但是我们可以从http响应报文首部中的date字段得知这一情况：如果这个字段的时间比当前时间更早得多，说明这是从缓存得到的，因为date描述的服务器第一次响应的时间，而缓存是不会对这个字段进行修改的。</p></li></ul><h3 id="缓存的拓扑结构"><a href="#缓存的拓扑结构" class="headerlink" title="缓存的拓扑结构"></a>缓存的拓扑结构</h3><ul><li><p><strong>分类：</strong>缓存分为私有缓存（只为一个客户端服务，比如我们给浏览器配置的代理）和共有缓存（为多个客户端服务，现实中是以代理缓存服务器的形式出现）</p></li><li><p><strong>代理缓存的层级结构：</strong>此种结构描述的以父、子层级出现的层级结构，同时离客户端越近的子缓存命中率较低（较廉价），可以把请求上升到父缓存（较昂贵），从而在父缓存那里实现事务处理。</p></li><li><p><strong>代理缓存的网状结构：</strong>它描述的缓存结构并不是很明显呈现父子关系的结构，而是呈现无规则的网状。这种结构的思想就是子缓存可以动态选择上一级缓存，从而实现更灵活的缓存控制。</p></li></ul><h3 id="缓存的处理步骤"><a href="#缓存的处理步骤" class="headerlink" title="缓存的处理步骤"></a>缓存的处理步骤</h3><ol><li><strong>接收</strong>————缓存从网络中读取抵达的请求报文。</li><li><strong>解析</strong>————缓存对报文进行解析，提取出url和各种首部。</li><li><strong>查询</strong>————缓存查看是否有本地副本可用，如果没有，就去获取一份副本（根据情形和配置，到原始服务器或父代理中去取，将副本存在本地，或者获取不到返回错误信息）</li><li><strong>新鲜度检测</strong>————缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。</li><li><strong>创建响应</strong>————缓存会用新的首部和已缓存的主体来构建一条响应报文。</li><li><strong>发送</strong>————缓存通过网络将响应发送给客户端。</li><li><strong>日志</strong>————缓存可选地创建一个日志文件条目来描述这个事务。</li></ol><h3 id="保存副本的新鲜度"><a href="#保存副本的新鲜度" class="headerlink" title="保存副本的新鲜度"></a>保存副本的新鲜度</h3><ul><li>文档过期通过特殊的http首部cache-control和expires，http让原始服务器为每个文档设置一个“过期时间”，如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: Max-Age = 484200  // 除了Max-Age , 还可以有其他的字段啦</span><br><span class="line">Expire: Fri, 28 Oct 2016 12:00:00 GMT</span><br><span class="line"></span><br><span class="line">// Max-Age 是相对时间，以秒为单位，理解为使用期  推荐使用</span><br><span class="line">// Expires 为绝对时间，理解为到期时间  不推荐使用--由于很多服务器的时钟都不同步，或者不正确，所以最好使用剩余秒数（相对时间）来表示过期时间</span><br></pre></td></tr></table></figure><ul><li><p><strong>服务器再验证：</strong>仅仅是已缓存文档过期了并不意味着它和原始服务器目前处于活跃状态的文档有诗集的区别；这知识意味着到了要进行核对的时间了。这种情况被称为<code>服务器再验证</code>，说明缓存需要询问服务器是否发生了变化。</p></li><li><p><strong>用条件再验证：</strong>涉及到的两个首部为<code>If-Modified-Since</code>和<code>If-None-Match</code>。如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: &lt;data&gt;</span><br><span class="line">If-None-Match: &lt;verson&gt;</span><br><span class="line"></span><br><span class="line">// date为服务器响应报文里面Last-Modified时间</span><br><span class="line">// version是实体标签ETag。其机制跟If-Modified-Since不同在于：后者是根据修改时间来判断文档的新鲜度，但是有些情况下是不适合的，比如我们只是加了注释什么的，其中实际内容并没有什么变化。</span><br></pre></td></tr></table></figure><h3 id="缓存的控制能力"><a href="#缓存的控制能力" class="headerlink" title="缓存的控制能力"></a>缓存的控制能力</h3><p>缓存控制能力描述的是服务器可以通过设置相关的首部来控制文档的缓存过期时间的能力。相关首部解析如下：</p><table><thead><tr><th>指令</th><th>目的</th></tr></thead><tbody><tr><td>Cache-Control:no-store</td><td>不能缓存/尽快从存储器中删除文档的所有痕迹，因为里面可能有敏感信息</td></tr><tr><td>Cache-Control:no-cache</td><td>除非资源进行了再验证，否则这个客户端不会接受已缓存的资源</td></tr><tr><td>Cache-Control:must-revalidate</td><td>严格遵守新鲜验证规则</td></tr><tr><td>Cache-Control:max-age</td><td>设置多长时间过期（相对时间）</td></tr><tr><td>Expires: <date></date></td><td>设置多长时间过期（绝对时间）不建议使用</td></tr><tr><td>试探性过期</td><td>不设置首部，让缓存来决定，这个方式涉及到一种算法，比如缓存服务器通过查看最后修改时间，从而得到该文档的修改频繁度，从而为其设置缓存过期时间</td></tr></tbody></table><p>上面的优先级从上到下依次降低。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《HTTP权威指南》</p><p>《图解HTTP》</p><p style="color:red;text-align: center;">精力有限，未能一次性更新完，还望体谅…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/network/http/http_banner.jpg&quot; alt=&quot;network/http/http_banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;了解http是前端工程师必备的一个技能哈，虽然现在自己不是很了解，但是根据查阅的资料，自己谈下自己的总结啦！路漫漫兮其修远…&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://reng99.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http" scheme="http://reng99.cc/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>前端优化：雅虎35条原则</title>
    <link href="http://reng99.cc/2018/03/06/frontend-optimization/"/>
    <id>http://reng99.cc/2018/03/06/frontend-optimization/</id>
    <published>2018-03-06T08:28:09.000Z</published>
    <updated>2018-03-23T02:40:47.445Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/optimization/fontend-optimization-banner.jpg" alt="frontend/optimization/fontend-optimization-banner"></p><p>整理前端优化的方案，主要是雅虎的35条原则。欢迎补充哈 😊 </p><a id="more"></a><h2 id="内容-尽量减少HTTP请求数"><a href="#内容-尽量减少HTTP请求数" class="headerlink" title="[内容]尽量减少HTTP请求数"></a>[内容]尽量减少HTTP请求数</h2><p>80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本，Flash等等。减少组件数必然能减少页面提交的HTTP请求书。这是让页面更快的关键。</p><p><strong>合并文件</strong>是通过把所有脚本(javascript)放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。</p><p><strong>CSS Sprites(精灵图)</strong>是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的<code>background-image</code>和<code>background-position</code>属性来定位要显示的部分。也可以只用<code>position</code>就行了。</p><p><strong>图像映射</strong>可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在页面中连续的时候才有用，比如导航条。给<code>image map</code>设置坐标的过程既无聊又容易出错，用<code>image map</code>来做导航也不容易，所以不推荐用这种方式。</p><p><strong>行内图片(Base64编码)</strong>用<code>data:</code>URL模式来把图片嵌入图片。这样会增加HTML文件的大小，把行内图片放在(缓存的)样式表中是个好办法，而且成功避免了页面变重。但目前主流浏览器并不能很好地支持行内图片。</p><h2 id="服务器-使用CDN-Content-Delivery-Network"><a href="#服务器-使用CDN-Content-Delivery-Network" class="headerlink" title="[服务器]使用CDN(Content Delivery Network)"></a>[服务器]使用CDN(Content Delivery Network)</h2><p>用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。当具体要怎么做呢？</p><p>实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务。缩短用户和内容之间的距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。</p><p>记住终端用户80%到90%的响应时间都花在下载组件上了：图片，样式，脚本，Flash等等，这是<code>业绩黄金法则</code>。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。</p><p><strong>内容分发网络(CDN)</strong>是一组分散在不同地理位置的web服务器，用来给用户更高效地分发内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数(hop)最少的或者响应时间最快的服务器。</p><h2 id="服务器-添上Expires或者Cache-Control-HTTP头"><a href="#服务器-添上Expires或者Cache-Control-HTTP头" class="headerlink" title="[服务器]添上Expires或者Cache-Control HTTP头"></a>[服务器]添上Expires或者Cache-Control HTTP头</h2><p>这条规则有两个方面： </p><ul><li><p>对于静态组件：通过设置一个遥远的将来时间作为<code>Expires</code>来实现用不失效</p></li><li><p>多余动态组件：用适合的<code>Cache-Control</code>HTTP头来让浏览器进行条件性的请求</p></li></ul><p>网页设计越来越丰富，这意味着页面里有更多的脚本，图片Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这就避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但是它们应该用在<code>所有</code>组件上，包括脚本、样式和Flash组件。</p><p>浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2020年03月06日前不会改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Fri, <span class="number">06</span> Mar <span class="number">2020</span> <span class="number">21</span>:<span class="number">00</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure><p>用一个遥远的未来时间做有效期HTTP头，只有在用户已经访问过站点之后才会影响页面视图。如果是新访客或者浏览器的缓存被清空时，对HTTP请求的数量并没有影响。因此这种性能提升取决于已缓存各个组件的用户访问站点的频率。我们<a href="https://yuiblog.com/blog/2007/01/04/performance-research-part-2/" target="_blank" rel="noopener">在Yahoo!测量了这个数据</a>，发现已缓存各个组件的页面访问量（PV）占75%到85%。通过把一个遥远的未来时间作为有效期HTTP头，增加了被浏览器缓存的组件数量，在后续页面的访问中不需要用Internet连接多发哪怕一个字节。</p><h2 id="服务器-Gzip组件"><a href="#服务器-Gzip组件" class="headerlink" title="[服务器]Gzip组件"></a>[服务器]Gzip组件</h2><p>前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽，网络服务商，对等交换点的距离问题等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。</p><p>从HTTP/1.1开始，web客户端就有了支持压缩<code>Accept-Encoding HTTP</code>请求头。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip,deflate</span><br></pre></td></tr></table></figure><p>如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过<code>Content-Encoding: gzip</code>响应头来通知客户端。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure><p>Gzip是目前最常见的高效压缩方法，由GNU项目开发并被<a href="http://www.ietf.org/rfc/rfc1952.txt" target="_blank" rel="noopener">RFC 1952</a>标准化。唯一一个你可能会看到的其它压缩格式是deflate，但它效率不高而且并不常见。</p><p>Gzipping一般能够把响应压缩到70%左右，目前大约90%的通过浏览器的网络传输都支持gzip。如果是Apache服务器，配置gzip的模块取决于版本Apache 1.3用<a href="https://sourceforge.net/projects/mod-gzip/" target="_blank" rel="noopener">mod_gzip</a>而Apache 2.x是<a href="http://httpd.apache.org/docs/2.0/mod/mod_deflate.html" target="_blank" rel="noopener">mod_deflate</a>模块。</p><p>浏览器和代理的某些因素可能会引起浏览器所期望的和它收到的压缩内容不匹配。幸运的是，随着老旧浏览器的淘汰，这些极少遇到的情况正在逐渐减少，而且Apache模块可以通过自动添加合适的Vary响应头来帮你搞定。</p><p>服务器会根据文件类型来决定要不要用gzip压缩，但这非常有限。大多数网站都有gzip压缩HTML文件，其实压缩脚本，样式表也是不错的选择，但是很多网站却错失了这个机会。其实，可以压缩任何文本内容，包括XML和JSON，而图片和PDF不用压缩，因为它们已经被压缩过了，再用gzip压缩不仅浪费CPU，还可能会越压越大。</p><p>尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。</p><h2 id="CSS-把样式表放在顶部"><a href="#CSS-把样式表放在顶部" class="headerlink" title="[CSS]把样式表放在顶部"></a>[CSS]把样式表放在顶部</h2><p>在Yahoo!研究性能的时候，我们发现把样式表放在文档的HEAD部分能让页面<code>看起来</code>加载得更快。这是因为把样式表放在head里能让页面逐步渲染。</p><p>关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显示得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被记录下来了。在我们的例子中，HTML页面就是进度条！当浏览器逐渐加载页面头部，导航条，顶部logo等等的内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整个用户体验。</p><p>在很多浏览器（包括IE）中，把样式表放在HTML文档底部会阻止页面逐渐渲染。这些浏览器阻塞渲染过程，以避免因为样式变动而重绘页面元素，用户这时就只能盯着空白页面。</p><p><a href="https://www.w3.org/TR/html4/struct/links.html#h-12.3" target="_blank" rel="noopener">HTML官方文档</a>清楚的描述了样式表应该放在页面的HEAD里面：<code>Unlike A,[LINK] may only appear in the HEAD section of a document, although it may appear any number of times.</code>（不像a标签,link标签可能只出现在head部分，虽然它可以出现多次）。空白屏幕或者没有样式的falsh内容都是不可取的。理想的方案就是遵循<a href="https://www.w3.org/TR/html4/struct/links.html#h-12.3" target="_blank" rel="noopener">HTML官方文档</a>，把样式表放在HTML文档的HEAD部分。</p><h2 id="javascript-把脚本放在底部"><a href="#javascript-把脚本放在底部" class="headerlink" title="[javascript]把脚本放在底部"></a>[javascript]把脚本放在底部</h2><p>脚本会阻塞并行下载，<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4" target="_blank" rel="noopener">HTTP/1.1官方文档</a>建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。<code>如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同的名下的。</code></p><p>有时候，并不容易吧脚本移动到底部。举个例子，如果脚本是用<code>document.write</code>插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在大多数情况下，这些问题都是可以解决的。</p><p>一个常见的建议是用推迟(deferred)脚本，有<code>DEFER</code>属性的脚本意味着不能含有document.write，并提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持<code>DEFER</code>属性。在IE中，脚本可能被推迟，但不尽人意。如果脚本可以推迟，我们就可以把它放在页面底部，页面就可以更快地载入。</p><h2 id="CSS-避免使用CSS表达式"><a href="#CSS-避免使用CSS表达式" class="headerlink" title="[CSS]避免使用CSS表达式"></a>[CSS]避免使用CSS表达式</h2><p>用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4" target="_blank" rel="noopener">从IE8起就不推荐使用了</a>。例如，可以用CSS表达式吧背景颜色设置成按小时交替的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">expression</span>((<span class="selector-tag">new</span> <span class="selector-tag">Date</span>())<span class="selector-class">.getHours</span>()%2 ? "<span class="selector-id">#f00</span>" : "<span class="selector-id">#fff</span>");</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>expression</code>方法可以接受一个javascript表达式。css属性会被设置成表达式的计算结果。<code>expression</code>方法会被其他浏览器忽略，所以只有想办法实现垮浏览器的与IE一致的用户体验才有用。</p><p>表达式最大的问题是<code>它们经常被重复计算，比我们想象的次数还要多。</code>不仅仅是页面渲染和调整大小的时候，在页面被滚动，甚至用户在页面上移动鼠标时都被重新计算表达式。给css表达式添加一个计算器就可以追踪它重新计算的时间和频率，而在页面上动动鼠标就可以引发10000多次重新计算。</p><p>减少css表达式重新计算的一种方式就是用一次性表达式，即在表达式第一次计算后就把样式属性设置成一个明确的值，换掉表达式。如果必须要在页面的整个生命周期中动态设置样式属性，可以用事件处理器来代替css表达式。如果必须使用css表达式，要记得它们可能被重复计算千次，从而影响整个页面的性能。</p><h2 id="javascript-css-把javascript和css放到外面"><a href="#javascript-css-把javascript和css放到外面" class="headerlink" title="[javascript ,css]把javascript和css放到外面"></a>[javascript ,css]把javascript和css放到外面</h2><p>很多性能原则都是关于如何管理外部组件的，然而，在这些顾虑出现之前你应该问一个基础的问题：<code>应该把javascript和css放到外部文件中还是直接卸载页面里？</code></p><p>实际上，用外部文件可以让页面更快，因为javascript和css文件会被缓存在浏览器。HTML文档中的行内javascript和css在每次请求该html文档的时候都会重新下载。这样做是减少了所需的HTTP请求数，但是增加了html文档的大小。另一方面，如果javascript和css在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。</p><p>关键因素是，外部文件被缓存的频率和页面被请求数量之间的关系。尽管这个因素很难量化，但我们还是可以用各种各样的指标来衡量的。如果用户的每个会话中都有多次页面访问，那么相同的脚本和样式表就可以被多个页面复用，缓存的外部文件就会带来巨大的好处。</p><p>很多站点在度量中都处于中等水平，对这些站点来说，一般最好的解决方案就是把javascript和css部署为外部文件。唯一的例外是主页上汗哪方式的优先。在每个会话中访问量比较少的主页会发现行内javascript和css能让终端用户的响应时间更快。</p><p>对典型的站点来说，首页是众多访问量的开始，有很多技术可以对减少HTTP请求起到杠杆作用，就像用外部文件缓存的好处一样。这样的一种技术就是在首页使用行内javascript和css，但是在页面载入完成之后动态加载外部文件，这样后续的页面所需的外部文件就已经被放在浏览器的缓存里面了。</p><h2 id="内容-减少DNS查找"><a href="#内容-减少DNS查找" class="headerlink" title="[内容]减少DNS查找"></a>[内容]减少DNS查找</h2><p>域名系统建立了主机名和IP地址间的映射，就像电话薄上人名和号码的映射一样。当你在浏览器输入www.yahoo.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完之前，浏览器无法从主机名下载任何东西。</p><p>DNS查找被缓存起来更加有效，由用户的ISP(网络提供商)或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己cache。只要浏览器在自己的cache里还保存着这条记录，它就不会向操作系统查询DNS。</p><p>IE默认缓存DNS查找30分钟，写在<code>DnsCacheTimeout</code>注册表设置中。Firefox缓存1分钟，可以用<code>network.dnsCacheExpiration</code>配置项设置。（Fasterfox把缓存时间改成了1小时P.S.Fasterfox是FF的一个提速插件）</p><p>如果客户端的DNS cache是空的（包括浏览器和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。</p><p>减少不同主机名的数量同时也减少了页面能够并行下载的组件的数量，避免了DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散到2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。</p><h2 id="javascript-css-压缩javascript和css"><a href="#javascript-css-压缩javascript和css" class="headerlink" title="[javascript,css]压缩javascript和css"></a>[javascript,css]压缩javascript和css</h2><p>压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行符和tab）。在javascript中这样做能够提高响应性能，因为要下载的文件变小了。自己一般使用gulp来压缩。</p><h2 id="内容-避免重定向"><a href="#内容-避免重定向" class="headerlink" title="[内容]避免重定向"></a>[内容]避免重定向</h2><p>重定向用301和302状态码，下面是一个有301状态码的HTTP头：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">301</span> Moved Permanently</span><br><span class="line">Location: http:<span class="comment">//example.com/newuri</span></span><br><span class="line">Content-type: text/html</span><br></pre></td></tr></table></figure><p>浏览器会自动跳转到<code>Location</code>域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其额外的HTTP头，比如<code>Expires</code>和<code>Cache-Control</code>也表示重定向。除此之外还有别的跳转方式：refresh元素和javascript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。</p><p>牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。</p><p>有一种常见的极其浪费资源的重定向，而且WEB开发人员一般意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到<a href="http://reng99" target="_blank" rel="noopener">http://reng99</a>会返回一个重定向到<a href="http://reng99/" target="_blank" rel="noopener">http://reng99/</a>的301响应（注意添加在尾部的斜线）。在Apache中可以用Alias,mod_rewrite或者DirectorySlash指令来取消不必要的重定向。</p><p>重定向最常见的用途就是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户账号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用<code>Alias</code>和<code>mod_rewrite</code>，前提是两个代码路径都在相同的服务器上。如果因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合<code>Alias</code>或者<code>mod_rewrite</code>指令。</p><h2 id="javascript-去除重复脚本"><a href="#javascript-去除重复脚本" class="headerlink" title="[javascript]去除重复脚本"></a>[javascript]去除重复脚本</h2><p>页面含有重复脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：<code>团队大小和脚本数量</code>。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的javascript代码，而影响页面性能。</p><p>IE会产生不必要的HTTP请求，而Firefox不会。在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载的时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。</p><p>除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的javascript代码。</p><p>避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中使用SCRIPT标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"path/to/*.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="服务器-配置ETags"><a href="#服务器-配置ETags" class="headerlink" title="[服务器]配置ETags"></a>[服务器]配置ETags</h2><p>实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETag可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的<code>ETag</code>来指定组件的ETag:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Last-Modified; Tue,12 Dec 2006 03:03:58 GMT</span><br><span class="line">ETag: <span class="string">"17hkh23-3hn-42kj23jlj"</span></span><br><span class="line">Content-Length: 12195</span><br></pre></td></tr></table></figure><p>然后，如果浏览器必须验证一个组件，它用<code>If-None-Match</code>请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /i/yahoo.gif HTTP/1.1</span><br><span class="line">      Host: us.yimg.com</span><br><span class="line">      If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line">      If-None-Match: <span class="string">"10c24bc-4ab-457e1c1f"</span></span><br><span class="line">      HTTP/1.1 304 Not Modified</span><br></pre></td></tr></table></figure><p>ETags存在的问题是它们由特定服务器构造的，所以如果浏览器从一个服务器获取最初的组件，然后想验证另一个服务器上的相同组件，ETags是无法匹配成功的，而用一群服务器处理请求在web站点中又非常普遍。默认情况下，Apache和IIS会在ETag中嵌入谁，以大大降低在服务器站点上有效性测试成功的几率。</p><h2 id="内容-让Ajax可缓存"><a href="#内容-让Ajax可缓存" class="headerlink" title="[内容]让Ajax可缓存"></a>[内容]让Ajax可缓存</h2><p>Ajax的一个好处是可以给用户提供即时反馈，因为它能够从后台服务器异步请求信息。然而，用Ajax就无法保证用户在等待异步javascript和XML响应返回期间不会非常无聊。在很多应用程序中，用户能够一直等待取决于如何使用Ajax。例如，在基于web的电子邮件客户端中，用户为了寻找符合他们搜索标准的邮件信息，将会保持对Ajax请求返回结果的关注。重要的是，要记得”异步”并不意味着”即时”。</p><p>要提高性能，优化这些Ajax响应至关重要。最重要的提高Ajax性能就是让响应变得可缓存，就像添上Expires或者Cache-Control HTTP头讨论的一样。下面适用于Ajax的其他规则：</p><ul><li><p>Gzip组件</p></li><li><p>减少DNS查找</p></li><li><p>压缩javascript</p></li><li><p>避免重定向</p></li><li><p>配置ETags</p></li></ul><p>我们看下例子，一个web 2.0的电子邮价客户端用了Ajax来下载用户的通讯录，以便实现自动完成功能。如果用户从上一次使用之后再没有修改过她的通讯录，而且Ajax响应是可以缓存的，有尚未过期的Expires或者Cache-Control HTTP头，那么之前的通讯录就可以从缓存中读出。必须通知浏览器，应该继续使用之前之前缓存的通讯录响应，还是去请求一个新的。可以通过给通讯录的Ajax URL里添加一个表明用户通讯录最后修改时间的时间戳来实现，例如<code>&amp;t=1190241612</code>。如果通讯录从上一次下载之后再没有被修改过，时间戳不变，通讯录就将从浏览器缓存中直接读出，从而避免一次额外的HTTP往返消耗。如果用户已经修改了通讯录，时间戳也可以确保新的URL不会匹配缓存的响应，浏览器将请求新的通讯录条目。</p><p>即使Ajax响应是动态创建的，而且可能只适用于单用户，它们也可以被缓存，而这样会让你的WEB 2.0应用更快。</p><h2 id="服务器-尽早清空缓存区"><a href="#服务器-尽早清空缓存区" class="headerlink" title="[服务器]尽早清空缓存区"></a>[服务器]尽早清空缓存区</h2><p>当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个<code>flush()</code>函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很<code>轻</code>的前端页面上（PS也就是说，响应时耗主要在后台方面时最能体现优势）。</p><p>比较理想的清空缓存区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和javascript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。</p><p>例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  ... &lt;!-- css, js --&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> flush(); <span class="meta">?&gt;</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  ... &lt;!-- content --&gt;</span><br></pre></td></tr></table></figure><p><a href="https://search.yahoo.com/" target="_blank" rel="noopener">Yahoo!搜索</a>开创了这项技术，而且真实用户测试研究也证明了使用这种技术的诸多好处。</p><h2 id="服务器-对Ajax用GET请求"><a href="#服务器-对Ajax用GET请求" class="headerlink" title="[服务器]对Ajax用GET请求"></a>[服务器]对Ajax用GET请求</h2><p><a href="https://login.yahoo.com/?.src=ym&amp;.intl=us&amp;.done=https%3A%2F%2Fmail.yahoo.com%2F" target="_blank" rel="noopener">Yahoo!邮箱</a>团队发现使用<code>XMLHttpRequest</code>时，浏览器的POST请求是通过一个两步的过程来实现的： 先发送HTTP头，再发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。</p><p>POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="noopener">HTTP说明文档</a>中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。</p><h2 id="内容-延迟加载组件"><a href="#内容-延迟加载组件" class="headerlink" title="[内容]延迟加载组件"></a>[内容]延迟加载组件</h2><p>javascript是分隔onload事件之前和之后的一个理想选择。例如，如果javascript代码和支持拖放以及动画的库，这些都可以先等会儿，因为拖放元素是在页面最初渲染之后的。其它延迟加载的部分，包括隐藏内容（在某个交互动作之后才出现的内容）和折叠的图片。</p><p>工具可以帮你减轻工作量:<a href="https://developer.yahoo.com/yui/imageloader/" target="_blank" rel="noopener">YUI Image Loader</a>可以延迟加载折叠的图片，还有<a href="https://developer.yahoo.com/yui/get/" target="_blank" rel="noopener">YUI Get utility</a>是一种引入javascript和css的简单方法。<a href="https://www.yahoo.com/" target="_blank" rel="noopener">Yahoo!主页</a>就是一个例子，可以打开Firebug的网络面板仔细看看。</p><p>最好让性能目标符合其它WEB开发最佳实践，比如”渐进增强”。如果客户端支持javascript，可以提高用户体验，但必须确保页面在不支持javascript时也能正常工作。所以，在确定页面运行正常之后，可以用一些延迟加载脚本增强它，以支持一些拖放和动画之类的华丽效果。</p><h2 id="内容-预加载组件"><a href="#内容-预加载组件" class="headerlink" title="[内容]预加载组件"></a>[内容]预加载组件</h2><p>预加载可能看起来和延迟加载是相反的，但它实际有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得很快的。</p><p>时间应用中有以下几种预加载的类型：</p><ul><li><p>无条件预加载 ： 尽快开始加载，获取一些额外的组件。google.com就是一个sprite图片预加载的好例子，这个sprite图片并不是google.com主页需要的，而是搜索结果页面上的内容。</p></li><li><p>条件性预加载 ： 根据用户操作猜测用户跳转到哪里并据此预加载。</p></li><li><p>提前预加载 ： 在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但是比以前更慢了”，一部分原因是用户访问之前的页面都是旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。</p></li></ul><h2 id="内容-减少DOM元素的数量"><a href="#内容-减少DOM元素的数量" class="headerlink" title="[内容]减少DOM元素的数量"></a>[内容]减少DOM元素的数量</h2><p>一个复杂的页面意味着要下载更多的字节，而且用javascript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素是有区别的。</p><p>大量的DOM元素是一种征兆 ： 页面上有些内容无关的标记需要清理。正在用嵌套表格来布局吗？还是为了修复布局问题而添加了一堆的<code>&lt;div&gt;</code>？或许应该用更好的语义化标记。</p><p>DOM元素的数量很容易测试，只需要在Firebug的控制台输入:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>).length;</span><br></pre></td></tr></table></figure><p>那么多少DOM元素才算是太多呢？可以参考其他类似的标记良好的页面，例如<a href="https://www.yahoo.com/" target="_blank" rel="noopener">Yahoo!主页</a>是一个相当繁忙的页面，但只有不到700个元素(HTML标签)。</p><h2 id="内容-跨域分离组件"><a href="#内容-跨域分离组件" class="headerlink" title="[内容]跨域分离组件"></a>[内容]跨域分离组件</h2><p>分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在<code>www.example.org</code>，而把静态组件分离到<code>static1.example.org</code>和<code>static2.example.org</code>。</p><p>更多信息请查看Tenni Theurer和Patty Chi的文章：<a href="https://yuiblog.com/blog/2007/04/11/performance-research-part-4/" target="_blank" rel="noopener">Maximizing Parallel Downloads in the Carpool Lane</a></p><h2 id="内容-尽量少使用iframe"><a href="#内容-尽量少使用iframe" class="headerlink" title="[内容]尽量少使用iframe"></a>[内容]尽量少使用iframe</h2><p>用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。</p><p><code>&lt;iframe&gt;</code>的优点：</p><ul><li><p>引入缓慢的第三方内容，比如标志和广告</p></li><li><p>安全沙箱</p></li><li><p>并行下载脚本</p></li></ul><p><code>&lt;iframe&gt;</code>的缺点：</p><ul><li><p>代价昂贵，即使是空白的iframe</p></li><li><p>阻塞页面加载</p></li><li><p>非语义</p></li></ul><h2 id="内容-杜绝404"><a href="#内容-杜绝404" class="headerlink" title="[内容]杜绝404"></a>[内容]杜绝404</h2><p>HTTP请求代价昂贵，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。</p><p>有些站点用的是有帮助的404 ： “你的意思是xxx？”，这样做有利于用户体验，但是也浪费了服务器的资源（比如数据库等等）。最糟糕的是连接到的外部javascript有错误而且结果是404。首先，这种下载将阻塞并行下载。其次，浏览器会试图解析404响应体，因为它是javascript代码，需要找出其中可以用的部分。</p><h2 id="cookie-给Cookie减肥"><a href="#cookie-给Cookie减肥" class="headerlink" title="[cookie]给Cookie减肥"></a>[cookie]给Cookie减肥</h2><p>使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。</p><p>更多信息请查看Tenni Theurer和Patty Chi的文章：<a href="https://yuiblog.com/blog/2007/03/01/performance-research-part-3/" target="_blank" rel="noopener">When the Cookie Crumbles</a>。相关经验原则可以总结如下：</p><ul><li><p>清除不必要的cookie</p></li><li><p>保证cookie尽可能小，以最小化对用户响应时间的影响</p></li><li><p>注意给cookie设置合适的域级别，以免影响其他子域</p></li><li><p>设置适合的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间</p></li></ul><h2 id="把组件放在不含cookie的域下"><a href="#把组件放在不含cookie的域下" class="headerlink" title="[把组件放在不含cookie的域下]"></a>[把组件放在不含cookie的域下]</h2><p>当浏览器发送静态图像的请求时，cookies也会一起发送，而服务器根本就不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署到那儿。</p><p>如果域名是<code>www.example.org</code>，可以把静态组件部署到<code>static.example.org</code>。然而，如果已经在顶级域<code>example.org</code>或者<code>www.example.org</code>设置了cookie，那么所有对<code>static.example.org</code>的请求都会含这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是<code>yimg.com</code>,YouTube是<code>ytimg.com</code>，亚马逊是<code>images-amazon.com</code>等等。</p><p>把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是www.example.org作为主页，可以考虑下cookie的影响。省略www的话，就只能把cookie写到<code>*.example.org</code>，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。</p><h2 id="javascript-尽量减少DOM访问"><a href="#javascript-尽量减少DOM访问" class="headerlink" title="[javascript]尽量减少DOM访问"></a>[javascript]尽量减少DOM访问</h2><p>用javascript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该：</p><ul><li><p>缓存已访问过的元素的索引</p></li><li><p>先“离线”更新节点，再把它们添加到DOM树上</p></li><li><p>避免用javascript修复布局问题</p></li></ul><p>更多信息请查看YUI影院里Julien Lecomte的文章：<a href="https://yuiblog.com/blog/2007/12/20/video-lecomte/" target="_blank" rel="noopener">High Performance Ajax Applications</a></p><h2 id="javascript-用智能的事件处理器"><a href="#javascript-用智能的事件处理器" class="headerlink" title="[javascript]用智能的事件处理器"></a>[javascript]用智能的事件处理器</h2><p>有时候感觉页面反应不够灵敏，是因为有太多频繁执行的事件处理器被添加到DOM树的不同元素上，这就是推荐使用<code>事件委托</code>的原因。如果一个<code>div</code>里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。</p><p>不需要为了处理DOM树而等待onload事件，通常只有目标元素在DOM树中可以访问即可，而不必等待所有的图片下载完成。可以考虑用<code>DOMContentLoaded</code>来替代onload事件，但为了让它在所有浏览器中都可用，可以用<a href="https://developer.yahoo.com/yui/event/" target="_blank" rel="noopener">YUI Event</a>工具，它有一个<a href="https://developer.yahoo.com/yui/event/#onavailable=" target="_blank" rel="noopener">onAvailable</a>方法。</p><p>更多信息请查看YUI影院里Julien Lecomte的文章：<a href="https://yuiblog.com/blog/2007/12/20/video-lecomte/" target="_blank" rel="noopener">High Performance Ajax Applications</a></p><h2 id="CSS-选择舍弃-import"><a href="#CSS-选择舍弃-import" class="headerlink" title="[CSS]选择舍弃@import"></a>[CSS]选择<link>舍弃@import</h2><p>前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。</p><p>在IE中用<code>@import</code>与底部用<code>&lt;link&gt;</code>效果一样，所以最好不要用它。</p><h2 id="CSS-避免使用滤镜"><a href="#CSS-避免使用滤镜" class="headerlink" title="[CSS]避免使用滤镜"></a>[CSS]避免使用滤镜</h2><p>IE专有的<code>AlphaImageLoader</code>滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个过滤会阻塞渲染，卡住浏览器，还会增加内存消耗而且被应用到每个元素的，而不是每个图片，所以会存在一大推问题。</p><p>最好的方法是干脆不要用<code>AlphaImageLoader</code>，而优雅地降级到用IE中支持性很好的PNG8图片来代替。如果非要用<code>AlphaImageLoader</code>，应该用下划线hack：<code>_filter</code>来避免影响IE7及更高版本的用户。</p><h2 id="图片-优化图片"><a href="#图片-优化图片" class="headerlink" title="[图片]优化图片"></a>[图片]优化图片</h2><p>设计师做好图之后，在把这些图通过FTP上传到web服务器之前，我们还可以做一些事情。</p><ul><li><p>检查GIF图片，看看图片中是不是用了调色板大小对应的颜色数，用<a href="http://www.imagemagick.org/script/index.php" target="_blank" rel="noopener">imagemagick</a>可以简单地检查：<code>identify -verbose image.gif</code>如果4色图片用了调色板中256色的“槽”，那就还有改进的余地</p></li><li><p>试着把GIF图片转换成PNG，看能不能缩减大小，往往可以。开发者通常不愿意用PNG图片，因为浏览器支持有限，但这都是过去的事情了。真正的问题是PNG图片完全支持alpha透明度，而GIF图片却不支持透明度渐变，所以GIF能做的任何事情,PNG都可以（除了动画）。下面这个简单的命令就能让PNG图片可以安全使用：<code>convert image.gif image.png</code>“我们强调的是：给PNG一个机会。”</p></li><li><p>用<a href="https://pmt.sourceforge.io/pngcrush/" target="_blank" rel="noopener">pngcrush</a>（或者其他的PNG优化工具）处理所有的PNG图片，例如：<code>pngcrush image.png -rem alla -reduce -brute result.png</code></p></li><li><p>用jpegtran处理所有JPEG图片，这个工具支持对JPEG图片的无损操作比如旋转，还可以用来去除注释和其他无用信息（比如EXIF信息 P.S.数码照片信息，焦距光圈之类的）：<code>jpegtran -copy none -optimize -perfect src.jpg dest.jpg</code></p></li></ul><h2 id="图片-优化CSS-Sprite"><a href="#图片-优化CSS-Sprite" class="headerlink" title="[图片]优化CSS Sprite"></a>[图片]优化CSS Sprite</h2><ul><li><p>在Sprite图片中横向排列一般都比纵向排列的最终文件小</p></li><li><p>组合Sprite图片中的相似颜色可以保持低色度，最理想的是256色以下PNG8格式</p></li><li><p>“对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会有很大程度上影响文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100 x 100的图片是1万个像素，而1000 x 1000的图片就是100万个像素了。</p></li></ul><h2 id="图片-不要用HTML缩放图片"><a href="#图片-不要用HTML缩放图片" class="headerlink" title="[图片]不要用HTML缩放图片"></a>[图片]不要用HTML缩放图片</h2><p>不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要<code>&lt;img width=&quot;100&quot; height=&quot;100&quot;src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot;&gt;</code>那么图片本身(mycat.jpg)应该是100 x 100px的，而不应该是去缩小500 x 500px的图片。</p><h2 id="图片-用更小的可缓存的favicon-ico（P-S-收藏夹图片）"><a href="#图片-用更小的可缓存的favicon-ico（P-S-收藏夹图片）" class="headerlink" title="[图片]用更小的可缓存的favicon.ico（P.S.收藏夹图片）"></a>[图片]用更小的可缓存的favicon.ico（P.S.收藏夹图片）</h2><p>favicon.ico是放在服务器根目录的图片，它会带来一大堆麻烦，因为即使你不管它，浏览器也会自动请求它，所以最好不要给一个<code>404 Not Found</code>响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。</p><p>所以为了缓解favicon.ico的缺点，应该确保:</p><ul><li><p>足够小，最好在1K以下</p></li><li><p>设置合理的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。</p></li></ul><p><a href="http://www.imagemagick.org/script/index.php" target="_blank" rel="noopener">Imagemagick</a>可以用来处理小收藏夹图标</p><h2 id="移动-保证所有组件都小于25K"><a href="#移动-保证所有组件都小于25K" class="headerlink" title="[移动]保证所有组件都小于25K"></a>[移动]保证所有组件都小于25K</h2><p>这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是<code>未压缩的</code>大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。</p><p>更多信息请查看Wayne Shea和Tenni Theurer的文章：<a href="https://yuiblog.com/blog/2008/02/06/iphone-cacheability/" target="_blank" rel="noopener">Performance Research, Part 5: iPhone Cacheability – Making it Stick</a></p><h2 id="移动-把组件打包到一个复合文档里"><a href="#移动-把组件打包到一个复合文档里" class="headerlink" title="[移动]把组件打包到一个复合文档里"></a>[移动]把组件打包到一个复合文档里</h2><p>把各个组件打包成一个像附有的电子邮件一样的符合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。</p><h2 id="服务器-避免图片src属性为空"><a href="#服务器-避免图片src属性为空" class="headerlink" title="[服务器]避免图片src属性为空"></a>[服务器]避免图片src属性为空</h2><p>Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现：</p><p>1.straight HTML</p><blockquote><p><img src=""></p></blockquote><p>2.Javascript</p><blockquote><p>var img = new Image();<br>img.src = “”</p></blockquote><p>这两种形式都会引起相同的问题：浏览器会向服务器发送另一个请求。</p><ul><li><p>IE向页面所在目录发起一个请求</p></li><li><p>Safari和Chrome想当前页面本身发送一个请求</p></li><li><p>Firefox3及更早版本与Safari和Chrome处理方式一样，但3.5解决了这个问题<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=444931" target="_blank" rel="noopener">bug 444931</a>，不会再发送请求了</p></li><li><p>Opera遇到有空src属性的图片不做任何处理</p></li></ul><p>为什么图片src属性为空不好？</p><p>1.意外发送大量的通信量对服务器来说是很伤的，尤其是在每天有几百万访问量页面的时候。</p><p>2.浪费服务器资源去生成一个根本不可能看到的页面</p><p>3.可能会污染用户数据，如果追踪请求状态，要么通过cookie要么是其它方式，可能会破坏用户数据。即使图片请求并没有返回图片，整个HTTP头部也会被浏览器接受并读取，包括所有的cookie。虽然其余部分会被丢弃，但这可能已经造成破坏了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ayqy.net/blog/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%EF%BC%9A%E9%9B%85%E8%99%8E35%E6%9D%A1/?utm_source=tuicool&amp;utm_medium=referral#r1" target="_blank" rel="noopener">前端优化：雅虎35条</a></p><p style="color: red;text-align:center;">精力有限，未能一次更新完毕，还请见谅…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/optimization/fontend-optimization-banner.jpg&quot; alt=&quot;frontend/optimization/fontend-optimization-banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;整理前端优化的方案，主要是雅虎的35条原则。欢迎补充哈 😊 &lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="读书" scheme="http://reng99.cc/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>重读《JavaScript高级程序设计》</title>
    <link href="http://reng99.cc/2018/03/01/javascript-high-level/"/>
    <id>http://reng99.cc/2018/03/01/javascript-high-level/</id>
    <published>2018-03-01T09:09:19.000Z</published>
    <updated>2018-03-13T11:55:42.657Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/life/learn/read/javascript/javascript_high_level.jpg" alt="life/learn/read/javascript/javascript_high_level"></p><p>最近自己在休假，打算闭门几天将《JavaScript高级程序设计》(第3版)这本良心教材再回顾一遍。目前自己进入前端领域两年多，现在重读并记录下这本教材的“硬”知识点 😊 。</p><a id="more"></a><h2 id="函数没有重载"><a href="#函数没有重载" class="headerlink" title="函数没有重载"></a>函数没有重载</h2><p>ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数类型和数量）不同即可[p66]。ECMAScript的类型是松散形的，没有签名，所以是没有重载的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">num,name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = load(<span class="number">100</span>); <span class="comment">// 200</span></span><br><span class="line"># 后面的函数声明覆盖掉前面的函数声明</span><br></pre></td></tr></table></figure><h2 id="基本的数据类型"><a href="#基本的数据类型" class="headerlink" title="基本的数据类型"></a>基本的数据类型</h2><p><strong>基本类型值</strong>指的是简单的数据段，而<strong>引用类型</strong>指那些可能由多个值构成的对象[p68]。这里指出来的基本的数据类型是说的es5的哈：<code>Undefined</code>,<code>Null</code>,<code>Boolean</code>,<code>Number</code>和<code>String</code>。</p><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>ECMAScript 中所有的函数的参数都是<code>按值传递</code>的[p70]。也就是说，把函数外部的值复制给函数内部的参数，就是把值从一个变量复制到另一个变量一样。<strong>基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。</strong>下面分开例子介绍两种不同类型为什么是按值传递。</p><h3 id="基本类型值"><a href="#基本类型值" class="headerlink" title="基本类型值"></a>基本类型值</h3><p>基本类型这个按值传递比较好理解，直接复制变量的值传递：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">num += <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = addTen(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 20 ，没有变化哈</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><h3 id="引用类型值"><a href="#引用类型值" class="headerlink" title="引用类型值"></a>引用类型值</h3><p>有些人认为引用类型的传参是按照引用来传的，那暂且认为他们的理解是正确的，那下面的示例结果怎么解析呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">obj.name = <span class="string">'嘉明'</span>;</span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">'庞嘉明'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// '嘉明'，为啥不是'庞嘉明'呢？</span></span><br></pre></td></tr></table></figure><p>如果是按照引用传的话，那么新建的对象<code>obj = new Object()</code>应该是指向堆内容的对象啊，那么改变它本有的<code>name</code>属性值应该生效，然而并没有生效。所以它也是<code>按值传递</code>滴。</p><h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h2><p>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁[p111]。解析器会率先读取函数声明，并使其执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">//TypeError: sum is not a function</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apply和call"><a href="#apply和call" class="headerlink" title="apply和call"></a>apply和call</h2><p>每个函数都包含两个非继承而来的方法：<code>apply()和call()</code>。这两个方法的<strong>用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值</strong>[116]。call和apply在对象中还是挺有用处的。</p><p>apply()方法和call()方法的作用是相同的，区别在于接收参数的方式不同。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是<strong>参数数组</strong>，这里的参数数组可以是Array的实例，也可以是arguments对象（类数组对象）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">// 传入arguments类数组对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,[num1 , num2]); <span class="comment">// 传入数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>call()方法接收的第一个参数和apply()方法接收的一样，变化的是其余的参数直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1 , num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.call(<span class="keyword">this</span> , sum1 , sum2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum(<span class="number">10</span> , <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>虽然Object构造函数或者对象字面量都可以用来创建单个对象，但是这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。[p144]</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式就是造一个模子产生一个个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name , age ,job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = name;</span><br><span class="line">o.age = age;</span><br><span class="line">o.job = job;</span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">'greg'</span> , <span class="number">27</span> , <span class="string">'doctor'</span>);</span><br></pre></td></tr></table></figure><p> 工厂模式解决了创建多个相似对象的问题（解决创建对象时产生大量重复代码），但是没有解决对象识别的问题（即怎么知道一个对象的类型，是Person还是Animal啊）。</p><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>下面使用构造函数创建特定类型的对象。这里是Person类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , job</span>)</span>&#123; <span class="comment">// 注意构造函数的首字母为大写哦</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'greg'</span> , <span class="number">27</span> , <span class="string">'doctor'</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.constructor == Person); <span class="comment">// true 可以理解为person1的创造者是Person，也就是对象的类型Person</span></span><br></pre></td></tr></table></figure><p>在创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（因此this指向了这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><p>构造函数解决了重复实例话问题（也就是创建多个相似对象的问题）和解决了对象识别的问题。但是，像上面那样，person1和person2共有的方法，实例化的时候都创建了，这未免多余了。当然可以将共有的方法提取到外面，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'greg'</span> , <span class="number">27</span> , <span class="string">'doctor'</span>);</span><br></pre></td></tr></table></figure><p>将sayName提取出来，就成了全局的方法了，然而这里只有Person类创建对象的时候才使用到，这样就大才小用了吧，所以提取出来到全局方法这种操作不推荐。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>创建的每个函数都有一个prototype（原型）属性，这个属性就是一个指针，指向一个对象，而这个对象的用途就是包含可以由特定类型的所有实例共享的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'nicholas'</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以有关系图如下：</p><p><img src="http://omu538iq8.bkt.clouddn.com/life/learn/read/javascript/prototype_object.jpg" alt="life/learn/read/javascript/prototype_object"></p><p>上面的Person.prototype不建议使用字面量来写Person.prototype={},虽让效果一样，但是这里重写了原本Person.prototype的对象，因此constructor属性会指向Ohject而不是Person。当然也是可以处理的啦，将指向指正确并指定’construtor’的枚举属性为<code>enumerable: false</code>。</p><p>原型模式解决了函数共享的问题，但是也带了一个问题：实例化中对象的属性是独立的，而原型模式这里共享了。</p><h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>创建自定义类型的最常见的方式，就是组合使用构造函数模式和原型模式。<strong>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age ,job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="keyword">this</span>.friends = [<span class="string">'shelby'</span> , <span class="string">'court'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'greg'</span> , <span class="number">27</span> , <span class="string">'doctor'</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">'van'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">// 'shelby,court,van'</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// 'shelby,court'</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>其他的OO语言，比如java，创建对象的类中是包含了自身的属性、方法和共有的属性、方法，如下小狗的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name )</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">System.out.println(<span class="string">'小狗的名字是: '</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">'小狗的年龄为: '</span> + age);</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 创建对象 */</span></span><br><span class="line">Dog dog = <span class="keyword">new</span> Dog(<span class="string">'tom'</span>);</span><br><span class="line"><span class="comment">/* 通过方法来设定age */</span></span><br><span class="line">dog.setAge(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/* 调用另外一个方法获取age */</span></span><br><span class="line">dog.getAge();</span><br><span class="line"><span class="comment">/* 也可以通过 对象.属性名 获取 */</span></span><br><span class="line">System.out.println(<span class="string">'变量值: '</span> + dog.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了看起来是类那么一会事，动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age ,job</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>)&#123;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span> , <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>在前面几种模式都不适应的情况下，可以用寄生构造函数模式（数据结构中就使用到哈），寄生构造函数模式可以看成是工厂模式和构造函数模式的结合体。其基本思想是<strong>创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = name;</span><br><span class="line">o.age = age;</span><br><span class="line">o.job = job;</span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'nicholas'</span>, <span class="number">29</span> , <span class="string">'software engineer'</span>);</span><br><span class="line">friend.sayName(); <span class="comment">// nicholas</span></span><br></pre></td></tr></table></figure><p>关于寄生构造函数模式，需要说明：返回的对象与构造函数或者与构造函数的原型属性直接没有什么关系；也就是说，构造函数返回的对象与构造函数外部创建的对象没有什么区别。为此，不能依赖instanceof操作符来确定对象类型。由于存在上面的问题，建议在可以使用其他模式的情况下，不要使用这种模式。</p><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>稳妥对象适合在一些安全的环境中（这些环境中会禁止使用this和new），或者防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但是有两点不同：意识新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , job</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 创建要返回的对象</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在这里定义私有的变量和函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(name);  <span class="comment">// 不使用this.name</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象</span></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">'nicholas'</span>, <span class="number">29</span> , <span class="string">'software engineer'</span>); <span class="comment">// 不使用new</span></span><br><span class="line">friend.sayName(); <span class="comment">// 'nicholas'</span></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>许多的OO语言都支持两种继承方法：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现主要是<strong>依靠原型链来实现的</strong>。[p162]</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链的基本思想是<strong>利用原型让一个引用类型继承另一个引用类型的属性和方法</strong>。回顾下构造函数、原型和实例的关系: 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了SuperType,重点哦</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中原型链如下：</p><p><img src="http://omu538iq8.bkt.clouddn.com/life/learn/read/javascript/prototype_chain.png" alt="life/learn/read/javascript/prototype_chain"></p><p>原型链继承带来两个问题：一是原型实际上变成了另一个类型的实例，于是，原先的实例属性也就变成了现在原型的属性，共享了属性。二是在创建子类型的实例时，不能在没有影响所有对象实例的情况下向超类型的构造函数传递参数。</p><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>借用构造函数解决原型链继承带来的不能向构造函数传递仓鼠的问题。这里使用到了apply()或者call()方法在新创建的对象上执行构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line">SubType.call(<span class="keyword">this</span>); <span class="comment">// 使用SubType.apply(this)同效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.color.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// 'red,blue,green,black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// 'red,blue,green'</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我在父类型构造函数中没有传参数，看者感兴趣的话可以自己加下参数来实验一番咯。</p><p>借用构造函数解决了原型链继承的确定，但是又没有接纳原型链的优点：共享。下面的组合继承结合了原型链和借用构造函数，容纳了两者的优点。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承的思路是<strong>使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 继承属性</span></span><br><span class="line">SuperType.call(<span class="keyword">this</span>,name);</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor =SubType; <span class="comment">// 避免重写构造函数指向错误</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'nicholas'</span> , <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// 'red,blue,green,black'</span></span><br><span class="line">instance1.sayName(); <span class="comment">// 'nicholas'</span></span><br><span class="line">instance1.sayAge(); <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'greg'</span> , <span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// 'red,blue,green'</span></span><br><span class="line">instance2.sayName(); <span class="comment">// 'greg'</span></span><br><span class="line">instance2.sayAge(); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，<code>成为了JavaScript中最常用的继承模式</code>。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。</p><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>原型式继承是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义的类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123; <span class="comment">// 传入一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype = o;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">'nicholas'</span>,</span><br><span class="line">friends: [<span class="string">'shelby'</span>,<span class="string">'court'</span>,<span class="string">'van'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">'greg'</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">'rob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">'linda'</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">'barbie'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends); <span class="comment">// 'shelby,court,van,rob,barbie'</span></span><br></pre></td></tr></table></figure><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是与原型继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即是创建了一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的做了所有工作一样返回对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123; <span class="comment">// 传入一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype = o;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> clone = object(original);</span><br><span class="line">clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">'nicholas'</span>,</span><br><span class="line">friends : [<span class="string">'shelby'</span>,<span class="string">'court'</span>,<span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">// 'hi'</span></span><br></pre></td></tr></table></figure><p>上面的例子中，新对象anotherPerson不仅具有person的所有属性和方法，而且还有了自己的sayHi()方法。</p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。寄生组合式继承能够解决这个问题。</p><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是<strong>不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型的原型的一个副本而已</strong>。寄生组合式继承的基本模式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> prototype = <span class="built_in">Object</span>(superType.prototype); <span class="comment">// 创建对象</span></span><br><span class="line">prototype.constructor = subType; <span class="comment">// 增强对象，防止下面重写constructor属性</span></span><br><span class="line">subType.prototype = prototype; <span class="comment">// 指定对象</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个完整的例子如下,相关插图见书[p173]:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> prototype = <span class="built_in">Object</span>(superType.prototype);</span><br><span class="line">prototype.constructor = subType;</span><br><span class="line">subType.prototype = prototype;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.color = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">SuperType.call(<span class="keyword">this</span>,age); <span class="comment">// 只在这调用了一次超类型的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType , SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">'nicholas'</span> , <span class="number">29</span>);</span><br></pre></td></tr></table></figure><p>上面的例子的高效处体现在它只调用了一次SuperType构造函数，并且避免了在SubType.prototype上创建不必要的，多余的属性。与此同时，原型链还能保持不变；因此还能正常使用instanceof和inPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。我的理解是，函数内的函数使用到外层函数的变量延长变量的生存时间，造成常驻内存。例子见下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 3</span></span><br><span class="line">baz(); <span class="comment">// 4</span></span><br><span class="line">baz(); <span class="comment">// 5</span></span><br><span class="line">baz(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>上面的例子中，外部的函数foo()执行完成之后，正常的情况下应该销毁a变量的，但是内部的返回的匿名函数使用到该变量，不能销毁。如果需要销毁的话，可以改写成下面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line">baz(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">baz = <span class="literal">null</span>; <span class="comment">// 将内部的匿名函数赋值为空</span></span><br></pre></td></tr></table></figure><h2 id="从闭包说起"><a href="#从闭包说起" class="headerlink" title="从闭包说起"></a>从闭包说起</h2><p>谈到了闭包，这让我想起了不久前刷知乎看到一篇<a href="https://zhuanlan.zhihu.com/p/25855075" target="_blank" rel="noopener">文章</a>。自己整理如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5,5,5,5,5,5</span></span><br></pre></td></tr></table></figure><p>上面的代码是输出了6个5，而这6个5是这样执行的，先输出全局中的<code>console.log(i)</code>，然后是过了1秒种后，瞬间输出了5个5（为什么用瞬间这个词呢，怕看者理解为每过一秒输出一个5）。解读上面的代码的话，可以通过狭义范围(es5)的理解：同步 =&gt; 异步 =&gt; 回调 （回调也是属于异步的范畴，所以我这里指明了狭义啦）。先是执行同步的for,遇到异步的setTimeout(setTimeout和setInterval属于异步哈)后将其放入队列中等待，接着往下执行全局的<code>console.log(i)</code>，将其执行完成后执行异步的队列。</p><p><strong>追问1:闭包</strong></p><p>改写上面的代码，期望输出的结果为：5 =&gt; 0,1,2,3,4。改造的方式一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(j);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5,0,1,2,3,4</span></span><br></pre></td></tr></table></figure><p>上面的代码巧妙的利用IIFE(Immediately Invoked Function Expression:声明即执行的函数表达式)来解决闭包造成的问题，闭包的解析看上面。</p><p>方法二：利用js中基本类型的参数传递是按值传递的特征，改造代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> output = <span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">output(i); <span class="comment">// 这里传过去的i值被复制了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5,0,1,2,3,4</span></span><br></pre></td></tr></table></figure><p>上面改造的两个方法都是执行代码后先输出5，然后过了一秒种依次输出0,1,2,3,4。</p><p>如果不要考虑全局中的<code>console.log(i)</code>输出的5，而是循环中输出的0,1,2,3,4。你还可以使用ES6的<code>let</code>块级作用域语法,实现超级简单:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0,1,2,3,4</span></span><br></pre></td></tr></table></figure><p>上面是过了一秒钟后，依次输出0,1,2,3,4。这种做法类似于无形中添加了闭包。那么，如果使用ES6语法的话，会怎样实现<code>5,0,1,2,3,4</code>呢？</p><p><strong>追问2:ES6</strong></p><p>改造刚开始的代码使得输出的结果是每隔一秒输出0,1,2,3,4，大概第五秒输出5。</p><p>在不使用ES6的情况下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(j);</span><br><span class="line">&#125;,<span class="number">1000</span>*j);</span><br><span class="line">&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>*i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0,1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p>上面的代码简单粗暴，但是不推荐。看题目是每隔一秒输出一个值，再回调实现最后的5输出，这个时候应该使用ES6语法来考虑，应该使用Promise方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;<span class="comment">// 这里的i声明不能改成let，改成let的话请看下一段代码</span></span><br><span class="line">(<span class="function">(<span class="params">j</span>)=&gt;</span>&#123;</span><br><span class="line">tasks.push(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123; <span class="comment">// 执行tasks</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(j);</span><br><span class="line">resolve(); <span class="comment">// 这里一定要resolve,否则代码不会按照预期执行</span></span><br><span class="line">&#125;,<span class="number">1000</span>*j);</span><br><span class="line">&#125;))</span><br><span class="line">&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// 执行完tasks，回调</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合要求的每隔一秒输出</span></span><br><span class="line"><span class="comment">// 0,1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p>如果是使用<code>let</code>，我的改造如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">tasks.push(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">resolve();</span><br><span class="line">&#125;, <span class="number">1000</span> * i);</span><br><span class="line">&#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(tasks.length);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0,1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p>上面的代码比较庞杂，可以将其颗粒话，模块化。对上面两段代码的带<code>var</code>那段进行改造后如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []; <span class="comment">// 这里存放异步操作的Promise</span></span><br><span class="line"><span class="keyword">const</span> output = <span class="function">(<span class="params">i</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>*i);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成全部的异步操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">tasks.push(output(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步操作完成之后，输出最后的i</span></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合要求的每隔一秒输出</span></span><br><span class="line"><span class="comment">// 0,1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p><strong>追问3:ES7</strong></p><p>既然ES6的Promise可以写，那么ES7是否可以写呢，从而让代码更加简洁易读？那就使用到到了异步操作的<code>async await</code>特性啦。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟其他语言中的sleep，实际上可以是任何异步操作</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">time</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(resolve , time);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合要求的每隔一秒输出</span></span><br><span class="line"><span class="comment">// 0,1,2,3,4,5</span></span><br></pre></td></tr></table></figure><h2 id="浏览器窗口位置"><a href="#浏览器窗口位置" class="headerlink" title="浏览器窗口位置"></a>浏览器窗口位置</h2><p>IE、Safari、Opera和Chrome都提供了screenLeft和screenTop属性，分别表示浏览器窗口相对于屏幕左上角和上边的位置[p197]。Firefox则以screenX和screenY属性来表示。为了兼容各个浏览器，可以入下面这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>)?<span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>)? <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure><h2 id="浏览器窗口大小"><a href="#浏览器窗口大小" class="headerlink" title="浏览器窗口大小"></a>浏览器窗口大小</h2><p>由于浏览器厂商以及历史的问题，无法确认浏览器本身的大小，但是可以取得视口的大小[p198]。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">'CSS1Compat'</span>)&#123; <span class="comment">// 标准模式下的低版本ie</span></span><br><span class="line">pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123; <span class="comment">// 混杂模式下的chrome</span></span><br><span class="line">pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例可以简写成下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line"><span class="keyword">var</span> pageHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight;</span><br></pre></td></tr></table></figure><h2 id="canvas中的变换"><a href="#canvas中的变换" class="headerlink" title="canvas中的变换"></a>canvas中的变换</h2><p>为绘制上下文应用变换，会导致使用不同的变换矩阵应用处理，从而产生不同的结果。[p453]</p><p>可通过下面的方法来修改变换矩阵:</p><ul><li>rotation(angle):围绕原点旋转图像angle弧度</li><li>scale(scaleX,scaleY)</li><li>translate(x,y): 将坐标原点移动到(x,y)。执行这个变换后，坐标(0,0)会变成之前由(x,y)表示的点。</li></ul><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>关于JSON，最重要的是要理解它是一种数据格式，不是一种编程语言。</p><h3 id="对象字面量和JSON格式比较"><a href="#对象字面量和JSON格式比较" class="headerlink" title="对象字面量和JSON格式比较"></a>对象字面量和JSON格式比较</h3><p>先来看下对象字面量demo写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">"nicholas"</span>,</span><br><span class="line">age : <span class="number">29</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 上面的代码也可以写成下面的</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"><span class="string">"name"</span> : <span class="string">"nicholas"</span>,</span><br><span class="line"><span class="string">"age"</span> : <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而上面的对象写成数据的话，就是下面这样了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"nicholas "</span>,</span><br><span class="line"><span class="attr">"age"</span>: <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 可到网站 https://www.bejson.com/ 验证</span><br></pre></td></tr></table></figure><p>⚠️ 与JavaScript对象字面量相比，JSON对象又两个地方不一样。首先，没有声明变量(JSON中没有变量的概念)。其次，没有分号(因为这不是JavaScript语句，所以不需要分号)。留意的是，对象的属性必须加双引号(不是单引号哦)，这在JSON中是必须的。</p><h3 id="stringify-和parse"><a href="#stringify-和parse" class="headerlink" title="stringify()和parse()"></a>stringify()和parse()</h3><p>可以这么理解：JSON.stringify()是从一个object中解析成JSON数据格式，而JSON.parse()是从一个字符串中解析成JSON数据格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">'nicholas'</span>,</span><br><span class="line">age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(person);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(jsonText);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;"name":"nicholas","age":29&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strPerson = <span class="string">'&#123;"name":"nicholas","age":29&#125;'</span>;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.parse(strPerson);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(jsonText); <span class="comment">// &#123; name: 'nicholas', age: 29 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h2><p>XMLHttpRequest对象用于在后台与服务器交换数据。它是Ajax技术的核心[p571]。</p><p>XMLHttpRequest对象能够使你：</p><ul><li>在不重新加载页面的情况下更新网页 </li><li>在页面已加载后从服务器请求数据</li><li>在页面已加载后从服务器接收数据</li><li>在后台向服务器发送数据</li></ul><p>XMLHttpRequest的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 创建XHR对象 =&gt; open()准备发送 =&gt; send()传送数据</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象，对浏览器做兼容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">'undefined'</span>)&#123; <span class="comment">// IE7+和其他浏览器支持</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> ActiveXObject != <span class="string">'undefined'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">'string'</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> versions = [<span class="string">'MSXML2.XMLHttp.6.0'</span>,<span class="string">'MSXML2.XMLHttp.3.0'</span>,<span class="string">'MSXML2.XMLHttp'</span>]; <span class="comment">// 低版的ie可能遇到三种不同版本的XMR对象</span></span><br><span class="line"><span class="keyword">var</span> i , len;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>,len = versions.length; i &lt; len ; i++)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">new</span> ActiveXObject(version[i]);</span><br><span class="line"><span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span> (ex)&#123;</span><br><span class="line"><span class="comment">// 跳过</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No XHR object available."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备发送数据</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"path/to/example.txt"</span>,<span class="literal">false</span>);<span class="comment">// 非异步，异步的话第三个参数改为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传送数据</span></span><br><span class="line">xhr.send(<span class="literal">null</span>); <span class="comment">// get方法不需要传数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断状态嘛，获取服务器返回的数据</span></span><br><span class="line"><span class="keyword">if</span>((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Request was nsuccessful : "</span> + xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><p>何为跨域呢？只要访问的资源的协议、域名、端口三个不全相同，就可以说是非同源策略而产生了跨域了，这是狭义的说法。广义的说法：通过XHR实现Ajax通信的一个主要限制，来源于跨域的安全策略；默认情况下,XHR对象只能访问包含它的页面位于同一个域中的资源[p582]。注：部分文字和代码引用自<a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a></p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS（Cross-Origin Resource Sharing，跨资源共享）定义了在必须访问跨资源时，浏览器与服务器应该如何沟通。其背后的基本思想，就是<strong>使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</strong> 复杂的跨域请求应当考虑使用它。</p><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无需设置，如果要带cookie请求：前后端都要设置。</p><p>1.前端设置</p><p>1.) 原生ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span>(<span class="params">method,url</span>)</span>&#123; <span class="comment">// 兼容处理，ie8/9需要用到window.XDomainRequest</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr)&#123; <span class="comment">// 其他的用到withCredentials</span></span><br><span class="line">xhr.open(method,url,<span class="literal">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> XDomainRequest != <span class="string">'undefined'</span>)&#123;</span><br><span class="line">xhr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">xhr.open(method , url);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">xhr = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get请求</span></span><br><span class="line"><span class="keyword">var</span> request = createCORSRequest(<span class="string">"get"</span>,<span class="string">"http://www.somewhere-else.com/page/"</span>);</span><br><span class="line"><span class="keyword">if</span>(request)&#123;</span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//  对request.responseText 进行处理 </span></span><br><span class="line">&#125;;</span><br><span class="line">request.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// post请求，带cookie</span></span><br><span class="line"><span class="keyword">var</span> requestXhr = createCORSRequest(<span class="string">"post"</span>,<span class="string">"http://www.somewhere-else.com/page/"</span>);</span><br><span class="line">requestXhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">requestXhr.send(<span class="string">"user=admin"</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.)jquery ajax </p><p>上面写了一大堆原生的，看得头都有点大了，还是使用jquery ajax 比较舒服:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">...</span><br><span class="line">xhrFields: &#123;</span><br><span class="line">withCredentials: <span class="literal">true</span> <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">&#125;,</span><br><span class="line">crossDomain: <span class="literal">true</span>, <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span></span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.) vue框架</p><p>在vue-resource封装的ajax组建中加入以下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.credentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>2.服务器设置</p><p>若后端设置成功，前端浏览器控制台上就不会出现跨域报错的信息，反之，说明没有成功。</p><p>1.） java后台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 导入包：import javax.servlet.http.HttpServletResponse;</span></span><br><span class="line"><span class="comment"> * 接口参数中定义：HttpServletResponse response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://www.domain1.com"</span>);  <span class="comment">// 若有端口需写全（协议+域名+端口）</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>2.) node后台</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据块接收中</span></span><br><span class="line">    req.addListener(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据接收完毕</span></span><br><span class="line">    req.addListener(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨域后台设置</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="string">'true'</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">            <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://www.domain1.com'</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">            <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>   <span class="comment">// HttpOnly:脚本无法读取cookie</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res.write(<span class="built_in">JSON</span>.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是JSON with padding(填充式JSON或参数式JSON)的简写，是应用JSON的一种新方法，在后来的web服务中非常流行。简单的跨域请求用JSONP即可。</p><p>通常为了减轻web服务器的负载，我们把js,css,img等静态资源分离到另一台独立域名的服务器，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p><p>1.前端实现</p><p>1.）原生实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">script.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 传参并指定回调执行函数为onBack</span></span></span><br><span class="line"><span class="javascript">script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 回调执行函数</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">onBack</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(res));</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务器返回如下（返回时即执行全局函数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onBack(&#123;<span class="string">"status"</span>: <span class="literal">true</span>,<span class="string">"user"</span>:<span class="string">"admin"</span>&#125;)</span><br></pre></td></tr></table></figure><p>2.）jquery ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url: <span class="string">'http://www.domain2.com:8080/login'</span>,</span><br><span class="line">type: <span class="string">'get'</span>,</span><br><span class="line">dataType: <span class="string">'jsonp'</span>, <span class="comment">// 请求方式为jsonp </span></span><br><span class="line">jsonpCallback: <span class="string">'onBack'</span>, <span class="comment">// 自定义回调函数名</span></span><br><span class="line">data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.）vue.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.jsonp(<span class="string">'http://www.domain2.com:8080/login'</span>,&#123;</span><br><span class="line">params: &#123;&#125;,</span><br><span class="line">jsonp: <span class="string">'onBack '</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.后端nodejs代码的示范：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> params = qs.parse(req.url.split(<span class="string">'?'</span>)[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">var</span> fn = params.callback;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonp返回设置</span></span><br><span class="line">res.writeHead(<span class="number">200</span>,&#123;<span class="string">"Content-Type"</span>:<span class="string">"text/javascript"</span>&#125;);</span><br><span class="line">res.write(fn + <span class="string">'('</span>+<span class="built_in">JSON</span>.stringify(params)+<span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080 ...'</span>);</span><br></pre></td></tr></table></figure><p>⚠️ jsonp缺点：</p><ol><li><p>jsonp只支持get请求而不支持post请求，也就是说如果想传给后台一个json格式的数据，此时问题就来了，浏览器回报一个http状态码415错误，告诉你请求格式不正确。</p></li><li><p>存在明显的安全性问题，容易收到xss攻击</p></li></ol><h3 id="WebSocket协议跨域"><a href="#WebSocket协议跨域" class="headerlink" title="WebSocket协议跨域"></a>WebSocket协议跨域</h3><p>WebSocket protocol 是 HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯。</p><p>原生的WebSocket API使用起来不太方便，示例中使用了<a href="https://socket.io/" target="_blank" rel="noopener">socket.io</a>，它很好的封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1.前端代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>user input：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> socket = io(<span class="string">'http://www.domain2.com:8080'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="javascript">socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'data from server: ---&gt; '</span> + msg); </span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端关闭</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Server socket has closed.'</span>); </span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    socket.send(<span class="keyword">this</span>.value);</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.node socket后台</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Content-type'</span>: <span class="string">'text/html'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 接收信息</span></span><br><span class="line">    client.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        client.send(<span class="string">'hello：'</span> + msg);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data from client: ---&gt; '</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开处理</span></span><br><span class="line">    client.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Client socket has closed.'</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="requestAnimationFrame-帧动画"><a href="#requestAnimationFrame-帧动画" class="headerlink" title="requestAnimationFrame()帧动画"></a>requestAnimationFrame()帧动画</h2><p>requestAnimationFrame 创建平滑的动画[p682]。在此之前都是使用setTimeout或者setInterval实现，requestAnimationFrame与它们相比：</p><ul><li>不需要时间间隔，会贴切浏览器的刷新频率</li><li>在切换到另外的页面时，会停止运行</li></ul><p>使用的示范如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"num"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  兼容浏览器</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>,<span class="string">'moz'</span>,<span class="string">'ms'</span>,<span class="string">'-o'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>;x &lt;vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; ++x)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">'cancelAnimationFrame'</span>] || <span class="built_in">window</span>[vendors[x] + <span class="string">'CancelRequestAnimationFrame'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.requestAnimationFrame)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> currTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">            <span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">16</span> - (currTime - lastTime));</span><br><span class="line">            <span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                callback;</span><br><span class="line">            &#125;,timeToCall);</span><br><span class="line">            lastTime = currTime - timeToCall;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.cancelAnimationFrame)&#123;</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>)</span>&#123;</span><br><span class="line">            clearTimeout(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的计数</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>,</span><br><span class="line"> timer;</span><br><span class="line">fn();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'num'</span>).innerText = ++num;</span><br><span class="line">timer = requestAnimationFrame(fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">cancelAnimationFrame(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/life/learn/read/javascript/javascript_high_level.jpg&quot; alt=&quot;life/learn/read/javascript/javascript_high_level&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近自己在休假，打算闭门几天将《JavaScript高级程序设计》(第3版)这本良心教材再回顾一遍。目前自己进入前端领域两年多，现在重读并记录下这本教材的“硬”知识点 😊 。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="读书" scheme="http://reng99.cc/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="javascript" scheme="http://reng99.cc/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>我的2018计划</title>
    <link href="http://reng99.cc/2018/02/21/my-2018-plans/"/>
    <id>http://reng99.cc/2018/02/21/my-2018-plans/</id>
    <published>2018-02-21T15:01:49.000Z</published>
    <updated>2018-02-21T16:28:11.254Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/life/plans/2018/plan_logo.jpg" alt="life/plans/2018/plan_logo.jpg"></p><p>嗖～嗖～嗖～～～🚀现在是农历正月初六的晚上十一点多，第二天就得上班了呢，一年的时间过得真是賊快，来不及感叹2017年自己做了什么，只想着眼现在，立flag啦，鬼知道我会在新的一年会遇到什么人和事情呢。希望一年后回头看不打脸咯…</p><a id="more"></a><h3 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h3><p>看完下面的推荐书籍中的3-5本：</p><ol><li>保罗.约翰逊 《文明的解析》</li><li>乔治.阿克洛夫 《动物精神》</li><li>南希.休斯顿 《断层线》</li><li>安德鲁.罗斯.索尔金 《大而不倒》</li><li>保罗.克利尔 《被掠夺的星球》</li><li>马特.里德利 《理智的乐观者》</li><li>丹.艾瑞里 《非理性的积极力量》</li><li>莱茵哈特.罗格夫 《这次不一样》</li><li>乔纳森.弗兰岑 《自由》</li><li>里查德.克拉克和罗伯特.克纳克 《网络战争》</li><li>巴塞维奇 《华盛顿规则》</li><li>查布里斯.西蒙斯 《看不见的大猩猩》</li><li>托尼.朱特 《乡土式微》</li><li>阿维沙伊.马加利特 《关于妥协和卑微的妥协》</li><li>奇普.希思 《瞬变》</li><li>刘易斯 《大空头》</li><li>查尔斯.默里 《人类成就》</li><li>瓦茨拉夫.斯米尔 《能源神话与现实》</li><li>南丹.尼莱卡尼 《印度畅想》</li><li>克莱.舍基 《未来是湿的》</li></ol><h3 id="深造"><a href="#深造" class="headerlink" title="深造"></a>深造</h3><p>好吧，过年回去已经跟家人达成协议，2018要把考研列入其中，嗯，工作之余努力读书哦，除了程序猿一职，我还有一职—-永远都是学生哈哈哈。对了，英文提高很重要，这也涉及到下面的技能提升。</p><h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>作为一个码农，自己的码农技能总得上升一个阶段吧。将javascript的使用不仅仅局限于前端。自己的工作不仅仅是前端。相关的技能是html/html5,css/css3和javascript为主，java等为辅。</p><h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><p>下面的地点选择1-2进行旅游:</p><ol><li>泰国</li><li>新疆</li><li>云南</li><li>海南</li><li>成都</li><li>杭州</li><li>北京</li><li>潮汕</li></ol><p>就此打住了，这么列下来，感觉自己2018年要累成狗。希望能完成这些模糊又肯定的目标，对了，希望在新的一年里面能够遇到对的那个人 😂</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/life/plans/2018/plan_logo.jpg&quot; alt=&quot;life/plans/2018/plan_logo.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;嗖～嗖～嗖～～～🚀现在是农历正月初六的晚上十一点多，第二天就得上班了呢，一年的时间过得真是賊快，来不及感叹2017年自己做了什么，只想着眼现在，立flag啦，鬼知道我会在新的一年会遇到什么人和事情呢。希望一年后回头看不打脸咯…&lt;/p&gt;
    
    </summary>
    
      <category term="诗和远方" scheme="http://reng99.cc/categories/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
    
      <category term="计划" scheme="http://reng99.cc/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>webpack从零构建vue项目</title>
    <link href="http://reng99.cc/2018/01/16/webpack-build-vue-project/"/>
    <id>http://reng99.cc/2018/01/16/webpack-build-vue-project/</id>
    <published>2018-01-16T03:20:37.000Z</published>
    <updated>2018-03-19T14:54:24.433Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/webpack_build_vue_project/banner.jpg" alt="frontend/webpack_build_vue_project/banner"></p><blockquote><p>看官别急  工作之余更新  预计2018.3.30(乐观的时间，因为自己时间感觉不够用)前完成本博文更新 可文末留言更新建议或打赏</p></blockquote><p>看者可以到自己几个月前搭建的一个小的<a href="https://github.com/reng99/webpack" target="_blank" rel="noopener">webapck项目</a>github仓库下简单看搭建过程啦，如果你在<a href="https://github.com/reng99/webpack" target="_blank" rel="noopener">webpack项目</a>中留颗星星那就更好了。</p><blockquote><p>本博客因为自己事情忙暂时停，完成的时间待定，望见谅…</p></blockquote><a id="more"></a><h2 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h2><p>官方描述：At its core, webpack is a static module bundler for modern JavaScript applications. When webpack processes your application, it recursively builds a dependency graph that includes every module your application needs, then packages all of those modules into one or more bundles.</p><p>鄙人的翻译：webpack的核心是现代javascript程序的静态模块打包工具。当webpack处理你的应用的时候，它会根据你的应用需要的模块递归的描绘出一个依赖图，然后打包这些模块到指定的一个或者多个文件中。</p><p>翻译不妥，还请指出。</p><h2 id="webpack核心概念"><a href="#webpack核心概念" class="headerlink" title="webpack核心概念"></a>webpack核心概念</h2><p>webpack的核心包括： 入口(entry)，出口(output)，加载器(loader)和插件(plugin)。</p><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>入口entry指明webpack应该从哪个文件开始解析去构建它内部的依赖图。入口的语法可以分为下面的这些 ：</p><p><strong>单一的入口</strong></p><p>使用方法： <code>entry: string|Array&lt;string&gt;</code></p><p>相关的demo如下 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">entry: <span class="string">'/path/to/my/entry/file.js'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p><strong>多入口（类型入口）</strong></p><p>使用方法： <code>entry:{[entryChunkName: string]: string|Array&lt;string&gt;}</code></p><p>相关的demo如下 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">entry: &#123;</span><br><span class="line">app: <span class="string">'/path/to/app.js'</span>,</span><br><span class="line">vendors: <span class="string">'/path/to/vendors.js'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出点output是告诉webpack它处理后的文件命名和文件应该存放在哪里。</p><p><strong>用法</strong></p><p>(1) 属性<code>filename</code>是用来告诉webpack输出到的文件</p><p>(2) 属性<code>path</code>是确定文件的绝对路径，一般是用path.resolve(__dirname,’directoryName’)</p><p><strong>单文件出口</strong></p><p>单文件出口就是webpack处理后只输入一个文件，demo如下: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">output: &#123;</span><br><span class="line">filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">path: <span class="string">'/path/to/project/assets'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p><strong>多文件输出</strong></p><p>如果想在多入口文件中输出对应的文件的话，就需要用到webpack带的<code>name</code>属性了，demo如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">entry: &#123;</span><br><span class="line">app: <span class="string">'/path/to/app.js'</span>,</span><br><span class="line">search: <span class="string">'/path/to/search.js'</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">filename: <span class="string">'[name].js'</span>,</span><br><span class="line">path: __dirname + '/dist'# 一般是存放在dist文件夹下啦</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行相关的命令行后，就会在<code>dist</code>文件下面看到<code>app.js和search.js</code>文件了。</p><h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><p>webpack它本身只能够识别javascript文件，那么要webpack来处理除了javascript文件之外的文件，就需要用到<code>loaders</code>了。简单来讲，<code>Loaders</code>能够转换你应用中所有类型的文件到依赖的视图里面。</p><p>在webpack的配置中，<code>Loaders</code>需要注意以下的两点:</p><p>(1) <code>test</code>属性定义哪种类型的文件应该被转换</p><p>(2) <code>use</code>属性指明哪种加载器应该用来转换文件</p><p>如下面的demo的rule字段中匹配后缀名为<code>.txt</code>的文件(假设你已经安装了raw-loader) ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const config = &#123;</span></span><br><span class="line"><span class="string">entry: '</span>/path/to/file.js<span class="string">',</span></span><br><span class="line"><span class="string">output: &#123;</span></span><br><span class="line"><span class="string">path: path.resolve(__dirname,'</span>dist<span class="string">'),</span></span><br><span class="line"><span class="string">filename: '</span>file.name.js<span class="string">'</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">module: &#123;</span></span><br><span class="line"><span class="string">rules: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">test: /\.txt$/,</span></span><br><span class="line"><span class="string">use: '</span>raw-loader<span class="string">'</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p><code>Plugin</code>范围可以从优化和压缩的方法到定义类似环境的变量。英文原话<code>Plugins range from bundle optimization and minification all the way to defining environment-like variables</code>。</p><p>如果你要使用插件，你需要使用<code>require()</code>方法将它添加到<code>plugins</code>的数组中，然后创建相关的实例。下面以<code>html-webpack-plugin</code>插件为例子(前提是你已经安装了这个插件):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">entry: <span class="string">'/path/to/entry/file.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">path: path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">filename: <span class="string">'bundle.js'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">test: <span class="string">'/\.txt$/'</span>,</span><br><span class="line">use: <span class="string">'raw-loader'</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line"><span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">template: <span class="string">'./src/index.html'</span></span><br><span class="line">&#125;)</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><h2 id="webpack项目搭建过程"><a href="#webpack项目搭建过程" class="headerlink" title="webpack项目搭建过程"></a>webpack项目搭建过程</h2><p>简单的讲解了<code>webpack</code>的核心概念，那么接下来就使用<code>webpack</code>来搭建项目吧。下面讲解整个的项目搭建的过程。😊</p><h3 id="项目的初始化"><a href="#项目的初始化" class="headerlink" title="项目的初始化"></a>项目的初始化</h3><p>通过命令行<code>npm init -y</code>的初始化项目，建议在桌面新建文件（因为后面好找啊）还有通过<code>npm init</code>进行项目的初始化（自己可以控制内容）。自己在osx系统上是经过下面的步骤建项目的，如果你使用的电脑是其他系统，有所出入，请留意。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop <span class="comment"># 进入桌面</span></span><br><span class="line">$ mkdir projectName &amp;&amp; <span class="built_in">cd</span> <span class="built_in">cd</span> projectName  <span class="comment"># 新建目录并进入</span></span><br><span class="line">$ npm init <span class="comment"># 开始初始化项目</span></span><br><span class="line">package name: as you like <span class="comment"># 填写包名称，默认projectName</span></span><br><span class="line">version: as you like <span class="comment"># 项目的版本号，默认1.0.0</span></span><br><span class="line">description: as you like  <span class="comment"># 关于项目的描述，默认为空</span></span><br><span class="line">entry point: as you like  <span class="comment"># 项目的入口文件，默认是index.js</span></span><br><span class="line"><span class="built_in">test</span> <span class="built_in">command</span>: as you like  <span class="comment"># 测试命令，默认为空</span></span><br><span class="line">git repository: relatived git repository that you like  <span class="comment"># 相关的git仓库，如果有请关联一个，这样好管理。默认为空</span></span><br><span class="line">keyword: as you like  <span class="comment"># 项目的关键词，默认为空</span></span><br><span class="line">author: your name  <span class="comment"># 项目的作者/发起人，默认为空</span></span><br><span class="line">license: license you write <span class="comment"># 相关的证书，默认是ISC</span></span><br><span class="line"></span><br><span class="line">Is this ok?(yes) <span class="comment"># 询问你设置是否确认，确认的话就按回车键。如果放弃请英文输入法输入n，再按下回车键，就放弃更改，回到最初状态了，再执行 npm init</span></span><br></pre></td></tr></table></figure><p>如果你直接执行<code>npm init -y</code>就会直接使用默认状态啦，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop</span><br><span class="line">$ mkdir projectName &amp;&amp; <span class="built_in">cd</span> projectName</span><br><span class="line">$ npm init -y</span><br><span class="line">Wrote to /Users/reng/Desktop/demo/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"projectName"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"keywords"</span>: [],</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人还是比较偏向<code>npm init</code>啦！</p><blockquote><p>有待补充</p></blockquote><h2 id="全栈项目"><a href="#全栈项目" class="headerlink" title="全栈项目"></a>全栈项目</h2><p>是什么全栈项目呢？说实在，自己还没想好 😂  看情况写或者不写</p><blockquote><p>有待补充</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack官网</a></p><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue官网</a></p><p style="color:red;text-align:center;">精力有限，未能一次性更新完,忘见谅…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/webpack_build_vue_project/banner.jpg&quot; alt=&quot;frontend/webpack_build_vue_project/banner&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;看官别急  工作之余更新  预计2018.3.30(乐观的时间，因为自己时间感觉不够用)前完成本博文更新 可文末留言更新建议或打赏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看者可以到自己几个月前搭建的一个小的&lt;a href=&quot;https://github.com/reng99/webpack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;webapck项目&lt;/a&gt;github仓库下简单看搭建过程啦，如果你在&lt;a href=&quot;https://github.com/reng99/webpack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;webpack项目&lt;/a&gt;中留颗星星那就更好了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本博客因为自己事情忙暂时停，完成的时间待定，望见谅…&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="vuejs" scheme="http://reng99.cc/tags/vuejs/"/>
    
      <category term="mvvm" scheme="http://reng99.cc/tags/mvvm/"/>
    
      <category term="webpack" scheme="http://reng99.cc/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vuex 要点</title>
    <link href="http://reng99.cc/2018/01/01/vuex/"/>
    <id>http://reng99.cc/2018/01/01/vuex/</id>
    <published>2018-01-01T11:37:35.000Z</published>
    <updated>2018-01-15T13:50:46.070Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/vuejs/vuex/vuex_banner.jpg" alt="frontend/vuejs/vuex/vuex_banner"></p><p><code>vuex</code>是一个状态管理模式，通过用户的<code>actions</code>触发事件，然后通过<code>mutations</code>去更改数据（你也可以说状态啦 -&gt; state），最后通过<code>getters</code>对状态进行获取，更改页面展示的内容。哈哈 😄 ，详细的内容请接着往下看，如有不妥请文末留言啊。原创文章，转载请注明出处。</p><a id="more"></a><p>注意 ⚠️ 文章中涉及到项目代码是使用<code>Vue</code>官方提供的脚手架<code>vue-cli</code>进行搭建的，如果看者感兴趣，可以自行用<code>vue-cli</code>搭建项目，并进行代码的验证。</p><h2 id="Vuex是什么"><a href="#Vuex是什么" class="headerlink" title="Vuex是什么"></a>Vuex是什么</h2><p>官网介绍:<code>Vuex是一个专门为Vuejs应用程序开发的状态管理模式</code>。（类似react的redux）。<code>Vuex</code>采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex在构建中大型的应用比较适用，小型的应用用组件之间的通信就可以了，小型应用用上<code>Vuex</code>就显得比较臃肿了。</p><h2 id="Vuex的安装"><a href="#Vuex的安装" class="headerlink" title="Vuex的安装"></a>Vuex的安装</h2><p>因为自己是使用<code>npm</code>来辅助开发的，所以我也只说下通过<code>npm</code>安装<code>Vuex</code>的方法。其他的安装方法，请戳<a href="https://vuex.vuejs.org/zh-cn/installation.html" target="_blank" rel="noopener">传送门</a>。</p><p>进入你项目的根目录，然后执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install vuex --save </span><br><span class="line">或</span><br><span class="line">$ npm install vuex --save-dev</span><br></pre></td></tr></table></figure><p>然后在<code>store</code>主入口的<code>javascript文件，一般是store/index.js</code>中通过<code>use</code>进行引用，前提是你已经安装了<code>vue</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import Vuex from <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><p>为了方便在各个组件中使用<code>store</code>，需要在程序的根组件中将其<code>注入</code>到每个子组件。我们需要在实例化<code>Vue</code>的时候将<code>store</code>引入（实例化<code>Vue</code>的文件一般是main.js主入口文件）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import store from <span class="string">'/path/to/store/index.js'</span></span><br><span class="line"></span><br><span class="line">const initApp =new Vue(&#123;</span><br><span class="line">store: store</span><br><span class="line">&#125;).<span class="variable">$mount</span>(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在使用<code>Vuex</code>进行开发的过程中，你可以理解核心的概念只有<code>State</code>、<code>Action</code>和<code>Mutation</code>三个，就像本文章开篇给出的截图流程那样简单明了。但是，我们使用<code>Vuex</code>开发一个应用，肯定是想要方便管理等等。这里自己按照五个核心概念来谈谈，五个核心概念也是<a href="https://vuex.vuejs.org/zh-cn/core-concepts.html" target="_blank" rel="noopener">官网</a>推荐使用的。<code>Vuex</code>的五个核心概念除了上面指出的三个之外，还包括<code>Getter</code>和<code>Module</code>两个。先一句话来概括下它们 :</p><ul><li><p>State : 数据源的存放地</p></li><li><p>Getter : store的计算属性</p></li><li><p>Mutation : 处理数据逻辑，使得数据和视图分离（同步）</p></li><li><p>Action : 类似Mutation（异步），改变状态的话，还得触发Mutation</p></li><li><p>Module : 将store分解成模块</p></li></ul><p>下面来详细讲解各个核心概念咯 😊</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p><code>Vuex</code>是使用单一状态树，一个对象就包含了全部的应用层级状态。这也就表明，一个应用仅仅包含一个<code>store</code>的实例。</p><p>状态<code>State</code>对应于<code>Vue</code>对象中的data，因为两者是对应的关系，所以在这里可以称<code>状态==数据</code>的。如下代码指出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">name: <span class="string">''</span>,</span><br><span class="line"><span class="function"><span class="title">data</span></span>() &#123; // state对应的地方</span><br><span class="line"><span class="built_in">return</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>State</code>里面存放的数据是响应式的，<code>Vue</code>组件从<code>store</code>中读取数据，若是<code>store</code>中的数据发生改变，依赖这个数据的组件也会发生更新。也就是说数据和视图是同步的。</p><p><strong>局部状态</strong></p><p>虽然说<code>Vuex</code>的<code>Store</code>仓库让我们统一管理数据变得更加方便，但是代码一多也会变得冗长和不直观。有些组件的数据是自己严格使用，我们可以将<code>state</code>放在组件自身，作为局部数据，专供此组件使用。比如现在只想在一个组件中使用<code>emotion: happiness</code>，那就不必要在<code>store</code>的<code>state</code>中进行定义了，只在本组件初始化就行了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">emotion: <span class="string">'happiness'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取状态</strong></p><p>在<code>Vue</code>组件中获取<code>store</code>中的数据（状态），最直接的就是通过计算属性获取。因为在上面我将<code>store</code>注册到根组件上了，所以在这里直接通过<code>this.$store</code>就可以调用了。比如我获取状态（state）中的<code>count: 100</code> :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">count: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapState辅助函数</strong></p><p><code>mapState</code>辅助函数把全局的<code>State</code>映射到当前组件<code>computed</code>计算属性中，即是帮助我们生成计算属性。简化我们的代码操作，不需要使用<code>this.$store.state</code>获取了。以上面状态（state）中的<code>count: 100</code>为例子 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span> <span class="comment">// 注意别漏了引入</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">computed: </span><br><span class="line">mapState(&#123;</span><br><span class="line">count: <span class="function"><span class="params">state</span> =&gt;</span> state.count</span><br><span class="line">&#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>上面的<code>state</code>中我们了解到，在<code>store</code>仓库里，<code>state</code>是用来存储数据的。在多个组件中要进行使用同一种状态的话，对数据进行简单操作，我们可以通过在组件的computed中进行获取<code>this.$store.state.theDataName</code>。简单操作没问题，但是，我们进行其他的操作，比如<code>过滤操作</code>，我们就得写一堆的代码 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">filterData: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.$store.state.theDataName.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="comment">// do something ...</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在每个组件中复制这一大堆的代码，或者你单独新建一个文件把代码写进入，每个组件都引入（如果你不觉得很麻烦的话）。</p><p>而<code>Getter</code>可以把组件中共享状态抽取出来，这也是<code>Getter</code>存在的意义。我们可以认为，<code>Getter</code>是<code>Store</code>的计算属性。</p><p><strong>如何使用Getter</strong></p><p>为了方便管理，需要一个单独的<code>getters.js</code>的文件，假如已经有对数据进行过滤的函数了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">filterDatas (state,getter,rootState) &#123;</span><br><span class="line"><span class="comment">// do something ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么只要在相关的组件的<code>computed</code>中引入就可以了，是不是很方便啊 ：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">filterItems: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.filterDatas;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>mapGetters辅助函数</strong></p><p> <code>mapGetters</code>辅助函数仅仅是将<code>store</code>中的<code>getter</code>映射到局部计算属性，看情况使用，类似<code>mapState</code>。下面使用<code>mapGetter</code>改写上面的<code>filterItems</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span> <span class="comment">// 记得引入</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">computed: </span><br><span class="line">mapGetters(&#123;</span><br><span class="line"> filterItems: <span class="string">'filterDatas'</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p><a href="https://vuex.vuejs.org/zh-cn/mutations.html" target="_blank" rel="noopener">Vuex的中文官网</a>中明确指出<code>更改Vuex的store中的状态（state）的唯一的方法是提交mutation</code>。</p><p><code>Mutation</code>可以理解为：在<code>Mutation</code>里面装着一些改变数据方法的集合。即把处理数据逻辑方法全部放在<code>Mutation</code>里面，使得数据和视图分离。</p><p><strong>使用Mutation</strong></p><p><code>Mutation</code>的结构：每个mutation都有一个字符串的<code>事件类型(type)</code>和一个<code>回调函数(handler)</code>也可以理解为<code>{type:handler()}</code>，这和订阅发布有点类似。先是注册事件，当触发响应类型的时候调用<code>handle()</code>，调用<code>type</code>的时候需要用到<code>store.commit(&#39;typeName&#39;)</code>方法。比如我想在要触发<code>mutations.js</code>中的<code>INCREASE</code>处理函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutations.js</span></span><br><span class="line"><span class="keyword">const</span> INCREASE = <span class="string">'INCREASE'</span>; <span class="comment">// 不能漏</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">[INCREASE](state,data)&#123;</span><br><span class="line"><span class="comment">// change the state ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我注册了<code>store</code>到根组件，那么在<code>.vue</code>组件中就可以通过<code>this.$store.commit(&#39;INCREASE&#39;)</code>触发这个改变相关状态的处理函数了。如果在<code>actions.js</code>中调用，直接使用提供的<code>commit</code>参数进行<code>commit(&#39;INCREASE&#39;)</code>触发处理函数。</p><p><strong>提交载荷（Payload）</strong></p><p>可以向<code>store.commit</code>传入额外的参数，参数一般为<code>object</code>类型。我这里接着上面的示例，组件触发的时候传入一个<code>100</code>的数字到<code>data</code>里面 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">increase: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'INCREASE'</span>,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用mutation-types.js</strong></p><p>使用<code>mutation-types.js</code>(名称可根据爱好随便取)是为了方便管理项目<code>mutation</code>的类型。<a href="https://www.zhihu.com/question/58164683/answer/285394955" target="_blank" rel="noopener">我在知乎上也回答过为什么要使用mutation-types.js</a>，当然你完全没必要使用它，不过我自己喜欢使用它。将<code>使用mutation</code>内容中的<code>mutations.js</code>代码拆分为两部分，一部分是<code>mutation-types.js</code>，另一部分是<code>mutations.js</code>，示范如下 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREASE = <span class="string">'INCREASE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutations.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREASE&#125; <span class="keyword">from</span> <span class="string">'/path/to/mutation-type.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">[INCREASE](state,data)&#123;</span><br><span class="line"><span class="comment">// change the state ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapMutations辅助函数</strong></p><p>为了简化你的代码量，使得代码看起来逼格更高点，你可以使用<code>mapMutations</code>辅助函数将组件中的<code>methods</code>映射为<code>store.commit</code>调用(需要在根节点注入store哦)。demo来映射上面的<code>increase</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapMutations&#125; <span class="keyword">from</span> <span class="string">'vuex'</span> <span class="comment">// 不能漏哦</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">...mapMutations([</span><br><span class="line"><span class="string">'INCREASE'</span></span><br><span class="line">])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action 类似于 Mutation，不同点是 ：</p><ul><li><p>Action提交的是 mutation，而不是直接变更状态</p></li><li><p>Action是异步的，而Mutation是同步的</p></li></ul><p>详细的相似点可以回滚看<code>Mutation</code>的啦，或者直接戳<a href="https://vuex.vuejs.org/zh-cn/actions.html" target="_blank" rel="noopener">vue官网Store</a></p><p><strong>组件内分发Action</strong></p><p>因为我在全局组件中挂载了<code>store</code>，所以引用就可以这样写 -&gt; <code>this.$store.dispatch(&#39;dispatchEvent&#39;)</code>，当然你可以传参过去啦。比如：<code>this.$store.dispatch(&#39;dispatchEvent&#39;,param)</code>，param一般是obj类型的。</p><p><strong>mapActions辅助</strong></p><p>为了简化操作，Action像Mutaion一样有一个映射的函数<code>mapActions</code>。使用方法也类似Mutation，demo如下 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapActions&#125; <span class="keyword">from</span> <span class="string">'vuex'</span> <span class="comment">// 不能漏哦</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">...mapActions([</span><br><span class="line"><span class="string">'INCREASE'</span></span><br><span class="line">])</span><br><span class="line">或</span><br><span class="line">...mapActions([</span><br><span class="line">increase: <span class="string">'INCREASE'</span></span><br><span class="line">])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>由于vue中使用单一的状态树，当管理的项目中大型的时候，所有的状态都集中在一个对象中会变得比较复杂，难以管理，显得项目比较臃肿。为了解决这些问题，我们可以使用<code>vuex提供的Module功能</code>，将store分割成模块。每个模块都有自己的state、mutation、action、getter。现在假设你的应用的功能包括<code>登录和音乐</code>两个功能模块页面，那么store的结构可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- module</span><br><span class="line">- music</span><br><span class="line">actions.js</span><br><span class="line">getters.js</span><br><span class="line">index.js// music module 的入口文件</span><br><span class="line">mutations.js</span><br><span class="line">state.js</span><br><span class="line">- user</span><br><span class="line">actions.js</span><br><span class="line">getters.js</span><br><span class="line">index.js// user module的入口文件</span><br><span class="line">mutations.js</span><br><span class="line">state.js</span><br><span class="line">actions.js</span><br><span class="line">index.js// store 的入口文件</span><br><span class="line">mutation-types.js// 管理所有的mutations</span><br><span class="line">mutations.js</span><br><span class="line">state.js</span><br></pre></td></tr></table></figure><p><strong>模块的局部状态</strong></p><p>对于模块内部的mutation，接收的第一个参数是<code>state</code>，也就是接收本模块的局部状态，比如上面的music模块，我在其state.js中写上 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">music: &#123;</span><br><span class="line">list: [],</span><br><span class="line">total: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在同级的<code>mutations.js</code>中有 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../../mutation-types'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">[types.UPDATE_MUSIC](state,data)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(state.music.total);<span class="comment">// 打印出100</span></span><br><span class="line">...other handle</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命名空间</strong></p><p>默认情况下，模块<code>内部</code>的action、mutation 和 getter是注册在全局命名空间的 -&gt; 这样使得多个模块能够对mutation和action作出响应。</p><p>如果看者希望你写的模块具有更高的封装度和复用性，你可以通过添加<code>namespaced:true</code>的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。比如上面的music模块 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">'./state'</span>     <span class="comment">//state</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">'./getters'</span> <span class="comment">//getters</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span>    <span class="comment">//actions</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span>     <span class="comment">//mutations</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//modules</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">namespaced: <span class="literal">true</span>, <span class="comment">// 添加命名空间</span></span><br><span class="line">state,</span><br><span class="line">getters,</span><br><span class="line">actions,</span><br><span class="line">mutations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的情况请戳<a href="https://vuex.vuejs.org/zh-cn/modules.html" target="_blank" rel="noopener">vuex官网modules</a></p><h2 id="store结构"><a href="#store结构" class="headerlink" title="store结构"></a>store结构</h2><p><a href="https://vuex.vuejs.org/zh-cn/structure.html" target="_blank" rel="noopener">vuex的官网谈项目结构</a>，我这里谈<code>store结构</code>，因为我觉得每个人的项目的结构布局有所不同，但是<code>vuex</code>可以是一个模版化的使用。当然，这模版化的使用遵循了官网所定的规则：</p><ul><li><p>应用层级的状态应该集中在单个 store对象中</p></li><li><p>提交mutation是更改状态（state）的唯一方法，并且这个过程是同步的</p></li><li><p>异步逻辑都应该封装到action里面</p></li></ul><p>整理的store结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── ...</span><br><span class="line">│</span><br><span class="line">└── store</span><br><span class="line">├── actions.js// 根级别的 action</span><br><span class="line">├── index.js// 我们组装模块并导出 store 的地方</span><br><span class="line">├── mutation-types.js// store所有mutations管理</span><br><span class="line">├── mutations.js// 根级别的 mutation</span><br><span class="line">├── state.js// 根级别的 state</span><br><span class="line">└── modules</span><br><span class="line">├── moduleA</span><br><span class="line">├── moduleB</span><br><span class="line">└── moduleC</span><br><span class="line">├── actions.js  // moduleC 的 action</span><br><span class="line">├── getters.js// moduleC 的 getter</span><br><span class="line">├── index.js// moduleC 的 入口</span><br><span class="line">├── mutations.js// moduleC 的 mutation</span><br><span class="line">└── state.js// moduleC 的 state</span><br></pre></td></tr></table></figure><p>上面的结构比较通用，模版化，我在接下来的<code>完整小项目</code>中就是使用上面的<code>store结构</code>来管理啦 😝</p><h2 id="完整小项目"><a href="#完整小项目" class="headerlink" title="完整小项目"></a>完整小项目</h2><p>自己在上面讲了一大推的<del>废话</del>，嗯哈，为了证明那不是<del>废话</del>，下面就结合上面讲的知识点来一个综合的<code>min-demo</code>吧，欢迎指正啊！ @~@</p><h3 id="是什么项目呢"><a href="#是什么项目呢" class="headerlink" title="是什么项目呢"></a>是什么项目呢</h3><p>思来想去，自己还是觉得做一个简单版本的<code>todo</code>项目好点，理由如下：</p><ul><li><p>个人时间精力邮箱(main reason)</p></li><li><p>todo项目 -&gt; 麻雀虽小，五脏俱全</p></li></ul><p>项目包含一个简单的登录页面，然后跳转到<code>todo小项目</code>的页面。如图所示：</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/vuejs/vuex/min-demo-login.png" alt="frontend/vuejs/vuex/min-demo-login"></p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/vuejs/vuex/min-demo-todo.png" alt="frontend/vuejs/vuex/min-demo-todo"></p><p>在登录页面，会要求你填写非空的内容进入，我这里填了自己的名字啦。在<code>todo页面</code>，你就需要在输入框输入你要做的事情啦，事情的添加默认是未做的状态。当然，允许进行时间的状态进行设置和事件的删除啦。成品可查看下面最终的效果<code>gif动效</code>，就酱 @～@</p><h3 id="项目的初始化"><a href="#项目的初始化" class="headerlink" title="项目的初始化"></a>项目的初始化</h3><p>⚠️ 本项目在mac系统上使用<code>vue-cli</code>的基础上搭建<code>(搭建日期2018.01.14)</code>的小项目，其完整的覆盖了vue的全家桶了 -&gt; 使用的vue版本是<code>^2.5.2</code>，vuex的版本是<code>^3.0.1</code>，vue-router的版本也是<code>^3.0.1</code>。如果你使用低版本，请参考低版本的相关说明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装 vue-cli</span></span><br><span class="line">$ npm install --global vue-cli</span><br><span class="line"><span class="comment"># 进入桌面</span></span><br><span class="line">$ <span class="built_in">cd</span> desktop</span><br><span class="line"><span class="comment"># 初始化项目min-demo</span></span><br><span class="line">$ vue init webpack min-demo</span><br><span class="line"></span><br><span class="line">? Project name min-demo<span class="comment"># 项目名称</span></span><br><span class="line">? Project description A Vue.js project<span class="comment"># 项目描述</span></span><br><span class="line">? Author reng99  <span class="comment"># 项目作者</span></span><br><span class="line">? Vue build standalone</span><br><span class="line">? Install vue-router? Yes<span class="comment"># 是否使用路由</span></span><br><span class="line">? Use ESLint to lint your code? No<span class="comment"># 是否启动语法检查</span></span><br><span class="line">? Set up unit tests No<span class="comment"># 是否配置单元测试</span></span><br><span class="line">? Setup e2e tests with Nightwatch? No<span class="comment"># 是否配置集成测试</span></span><br><span class="line">? Should we run `npm install` <span class="keyword">for</span> you after the project has been created? (recom</span><br><span class="line">mended) npm<span class="comment"># 选择那种包管理工具进行安装依赖，共三种选择：npm,yarn,no thanks 我选择了npm</span></span><br><span class="line"></span><br><span class="line">   vue-cli · Generated <span class="string">"min-demo"</span>.</span><br><span class="line"><span class="comment"># 等待安装依赖的完成</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 进入项目</span></span><br><span class="line">$ <span class="built_in">cd</span> min-demo</span><br><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line">$ npm run dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果一切正常，就会在浏览器的http://localhost:8080的地址页面有相关的vue界面展示出来</span></span><br></pre></td></tr></table></figure><p>当然，使用脚手架搭建的项目，没有自动集成<code>vuex</code>，这就需要你进入项目的根目录，执行<code>npm install vuex --save</code>命令来安装啦。</p><h3 id="项目的实现"><a href="#项目的实现" class="headerlink" title="项目的实现"></a>项目的实现</h3><p>嗯嗯，下面我将改写在<code>vue-cli</code>搭建的项目，以符合我自己期望。改写的代码就不全给出来了啊，关键的项目代码还是会贴一下的。😝</p><p>这个项目的结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build/<span class="comment">#webpack 的配置项</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── config/</span><br><span class="line">│   ├── index.js<span class="comment"># 项目的主要配置</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── node_modules/<span class="comment"># 相关依赖</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.js<span class="comment"># 应用的主入口</span></span><br><span class="line">│   ├── App.vue     <span class="comment"># 引用的根组件</span></span><br><span class="line">│   ├── components/ </span><br><span class="line">│   │   ├── Login.vue<span class="comment"># 登录组件</span></span><br><span class="line">│   │   └── Todo.vue<span class="comment"># todo组件</span></span><br><span class="line">│   ├── store/ </span><br><span class="line">│   │   ├── modules/<span class="comment"># todo组件</span></span><br><span class="line">│   │   │  └── todo</span><br><span class="line">│   │   │      ├── actions.js<span class="comment"># todo的actions</span></span><br><span class="line">│   │   │      ├── getters.js<span class="comment"># todo的getters</span></span><br><span class="line">│   │   │      ├── index.js<span class="comment"># todo的入口</span></span><br><span class="line">│   │   │      ├── mutations.js<span class="comment"># todo的mutations</span></span><br><span class="line">│   │   │      └── state.js<span class="comment"># todo的状态</span></span><br><span class="line">│   │   ├── actions.js<span class="comment"># 根actions</span></span><br><span class="line">│   │   ├── index.js<span class="comment"># store入口文件</span></span><br><span class="line">│   │   ├── mutation-types.js<span class="comment"># 整个store中的mutation的管理</span></span><br><span class="line">│   │   ├── mutations.js<span class="comment"># 根mutations</span></span><br><span class="line">│   │   └── state.js<span class="comment"># 根的状态</span></span><br><span class="line">│   ├── router/ </span><br><span class="line">│   │   └── index.js<span class="comment"># 路由文件</span></span><br><span class="line">│   └── assets/<span class="comment">#  模块的资源</span></span><br><span class="line">│       └── ...</span><br><span class="line">├── static/  <span class="comment"># 静态资源存放的地方</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── .babelrc                    <span class="comment"># 语法转换babel的相关配置</span></span><br><span class="line">├── .editorconfig<span class="comment"># 编辑器IDE的相关配置</span></span><br><span class="line">├── .gitignore                  <span class="comment"># 提交到github忽略的内容配置</span></span><br><span class="line">├── .postcssrc.js               <span class="comment"># css的处理配置postcssrc</span></span><br><span class="line">├── index.html                  <span class="comment"># index html模版</span></span><br><span class="line">├── package.json                <span class="comment"># 相关的执行命令和依赖配置</span></span><br><span class="line">└── README.md                   <span class="comment"># 项目的说明文件</span></span><br></pre></td></tr></table></figure><p>⚠️ 项目重点在<code>src</code>文件夹内</p><p>在<code>/src/components/Login.vue</code>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"login"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">'login'</span>&gt;</span><br><span class="line">      &lt;div class=<span class="string">'login-title'</span>&gt;简单模拟登录&lt;/div&gt;</span><br><span class="line">      &lt;div class=<span class="string">'login-body'</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">'hint'</span> v-show=<span class="string">'hintFlag'</span>&gt;输入的文字不能为空&lt;/div&gt;</span><br><span class="line">        &lt;input placeholder=<span class="string">'请输入任意文字...'</span> <span class="built_in">type</span>=<span class="string">'text'</span> v-model=<span class="string">'loginTxt'</span>/&gt;</span><br><span class="line">        &lt;div class=<span class="string">"btn"</span> @click=<span class="string">'login'</span>&gt;登录&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Login'</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      hintFlag: <span class="literal">false</span>,</span><br><span class="line">      loginTxt: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">login</span></span> () &#123;</span><br><span class="line">      var vm = this;</span><br><span class="line">      <span class="keyword">if</span>(vm.loginTxt.trim()==<span class="string">''</span>)&#123;</span><br><span class="line">        vm.hintFlag = <span class="literal">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        // 进入todo的页面</span><br><span class="line">        vm.hintFlag = <span class="literal">false</span>;</span><br><span class="line">        // 触发获取登录名</span><br><span class="line">        vm.<span class="variable">$store</span>.dispatch(<span class="string">'createUsername'</span>,vm.loginTxt);</span><br><span class="line">        vm.<span class="variable">$router</span>.push(<span class="string">'/todo'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch:&#123;</span><br><span class="line">    loginTxt(curVal)&#123;</span><br><span class="line">      var vm = this;</span><br><span class="line">      <span class="keyword">if</span>(curVal.trim()==<span class="string">''</span>)&#123;</span><br><span class="line">        vm.hintFlag = <span class="literal">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        vm.hintFlag = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=<span class="string">'less'</span>&gt;</span><br><span class="line">  <span class="comment">#login&#123;</span></span><br><span class="line">    margin-top: 100px;</span><br><span class="line">    .login&#123;</span><br><span class="line">      width: 400px;</span><br><span class="line">      margin: 0 auto;</span><br><span class="line">      &amp;-title&#123;</span><br><span class="line">        color: <span class="comment">#999;</span></span><br><span class="line">        font-size: 22px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        margin-bottom: 20px;</span><br><span class="line">      &#125;</span><br><span class="line">      &amp;-body&#123;</span><br><span class="line">        width: 360px;</span><br><span class="line">        padding: 40px 20px 60px 20px;</span><br><span class="line">        background: <span class="comment">#ededed;</span></span><br><span class="line">        input&#123;</span><br><span class="line">          width: 100%;</span><br><span class="line">          display: block;</span><br><span class="line">          height: 40px;</span><br><span class="line">          text-indent: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .btn&#123;</span><br><span class="line">          width: 100%;</span><br><span class="line">          text-align: center;</span><br><span class="line">          height: 40px;</span><br><span class="line">          line-height: 40px;</span><br><span class="line">          background: <span class="comment">#09c7d1;</span></span><br><span class="line">          color: <span class="comment">#fff;</span></span><br><span class="line">          margin-top: 20px;</span><br><span class="line">          cursor: pointer;</span><br><span class="line">        &#125;</span><br><span class="line">        .hint&#123;</span><br><span class="line">          color: red;</span><br><span class="line">          font-size: 12px;</span><br><span class="line">          text-align: center;</span><br><span class="line">          padding-bottom: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在上面的组件中，自己原封不动的将里面的代码复制过来了，你应该可以看出，这个<code>.vue</code>文件中结合了三块的东西，分别是<code>html</code>的模版、<code>javascript</code>代码和运用less预处理器编写的<code>css</code>代码。</p><p>在<code>/src/components/Todo.vue</code>组件的结构依旧是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"todo"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">'username'</span>&gt;欢迎您！&lt;span&gt;&#123;&#123;username&#125;&#125;&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;</span><br><span class="line">      &lt;div class=<span class="string">"input"</span>&gt;</span><br><span class="line">        &lt;input placeholder=<span class="string">'请输入要做的事情...'</span> <span class="built_in">type</span>=<span class="string">'text'</span> v-model=<span class="string">'eventTxt'</span>/&gt;</span><br><span class="line">        &lt;button @click=<span class="string">"addEvent"</span>&gt;增加&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'ToDo'</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      noDataFlag: <span class="literal">true</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span></span>()&#123;</span><br><span class="line">    var vm = this;</span><br><span class="line">    <span class="keyword">if</span>(vm.username == <span class="string">''</span>)&#123;</span><br><span class="line">      vm.<span class="variable">$router</span>.push(<span class="string">'/'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">username</span></span>()&#123;</span><br><span class="line">      <span class="built_in">return</span> this.<span class="variable">$store</span>.getters.username;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    delEvent (id) &#123;</span><br><span class="line">      this.<span class="variable">$store</span>.dispatch(<span class="string">'delEvent'</span>,id);</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  watch:&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=<span class="string">'less'</span>&gt;</span><br><span class="line">  <span class="comment">#todo&#123;</span></span><br><span class="line">    margin-top: 100px;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在路由的文件中，因为知识涉及了两个页面的路由跳转，这里也全贴出来吧 –</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'@/components/Login'</span></span><br><span class="line"><span class="keyword">import</span> ToDo <span class="keyword">from</span> <span class="string">'@/components/ToDo'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'Login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/todo'</span>,</span><br><span class="line">      name: <span class="string">'ToDo'</span>,</span><br><span class="line">      component: ToDo</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>关于<code>store</code>，这是一个重点，我打算详细说啦。首先当然得从整个<code>store</code>的入口文件讲起啦。在<code>store/index.js</code>中，我是这样引用的 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span><span class="comment">// 引入vue依赖</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'Vuex'</span><span class="comment">// 引入vuex依赖</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">'./state'</span><span class="comment">// 引入根状态</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span><span class="comment">// 引入根actions</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span><span class="comment">// 引入根mutations</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> todo <span class="keyword">from</span> <span class="string">'./modules/todo/index'</span><span class="comment">// 引入todo模块</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)<span class="comment">// 引入vuex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  modules:&#123;</span><br><span class="line">    todo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在根的<code>store</code>的<code>mutation-types.js</code>文件中，管理着整个项目的状态管理函数 –&gt; 包括创建用户名、添加要做的事情、删除创建的事情、显示事件的状态(全部，已经做，没有做)和标记事件(已经做的事件标记为未做，未做的事件标记为已经做)。代码展示如下 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CREATE_USERNAME = <span class="string">'CREATE_USERNAME'</span>  <span class="comment">// 创建用户名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_EVENT = <span class="string">'ADD_EVENT'</span>  <span class="comment">// 添加事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DEL_EVENT = <span class="string">'DEL_EVENT'</span>  <span class="comment">// 删除事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ALL_EVENT = <span class="string">'ALL_EVENT'</span>  <span class="comment">// 全部事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UNDO_EVENT = <span class="string">'UNDO_EVENT'</span>  <span class="comment">// 没做事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DONE_EVENT = <span class="string">'DONE_EVENT'</span>  <span class="comment">// 已做事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MARK_UNDONE = <span class="string">'MARK_UNDONE'</span> <span class="comment">// 标记为未做</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MARK_DONE = <span class="string">'MARK_DONE'</span> <span class="comment">// 标记为已做</span></span><br></pre></td></tr></table></figure><p><code>store/state.js</code>的作用在你听完<code>store/todo/state.js</code>的讲解后你应该会明白。在模块<code>todo</code>的state中，自己定义了此模块的相关的数据结构，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 事件列表</span></span><br><span class="line">  list:[</span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//   id: 0,  相关的id</span></span><br><span class="line">    <span class="comment">//   content:'',  // 事件的内容</span></span><br><span class="line">    <span class="comment">//   flag: 1 // 是否完成,1是完成，0是未完成</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  ],</span><br><span class="line">  allList:[],</span><br><span class="line">  increase: <span class="number">0</span>,</span><br><span class="line">  total: <span class="number">0</span>,</span><br><span class="line">  done: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的这些数据结构，你可以说是状态吧，是为了给<code>mutation和getters</code>进行操作。对了，你也许注意到了<code>store</code>根目录中没有<code>getters.js</code>文件。因为，这是分散模块管理项目，为什么还需要呢，如果你想保留，你可以自己新建一个，按照自己的习惯进行管理项目呗。</p><p>上个段落以及前面某部分内容已经谈及了<code>mutations</code>的作用，本项目中使用mutation就是为了改变自己在<code>todo/state.js</code>定义的状态，比如改变<code>allList:[]</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../../mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  [types.ADD_EVENT] (state,data)&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">      id: state.increase++,</span><br><span class="line">      content: data,</span><br><span class="line">      flag: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    state.allList.push(obj);</span><br><span class="line">    state.list = state.allList;</span><br><span class="line">    state.total = state.allList.length;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>todo/getter.js</code>就是为了将<code>vuex</code>中的状态获取，方便显示在页面的啦，在本项目中，自己超级简单的使用了下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  list (state,getters,rootState) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.list;</span><br><span class="line">  &#125;,</span><br><span class="line">  username (state,getters,rootState) &#123;</span><br><span class="line">    <span class="keyword">return</span> rootState.username;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个是关于<code>todo/actions.js</code>，这是页面中的用户的事件去发送事件，使得产生<code>mutations</code>去改变状态(state.js)，最终使得页面展示的内容(getters)发生改变。这里以一个派遣添加事件为例子 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../../mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addEvent = <span class="function">(<span class="params">&#123;commit,state,rootState&#125;,query</span>) =&gt;</span> &#123;</span><br><span class="line">  commit(types.ADD_EVENT,query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，整篇文章都说整个store是挂载在根组件上的，那么是在哪里呢？答案就是<code>src/main.js</code>文件啦，文件内的代码如下 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="最终的效果"><a href="#最终的效果" class="headerlink" title="最终的效果"></a>最终的效果</h3><p>好吧，自己利用了一个下午搭建项目并简单思考了相关的逻辑，简单实现项目，其最终的效果如下<code>gif动图</code>啦 :</p><p><img src="http://omu538iq8.bkt.clouddn.com/frontend/vuejs/vuex/min-demo.gif" alt="frontend/vuejs/vuex/min-demo"></p><p>嗯，项目是不是很简单，所以就不放源码上去了 😂 。其实自己觉得源码实现不够严谨啦，毕竟只是花了短短一个下午和晚上从设计到实现… 逃：）</p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://vuex.vuejs.org/" target="_blank" rel="noopener">vuex官网</a></p><p style="color:red;text-align:center;">（ 完 @~@ ）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/vuejs/vuex/vuex_banner.jpg&quot; alt=&quot;frontend/vuejs/vuex/vuex_banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vuex&lt;/code&gt;是一个状态管理模式，通过用户的&lt;code&gt;actions&lt;/code&gt;触发事件，然后通过&lt;code&gt;mutations&lt;/code&gt;去更改数据（你也可以说状态啦 -&amp;gt; state），最后通过&lt;code&gt;getters&lt;/code&gt;对状态进行获取，更改页面展示的内容。哈哈 😄 ，详细的内容请接着往下看，如有不妥请文末留言啊。原创文章，转载请注明出处。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="vuejs" scheme="http://reng99.cc/tags/vuejs/"/>
    
      <category term="mvvm" scheme="http://reng99.cc/tags/mvvm/"/>
    
  </entry>
  
  <entry>
    <title>第二届前端体验大会 -- 本固枝荣</title>
    <link href="http://reng99.cc/2017/12/24/2ndTencent-frontend-meeting/"/>
    <id>http://reng99.cc/2017/12/24/2ndTencent-frontend-meeting/</id>
    <published>2017-12-24T03:31:10.000Z</published>
    <updated>2017-12-31T11:42:03.746Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/banner.jpg" alt="meeting/tencent_20171223/banner"></p><p>第二届前端体验大会，是至今为止，我参加的最棒的一次前端体验大会，不枉我从广州过去深圳啊。<del>目前只参加过一次大型的前端体验大会</del> 😝。在一天的时间里面，自己收获到了很多的东西。作为一个非典型的程序员，杂七杂八的就不谈了，还是谈技术来得简单粗暴一点。</p><a id="more"></a><h2 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h2><p>本会议的主题是<code>本固枝荣</code>，开场白的彪叔已经很好的解释了主题：基础牢固，才能更好的玩转前端（概括起来就这样吧）。在开场白的时候，彪叔介绍的前端的前三年的调查报告，着实让我一惊 -&gt; 原来前端的市场是酱紫啊，作为一个涉水不深的前端菜鸡来说，还是可以定m个小目标的。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/biaoshu_skills.jpg" alt="meeting/tencent_20171223/biaoshu_skills"></p><h2 id="一个UI的自我修养"><a href="#一个UI的自我修养" class="headerlink" title="一个UI的自我修养"></a>一个UI的自我修养</h2><p>腾讯的QQ音乐的设计天团研发经理主要是针对<code>一个UI开发的自我修养</code>来讲述了前端开发人员需要有发现问题，定位问题，解决问题的能力（概括不到位的话，大佬不要怂我 😂 ）。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaojian_skills.jpg" alt="meeting/tencent_20171223/xiaojian_skills"></p><h2 id="感知性能优化"><a href="#感知性能优化" class="headerlink" title="感知性能优化"></a>感知性能优化</h2><p>在众多嘉宾分享的话题中，我最喜欢的就是潇滨前辈讲解的<code>感知性能优化</code>的话题。在前端开发中，我们需要对自己做出来的产品进行优化，怎么进行优化呢，前辈经过三个层次进行说明：<code>资源感知</code>，<code>代码感知</code>和<code>用户感知</code>。这里也推荐雅虎的七个领域的35条优化原则，请戳<a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">传送门</a><br><strong>资源感知</strong>我们写的页面的<code>img,js,html,css</code>等都可以成为资源，我们在优化的时候，需要考虑到控制请求，控制资源的大小，控制缓存等。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaobin_skills_resource.jpg" alt="meeting/tencent_20171223/xiaobin_skills_resource"></p><p><strong>感知代码</strong>在代码的层面，我们可以通过对请求加载数进行延迟或者按需加载来控制代码。一个产品的首页首次渲染很是重要，在代码层面对样式的前置，js后置等进行优化。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaobin_skills_code01.jpg" alt="meeting/tencent_20171223/xiaobin_skills_code01"></p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaobin_skills_code02.jpg" alt="meeting/tencent_20171223/xiaobin_skills_code02"></p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaobin_skills_code03.jpg" alt="meeting/tencent_20171223/xiaobin_skills_code03"></p><p><strong>用户感知</strong>用户在产品中起到至关重要的作用，也许你的产品在电脑的模拟器上没有什么问题。但是是真的没有问题吗？这就需要站到用户的角度进行思考，如果用户的使用的网络是3g的怎么样等等。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaobin_skills_user.jpg" alt="meeting/tencent_20171223/xiaobin_skills_user"></p><p>整个感知优化的流程，可以用大佬ppt里面的图片进行总结，如下:</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/xiaobin_skills_process.jpg" alt="meeting/tencent_20171223/xiaobin_skills_process"></p><h2 id="那些年我们所遗忘的XSS黑魔法"><a href="#那些年我们所遗忘的XSS黑魔法" class="headerlink" title="那些年我们所遗忘的XSS黑魔法"></a>那些年我们所遗忘的XSS黑魔法</h2><p>至于前端方面的安全，<code>志龙</code>前辈演示了xss的黑魔法，自己一脸懵逼，因为接触前端安全这一块一直是个梗。在xss黑魔法中，哪里有用户输入，哪里就可能有前端的安全漏洞，当然，前辈不仅演示了如何攻击，还演示了如何防攻啦。自己很想加入他们的团队，貌似能力不足啊…</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/zhilon_part.jpg" alt="meeting/tencent_20171223/zhilon_part"></p><h2 id="前端监控系统"><a href="#前端监控系统" class="headerlink" title="前端监控系统"></a>前端监控系统</h2><p>监控系统是<code>幸福生活的保障</code>。一个产品的异常都需要进行监控，这些就是问题的来源。监控系统对异常进行监控，进行错误信息自动上报，性能数据自动上报，进行数据的打点，最终显示出系列告警的错误日志数据。<code>郑超</code>前辈指出<code>人</code>是监控系统的关键组成部分。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/zhengchao_part01.jpg" alt="meeting/tencent_20171223/zhengchao_part01"></p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/zhengchao_part02.jpg" alt="meeting/tencent_20171223/zhengchao_part02"></p><h2 id="跨界-成长：非典型程序员之路"><a href="#跨界-成长：非典型程序员之路" class="headerlink" title="跨界-成长：非典型程序员之路"></a>跨界-成长：非典型程序员之路</h2><p><code>某磊</code>前辈作为全场嘉宾中唯一一个文科生<del>（自己猜的）</del>出身的程序猿。在会场上分享了自己如何在<code>钱途</code>[逃：)]和<code>热情</code>的支撑下成为前端大神的经历。很喜欢他会场的一句话：<code>你生命中的每个点（经历的事），在你生命的某一个时刻终将连成线</code>。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/luolei_part.jpg" alt="meeting/tencent_20171223/luolei_part"></p><p>作为一个非典型的程序猿，你的世界不应该只有代码和办公室，你应该到处走走。美妙的代码只是你生命中的一部分，生命中其他美妙的部分等待着你去发现、挖掘。嗯，我也是一个非典型的程序猿，打代码仅仅是人生乐趣的一部分。 😊 </p><h2 id="高性能React替代方案"><a href="#高性能React替代方案" class="headerlink" title="高性能React替代方案"></a>高性能React替代方案</h2><p>现在前端比较热门的框架有三个，分别是<code>react</code>、<code>vue</code>和<code>angular</code>。京东的<code>某澈</code>前辈对三种框架进行了比较选择了react。然后基于他们京东的产品和业务，对react进行了改写，支持<code>IE8</code>版本等，他们改写<code>react</code>的<code>github仓库</code>请戳<a href="https://github.com/NervJS/nerv" target="_blank" rel="noopener">传送门</a>。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/yuche_part.jpg" alt="meeting/tencent_20171223/yuche_part"></p><p>每个公司的情况不同，我们的大佬就选择了<code>vue</code>。经过一年的<code>vue</code>的锻炼，自己貌似已经把<code>react</code>知识点忘记了。但愿<code>react</code>别来个变脸 -&gt; 改协议了…</p><h2 id="如何开发知晓榜工具类第一的小程序"><a href="#如何开发知晓榜工具类第一的小程序" class="headerlink" title="如何开发知晓榜工具类第一的小程序"></a>如何开发知晓榜工具类第一的小程序</h2><p>最后一位分享嘉宾是<code>某博</code>前辈讲的微信小程序。因为自己没开发过微信小程序，听不懂他在讲啥（我的锅），全程感觉就是围绕<code>websocket</code>和使用场景规模来讲。</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/libo_part.jpg" alt="meeting/tencent_20171223/libo_part"></p><p>如果需要学习微信小程序的时候只能靠后期了，也许找的资源比他讲解的还好(幻想中…)</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>会议的结尾，本会议的负责任<code>某帅</code>讲了自己的进入腾讯的幸酸的经历。嗯，是半开玩笑的那种。然后就是很形式的会议的闭幕的发言啦，感觉可以忽略。如果让自己用一个字还总结这次会议的话，那就是<code>棒</code>；两个字的话，那就是<code>很棒</code>；三个字的话，那就是<code>非常棒</code>。感谢主办方的精彩呈现 👏</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>作为一个非典型的程序猿，好吧，我说下参加本次会议的其他点吧：</p><ul><li><p>嗯，主持人很会带气氛的说，特别是男的主持人(会场一对主持人，男帅女靓)，怂一下主持人 -&gt; 会场总说自己穷，穷的人在这里还没说话呢 😢</p></li><li><p>腾讯的工作环境真是超级棒的，能在这里工作是多么的幸福呢，希望自己有机会进入腾讯工作吧</p></li><li><p>腾讯的饭堂很赞，举办方免费开了会议还提供免费的午餐，真是有心了</p></li><li><p>会议的抽奖礼品很实在哦，大奖是服务器的优惠卷（价值9000）。好吧，我也很幸运，中了幸运奖–貌似是布娃娃吧，会后忘记自己还中奖来着，直接离场忘拿了</p></li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li><p>本文的截图来自嘉宾的演讲稿</p></li><li><p>本文内容仅代表自己参加<code>本固枝荣</code>会议的观点，不喜勿喷</p></li><li><p>文中使用了嘉宾的名字，如果某嘉宾觉得本人使用不妥，可以文末留言，我将打码 😝</p></li></ul><p>一张会议的合影图结束本文（原图太大，放上压缩后的图片，原图可以私信我，我还保留的话就发你了）</p><p><img src="http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/meeting_persons.png" alt="meeting/tencent_20171223/meeting_persons"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/meeting/tencent_20171223/banner.jpg&quot; alt=&quot;meeting/tencent_20171223/banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;第二届前端体验大会，是至今为止，我参加的最棒的一次前端体验大会，不枉我从广州过去深圳啊。&lt;del&gt;目前只参加过一次大型的前端体验大会&lt;/del&gt; 😝。在一天的时间里面，自己收获到了很多的东西。作为一个非典型的程序员，杂七杂八的就不谈了，还是谈技术来得简单粗暴一点。&lt;/p&gt;
    
    </summary>
    
      <category term="技术交流" scheme="http://reng99.cc/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
    
      <category term="会议" scheme="http://reng99.cc/tags/%E4%BC%9A%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>git的学习汇总</title>
    <link href="http://reng99.cc/2017/12/13/git-learning/"/>
    <id>http://reng99.cc/2017/12/13/git-learning/</id>
    <published>2017-12-13T14:12:02.000Z</published>
    <updated>2018-01-02T12:22:00.599Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/tools/git/git-banner.jpg" alt="tools/git/git-banner"></p><p>这篇博文是自己在学习git过程中的思考总结。本文仅仅代表个人的看法，如有不妥地方还请本文文末留言。 😊 </p><a id="more"></a><h2 id="GIT是什么"><a href="#GIT是什么" class="headerlink" title="GIT是什么"></a>GIT是什么</h2><p><code>GIT</code>是一个免费并且开源的分布式版本控制系统，能够高速有效的处理或小或大的项目。(以上的话是自己翻译<a href="https://git-scm.com/" target="_blank" rel="noopener">github官网</a>)</p><p>至今，自己用过了window系统的<code>TortoiseSVN</code>, mac系统的<code>CornerStone</code>,最近的大半年也在用<code>GIT</code>(主要管理自己的<a href="https://github.com/reng99" target="_blank" rel="noopener">github项目</a>)。比较下来，还是GIT优势比较明显<del>，虽然目前为止没有用GIT开发过团队项目</del>。</p><p><strong>GIT跨平台</strong></p><p><code>GIT</code>可以在不同的操作系统中使用。也许你注意到了，我在window上和mac系统上工作的时候是使用两个不同的svn。如果我在linux上工作会不会又是一个呢。</p><p><strong>GIT是分布式版本控制系统,而svn是集中式版本控制系统</strong></p><p><code>集中式版本控制系统</code>是集中放在中央服务器上面的，而团队的人需要从中央服务器上面拉取最新的代码，然后进行开发，最后推送到中央服务器上面，就像串联的电路。而<code>分布式版本控制系统</code>没有中央服务器，团队的每个人的电脑就是一个完整的版本库，就好像并联的电路（自我理解）。</p><p><code>集中式版本控制系统</code>必须联网才能工作，如果是在局域网内还好，带宽足够大，速度足够快，但是遇到网速慢的话，那心里就一万个羊驼🐑在蹦腾了。</p><p><code>集中式版本控制系统</code>安全性比较低，如果中央系统崩溃了，那就有点悲催了。当然你不嫌麻烦，可以定期备份的啦。而<code>分布式中央系统</code>就比较安全，团队的每个成员的电脑就是一个完整的版本库。如果其中一个坏掉了，你可以从团队另外一个的人员电脑那里拷贝一份就行了。对了，<code>GIT</code>也会有一台中央的机子，主要是为了方便团队的交流，它是可以不存在的。</p><h2 id="GIT安装"><a href="#GIT安装" class="headerlink" title="GIT安装"></a>GIT安装</h2><p><code>GIT</code>支持不同的系统，看者可以在链接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a>中，找到和自己电脑系统匹配的<code>GIT</code>版本，下载安装包后根据提示进行安装。当然，<code>GIT</code>还提供图形界面管理工具，看者也可以在链接中下载<code>GUI Clients</code>，如下图所示–<br><img src="http://omu538iq8.bkt.clouddn.com/tools/git/git_install.png" alt="tools/git/git_install"><br>根据提示安装完成后，要验证是否安装成功。看者可打开命令行工具，输入<code>git --version</code>命令,如果安装成功，控制台输出安装的版本号（当然，安装前就应该输入git –version查看是否安装了git），我这里安装的<code>GIT</code>版本是<code>2.10.0</code>。</p><h2 id="GIT配置"><a href="#GIT配置" class="headerlink" title="GIT配置"></a>GIT配置</h2><p><code>GIT</code>在使用前，需要进行相关的配置。每台计算机上面只需要配置一次，程序升级的时候会保留配置信息。当然，看者可以在任何时候再次通过运行命令行来修改它们。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>设置<code>GIT</code>的用户名称和邮件地址，这个很重要，因为每个<code>GIT</code>的提交都会使用这些信息，并且它会写入到每一次的提交中。你可以在自己的仓库中使用<code>git log</code>，控制台上面显示的每次的提交都有<code>Author</code>字段，它的值就是<code>用户名称 &lt;邮件地址&gt;</code>。方便查看某次的提交的负责人是谁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"你的用户名"</span></span><br><span class="line">$ git config --global user.email 你的邮箱地址</span><br></pre></td></tr></table></figure><p>⚠️ <code>GIT</code>一般和<code>github</code>配合使用，看者应该设置用户名称为你的<code>github</code>用户名。当然，还有和<code>gitlab</code>等配合使用…</p><p>⚠️ 如果配置中使用了<code>--global</code>选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，<code>GIT</code>都会使用这些信息。但是，当你想针对特定项目使用不同的用户名称与邮件地址的时候，可以在那个仓库目录下运行不使用<code>global</code>选项的命令来配置。</p><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>通过<code>git config --list</code>命令可以列出所有<code>GIT</code>能找到的配置。如下：（我的git版本为2.10.0）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">user.name=reng99</span><br><span class="line">user.email=1837895991@qq.com</span><br><span class="line">color.ui=<span class="literal">true</span></span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当然，你可以通过<code>git config &lt;key&gt;</code>来检查<code>GIT</code>的某一项配置。比如<code>$ git config user.name</code>。</p><h3 id="帮助中心"><a href="#帮助中心" class="headerlink" title="帮助中心"></a>帮助中心</h3><p>在使用<code>GIT</code>的时候，遇到问题寻求帮助的时候，可以运行<code>git help</code>或<code>git --help</code>或<code>git</code>命令来查看。在控制台上会展示相关的帮助啦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">usage:</span><br><span class="line">...</span><br><span class="line">start a working area (see also: git <span class="built_in">help</span> tutorial)</span><br><span class="line">...</span><br><span class="line">work on the current change (see also: git <span class="built_in">help</span> everyday)</span><br><span class="line">...</span><br><span class="line">examine the <span class="built_in">history</span> and state (see alse: git <span class="built_in">help</span> revisions)</span><br><span class="line">...</span><br><span class="line">grow,mark and tweak your common <span class="built_in">history</span></span><br><span class="line">...</span><br><span class="line">collaborate (see also: git <span class="built_in">help</span> workflows)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>更加详细的内容，请点击<a href="https://git-scm.com/docs/git-help" target="_blank" rel="noopener">传送门</a></p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>版本库又名仓库(repository)，可以理解成一个目录，这个目录里面所有文件都可以被<code>GIT</code>管理起来，每个文件的修改、删除，<code>GIT</code>都能跟踪，以便任何时刻都能可以追踪历史，或者在将来某个时刻可以还原。</p><p>创建一个版本库，首先得选择一个存放目录的地方，我这里选择了桌面，并且创建一个空的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop</span><br><span class="line">$ mkdir -p learngit</span><br><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/Users/reng/desktop/learngit</span><br></pre></td></tr></table></figure><p><code>mkdir -p dirnanme</code>是创建一个子目录，这里的<code>-p</code>确保目录的名称存在，如果目录不存在的就新建一个，如果你确定目录不存在，直接使用<code>mkdir dirname</code>就可以了。<code>pwd(Print Working Directory)</code>是显示当前目录的整个路径名。</p><p>然后，通过命令行<code>git init</code>，将创建的目录变成<code>GIT</code>可以管理的仓库:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init </span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/reng/Desktop/learngit/.git/</span><br></pre></td></tr></table></figure><p>初始化好仓库后就可以愉快的玩耍了，但是，得先来了解下<code>GIT</code>整个工作流程先。</p><h2 id="GIT工作流程"><a href="#GIT工作流程" class="headerlink" title="GIT工作流程"></a>GIT工作流程</h2><p>为了更好的学习，自己用<code>Axure RP 8</code>粗略的画了下流程图，如下–<br><img src="http://omu538iq8.bkt.clouddn.com/tools/git/git_brief_process.png" alt="tools/git/git_brief_process"></p><p>本地仓库(repo)包含工作区和版本库,那么什么是工作区和版本库呢？基本的流程又是什么呢？</p><h3 id="工作区和版本库"><a href="#工作区和版本库" class="headerlink" title="工作区和版本库"></a>工作区和版本库</h3><p>我们新建一个仓库，就像我们新建的<code>learngit</code>仓库，现在在里面添加一个文件<code>README.md</code>，用sublime打开<code>learngit</code>目录。此时会出现如下图的情况(当然你设置了其他东西例外)–<br><img src="http://omu538iq8.bkt.clouddn.com/tools/git/working_version_area.png" alt="tools/git/working_version_area"><br>如上图，出现的内容就是工作区（ 电脑上能看到的此目录下的内容），这里工作区只有<code>README.md</code>一个文件。工作区有一个隐藏的目录<code>.git</code>，这个不算工作区，而是<code>GIT</code>的版本库。版本库又包括暂存区和GIT仓库。暂存区是一个文件，保存了下次将提交的文件列表信息，而GIT仓库目录是<code>GIT</code>用来保存项目的元数据和对象数据库的地方。这是<code>GIT</code>中最重要的部分，从其他计算机克隆仓库的时候，拷贝的就是这里的数据。当执行<code>git add .</code>或者<code>git add path/to/filename</code>的时候，文件从工作区转到暂存区；执行<code>git commit -m&quot;here is the message described the file you add&quot;</code>的时候,文件从缓存区添加到GIT仓库。</p><h3 id="基本的工作流"><a href="#基本的工作流" class="headerlink" title="基本的工作流"></a>基本的工作流</h3><p>基本的<code>GIT</code>工作流可以简单总结如下–</p><ol><li>在工作区目录中修改文件</li><li>暂存区中暂存文件，将文件的快照放入暂存区域</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到GIT仓库目录</li></ol><h2 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h2><p>到目前为止，在自己创建的本地仓库–<code>learngit</code>中已经初具形态了。进入<code>learngit</code>，执行<code>ls</code>，可看到目前仓库中已有的文件README.md。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop/learngit</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br></pre></td></tr></table></figure><p>上面展示了本地<code>learngit</code>内的相关的内容。运行下<code>git status</code>查看现在的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>这时候会提示没有内容可以提交，工作区是干净的。因为我之前已经提交(git commit)过了。上面还提示了目前是位于主分支上面，<code>GIT</code>在初始化(git init)的时候会自动创建一个<code>HEAD</code>指针指向默认<code>master</code>分支，也只有一个分支，看者可以通过<code>git branch</code>查看。</p><p>现在，在<code>README.md</code>上添加一些内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br></pre></td></tr></table></figure><p>此刻再通过<code>git status</code>查看当前状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>这时候显示出一堆的东西，告诉我们现在是位于主分支上面，然后告诉我们修改的文件啊，可以使用的命令进行下一步的操纵。那么我们来进行下一步的操作了，<code>git add . 或者 git add README.md</code>将修改的文件添加到暂存区域。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br></pre></td></tr></table></figure><p>对了，有时候需要在添加的之前（执行git add .  或者 git add path/to/filename）的时候，需要看下修改了哪些内容可以执行下<code>git diff</code>。那么，现在先回退到修改的前一个版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD README.md</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">MREADME.md</span><br><span class="line">$ git checkout -- README.md</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br></pre></td></tr></table></figure><p>回退正确，现在像上次那样添加内容<code>### first change</code>，然后执行命令<code>git diff</code>来查看更改的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 75759ec..0bc52b9 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,3 @@</span><br><span class="line">-<span class="comment">## content</span></span><br><span class="line">\ No newline at end of file</span><br><span class="line">+<span class="comment">## content</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">### first change</span></span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>现在就显示了修改前的内容–<code>-</code>前为修改前的内容，和修改后的内容–<code>+</code>前修改后的内容。查看完之后，觉得没有问题了，就可以进行添加(git add)，提交(git commit)。当然，一般不常用git diff的，因为自己修改的东西自己心里总有点数吧，可能合作中团队的其他人需要查看文件前后的不同点就需要用到<code>git diff</code>啦。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>为了方便讲解下版本回退，我先将上面添加的<code>### first change</code>提交以下–<code>git add . &amp;&amp; git commit -m &quot;add first change&quot;</code>。下面通过<code>git log</code>就可以查看自己提交的记录了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67</span><br><span class="line">Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">Date:   Sun Dec 17 17:11:53 2017 +0800</span><br><span class="line"></span><br><span class="line">    init README.md</span><br><span class="line">    </span><br><span class="line">$ git add . &amp;&amp; git commit -m <span class="string">"add first change"</span></span><br><span class="line">[master 0ac49ba] add first change</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 0ac49bae6ab55df9c05d0770de347665a2568f31</span><br><span class="line">Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">Date:   Mon Dec 18 15:26:06 2017 +0800</span><br><span class="line"></span><br><span class="line">    add first change</span><br><span class="line"></span><br><span class="line">commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67</span><br><span class="line">Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">Date:   Sun Dec 17 17:11:53 2017 +0800</span><br><span class="line"></span><br><span class="line">    init README.md</span><br></pre></td></tr></table></figure><p>在上面中，自己先执行了<code>git log</code>来显示提交的日志，显示只有一条，然后执行了add和commit的命令，打印的内容是现实主分支、commit的id、commit的信息、多少个文件的更改、多少个插入以及多少个删除。之后再次执行<code>git log</code>打印日志，显示了两次提交。⚠️ 注意：当提交(commit)的次数较多之后，控制台会显示不下（最多现实4条）那么多的条数，可以通过按键盘的<code>向上或向下</code>键查看日志的内容，需要退出查看日志命令的话，在<code>英文输入法的状态按下q</code>，意思就是quit(退出)。</p><p>版本的回退就是改变<code>HEAD</code>指针的指向。通过<code>git reset --hard HEAD^</code>返回上一个版本，通过<code>git reset --hard HEAD^^</code>返回上上个版本…由此推论，往上100个版本的话就是100个<code>^</code>，当然，这样你数到明天也未必数得正确，所以写成<code>git reset --hard HEAD~100</code>。另外一种是，你知道提交的id，例如<code>commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67</code>的前7位就是commit的id(5c2639e)，执行<code>git reset --hard 5c2639e</code>就回到此版本啦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ reng$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 5c2639e init README.md</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67</span><br><span class="line">Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">Date:   Sun Dec 17 17:11:53 2017 +0800</span><br><span class="line"></span><br><span class="line">    init README.md</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br></pre></td></tr></table></figure><p>现在你已经回到了最初的版本，这里演示的是通过<code>HEAD</code>，你也可以通过<code>commit id</code>来实现的。执行上面的代码后，<code>README.md</code>文件里面只有一<code>### content</code>文字内容,但是过了段时间后，你想恢复到原先的版本，通过<code>git log</code>命令行，控制台显示的以前的信息，通过它找不到回退前的<code>commit id</code>，怎么办？<code>GIT</code>提供一个<code>git reflog</code>显示提交的历史记录，在那里可以查看提交的id、<code>HEAD</code>的指针历史和操作的信息记录。下面演示回退到最新的版本（也就是commit -m “add first change”）–</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67</span><br><span class="line">Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">Date:   Sun Dec 17 17:11:53 2017 +0800</span><br><span class="line"></span><br><span class="line">    init README.md</span><br><span class="line">$ git reflog</span><br><span class="line">5c2639e HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">0ac49ba HEAD@&#123;1&#125;: commit: add first change</span><br><span class="line">5c2639e HEAD@&#123;2&#125;: commit (initial): init README.md</span><br><span class="line">$ git reset --hard 0ac49ba</span><br><span class="line">HEAD is now at 0ac49ba add first change</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first</span></span><br></pre></td></tr></table></figure><p>现在又回到了最新的版本，又能够愉快的玩耍了。😊</p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p><code>GIT</code>比其他版本控制系统设计优秀，其中一点是–<code>GIT</code>跟踪并管理的是修改，而非文件。</p><p>下面在<code>README.md</code>内添加信息<code>### second change</code>。之后看下变化后的文件的状态和差异等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">$ git add README.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br></pre></td></tr></table></figure><p>此时，对<code>README.md</code>进行第三次的修改，添加内容<code>### third change</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### third change</span></span><br><span class="line">$ git commit -m <span class="string">"test file modify"</span></span><br><span class="line">[master 18f86ba] <span class="built_in">test</span> file modify</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>上面的演示流程是这样的<code>第一次修改(#### second change) -&gt; git add -&gt; 第二次修改(### third change) -&gt; git commit</code>。但是最后查看状态的时候(git status)，第二次的修改并没有被提交上去。因为<code>GIT</code>管理的是修改，当使用<code>git add</code>命令的时候，在工作区的第一次修改被放入暂存区，准备提交，但是在工作区的第二次修改并没有放入到暂存区，而<code>git commit</code>是将暂存区的修改提交到<code>GIT仓库</code>，所以第二次修改的内容是不会被提交的。这也是说明为什么可以多次添加(git add)，一次提交(git commit)的原因了。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>文件的撤销修改分成三种情况，一种是修改在工作区的内容，一种是修改在暂存区的内容，另一种是修改在<code>GIT</code>仓库的内容。也许会有看者说，不能修改在远程库中的内容吗？有啊，就是<code>git add</code>-&gt;<code>git commit</code>-&gt;<code>git push</code>将远程仓库的内容覆盖被，不过团队人在克隆远程库下来的时候，还是可以查看到你提交的错误内容的。我们现在只针对本地仓库的三种情况谈下自己的看法–</p><p><strong>情况一：撤销工作区的内容</strong></p><p>在管理修改中，自己的工作区还是没有提交，此时想放弃当前工作区的编辑内容执行<code>git checkout -- file</code>。接着上面的内容，我这里的工作区内有的内容是<code>### third change</code>，现在我要放弃第三次修改，只要执行<code>git checkout -- README.md</code>就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### third change</span></span><br><span class="line">$ git checkout -- README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p><strong>情况二：撤销暂存区的内容</strong></p><p>当你不但改乱了工作区的某个文件的内容，还添加(git add)到了暂存区时，想丢弃修改，那么得分两步来撤销文件。先是通过<code>git reset HEAD file</code>，将暂存区的文件退回到工作区，然后通过<code>git checkout -- file</code>放弃修改改文件的内容。为了方便演示，我这里的暂存区没什么内容，所以添加内容<code>### tentative content</code>并将它添加到缓存区。之后，演示将缓存区的内容撤回–</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### tentative content</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">$ git reset HEAD README.md</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">MREADME.md</span><br><span class="line">$ git checkout -- README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p><strong>情况三：撤销GIT仓库的内容</strong></p><p>如果你不仅添加(git add)了内容到暂存区并且提交(git commit)了内容到<code>GIT仓库</code>中了。你需要撤销上一次的内容，也就是要回退到上一个版本，执行<code>git reset --hard HEAD^</code>就可以啦，详细的内容查看<code>版本回退</code>。如下–</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### second change</span></span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 0ac49ba add first change</span><br><span class="line">$ cat READMEmd</span><br><span class="line"><span class="comment">## content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### first change</span></span><br></pre></td></tr></table></figure><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库的使用能够提高你和团队的工作效率，无论何时何地，团队的人员都可以在联网的情况下将代码进行拉取，修改和更新。因为我是使用<code>github</code>来管理项目的，所以我的远程仓库是放在github里面。这里默认看者已经安装了<code>github</code>，当然也可以用码云、gitlab等。</p><h3 id="本地库添加到远程库"><a href="#本地库添加到远程库" class="headerlink" title="本地库添加到远程库"></a>本地库添加到远程库</h3><p>这点很容易，登录自己注册的<a href="https://github.com/" target="_blank" rel="noopener">github</a>，如果打不开，请开下VPN。进入自己的首页(<a href="https://github.com/username)，点击`+`号创建(new" target="_blank" rel="noopener">https://github.com/username)，点击`+`号创建(new</a> repository)一个名为<code>learngit</code>的仓库(注意哦⚠️ 名称是本地仓库已经初始化过的，我这里本地有个同名初始化的learngit仓库)，其他的字段自选来填写。点击<code>Create repository</code>创建此远程仓库。紧接着就是进行本地仓库和远程仓库的关联啦，<code>github</code>很友好的提示了你怎么进行一个远程仓库的关联。</p><p><img src="http://omu538iq8.bkt.clouddn.com/tools/git/related_github_step1.png" alt="tools/git/related_github_step1"><br><img src="http://omu538iq8.bkt.clouddn.com/tools/git/related_github_step2.png" alt="tools/git/related_github_step2"><br><img src="http://omu538iq8.bkt.clouddn.com/tools/git/related_github_step3.png" alt="tools/git/related_github_step3"></p><p>现在按照上图来关联下远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/reng99/learngit.git</span><br><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 456 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/reng99/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch master <span class="built_in">set</span> up to track remote branch master from origin.</span><br></pre></td></tr></table></figure><p>注意⚠️ 第一次向远程仓库（关联）push的时候是<code>$ git push -u origin master</code>，不能忽略<code>-u</code>，以后的push不用带<code>-u</code>。至此，打开你的github的相关的仓库就可以看到添加了<code>README.md</code>文件，我这里地址是<code>https://github.com/reng99/learngit</code>，因为我是使用markdown语法写的，控制台显示的内容和仓库的显示内容有所区别啦。<del>(⚠️ 后期我将learngit仓库删除啦，所以你访问链接是找不到这个仓库的，毕竟不想放一个没什么内容的仓库在我的github上)</del>。</p><h3 id="远程库克隆到本地"><a href="#远程库克隆到本地" class="headerlink" title="远程库克隆到本地"></a>远程库克隆到本地</h3><p>从远程仓库克隆东西到本地同样很简单，只需要进入你想克隆的仓库，将仓库的<code>url</code>复制下来（当然你也可以复制window.location.href的内容），运行<code>git clone address</code>。现在我将本地桌面的<code>learngit</code>的仓库删除，然后从远程将<code>learngit</code>克隆到本地。</p><p><img src="http://omu538iq8.bkt.clouddn.com/tools/git/git_clone_repository.png" alt="tools/git/git_clone_repository"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop</span><br><span class="line">$ rm -rf learngit</span><br><span class="line">$ find learngit</span><br><span class="line">find: learngit: No such file or directory</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/reng99/learngit</span><br><span class="line">Cloning into <span class="string">'learngit'</span>...</span><br><span class="line">remote: Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (6/6), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p>成功将<code>gitlearn</code>从远程克隆下来，接下来又可以愉快的玩耍啦。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支管理允许创建另一条线/方向上开发，能够让你在不影响他人工作的情况下，正常的工作。当在自己创建的分支中完成自己的功过后，合并到主分支就行了(git init初始化的时候已经默认创建了master主分支)。一般团队的合作是不在主分支上进行的，个人项目除外（个人理解）。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>当前<code>learngit</code>仓库上只有一个分支，那就是<code>master</code>分支，看者可以通过<code>git branch</code>命令来查看当前的分支，<code>git branch branchName</code>命令来创建一个新的分支，我这里创建的是<code>dev</code>分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop/learngit</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">$ git branch dev</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>现在已经创建了<code>dev</code>分支，有两个分支了，分支前面带有一个星号的分支说明是当前的正在工作的分区。执行上面的分支后，可以简单的画下现在的情况了，有个<code>HEAD</code>指针指向主分支的最新点，刚才新创建的<code>dev</code>分支我这里默认是一个<code>dev</code>的指针指向了<code>dev</code>分支的最新点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">.HEAD指针</span><br><span class="line">.│</span><br><span class="line">├────────*master</span><br><span class="line">└────────dev</span><br><span class="line">│</span><br><span class="line">dev指针</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>我们一般是很少在主分支进行工作的，所以在创建出新的分支之后，我们就切换到新的分支进行相关的工作。可以通过<code>git checkout branchName</code>切换到已经存在的分支工作，通过分支前面的<code>*</code>可查看目前位于哪个分支内。现在我切换到创建的<code>dev</code>分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>在创建好分支后，我们在新的分支上工作完成后，就需要往主分支上进行合并啦。我修改了分支<code>dev</code>上的<code>README.md</code>的内容，就是添加文字<code>### new branch content</code>。合并分支可以分成两个合并的方式，一种是本地合并到materz主分支之后，推送(push)到远程库，一种是直接将分支推送到远程库，在远程库进行合并。</p><p><strong>本地合并推送</strong></p><p>在合并分支前，需要切换到要合并到哪个分支(一般是master主分支)，通过<code>git merge branchName</code>将需要的合并的分支合并到当前分支，我是将<code>dev</code>分支合并到<code>master</code>分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">MREADME.md</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ git merge dev</span><br><span class="line">$ Already up-to-date.</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"merge dev branch"</span></span><br><span class="line">[master d705e73] merge dev branch</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 282 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/reng99/learngit</span><br><span class="line">   0ac49ba..d705e73  master -&gt; master</span><br></pre></td></tr></table></figure><p>合并之后,此时，<code>HEAD</code>指针就指向了<code>dev</code>指针，也就是两者同时指向了<code>master</code>主分支的最新处。具体的内容参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="noopener">传送门</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">├────────*master</span><br><span class="line">└────────dev</span><br><span class="line">│</span><br><span class="line">dev指针 ── HEAD指针</span><br></pre></td></tr></table></figure><p><strong>远程库推送合并</strong></p><p>远程库内合并的话，要先将<code>dev</code>的分支推送到远程库，然后在远程库进行合并。我这里在<code>dev</code>分支上添加了<code>### add new branch content into again</code>然后demo演示推送(git push origin dev)以及合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"add dev branch commit again"</span></span><br><span class="line">[dev dc817c4] add dev branch commit again</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 300 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/reng99/learngit</span><br><span class="line"> * [new branch]      dev -&gt; dev</span><br></pre></td></tr></table></figure><p>接下来就是进入<a href="https://github.com/reng99/learngit" target="_blank" rel="noopener">我的远程learngit仓库</a>进行合并，你会看到下面图示的提示。点击<code>Compare &amp;&amp; pull request</code>，然后写点相关的<code>comment</code>（选填），点击<code>Create pull request</code>。之后在绿色勾的提示下<code>Merge pull request</code>，紧接着点击<code>Confirm merge</code>按钮确定合并此分支，这时候返回主分支就可以看到<code>dev</code>内合并的内容了(后期我改动了dev的内容)。看者如果看得不明白，自己上手尝试一下呗！</p><p><img src="http://omu538iq8.bkt.clouddn.com/tools/git/merge_branch.png" alt="tools/git/merge_branch"></p><p>完成后，你会看到<code>learngit</code>仓库的<code>Pull requests</code>量为1，<code>branches</code>量为2。你可以点击进入分支，在<code>ALL branches</code>里面查看分支的具体内容。</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>在创建了分支，然后将分支的内容合并到主分支后，分支的使命就完成了，你就可以将分支删除了，这里的删除个人认为可以是两种，一种是本地仓库的分支删除，一种是远程仓库的分支的删除。当然啦，留着分支也没啥，可以留着呗<del>，自己认为有点碍眼</del>。</p><p><strong>本地分支的删除</strong></p><p>在本地的<code>learngit</code>的目录下，执行命令行<code>git branch -D branchName</code>就可以删除了。我这里删除的是<code>dev</code>分支。注意⚠️ ，删除的分支不应该是当前工作的分支，需要切换到其他分支，我这里切换的是<code>master</code>分支，毕竟我只有两个分支呢。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git branch -D dev</span><br><span class="line">error: Cannot delete branch <span class="string">'dev'</span> checked out at <span class="string">'/Users/reng/desktop/learngit'</span></span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line">$ git branch -D dev</span><br><span class="line">Deleted branch dev (was dc817c4).</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p><strong>远程库分支的删除</strong></p><p>删除远程库的分支，只要执行<code>git push origin :branchName</code>命令就行了。现在我要删除我远程库中的<code>dev</code>分支，执行<code>git push origin :dev</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :dev</span><br><span class="line">To https://github.com/reng99/learngit</span><br><span class="line"> - [deleted]         dev</span><br></pre></td></tr></table></figure><p>此时，打开我的远程库<a href="https://github.com/reng99/learngit" target="_blank" rel="noopener">learngit</a>，发现之前的<code>Pull requests</code>量为0，<code>branch</code>量为1。</p><h3 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h3><p>通过<code>git branch -m oldBranchName newBranchName</code>来重命名分支。我这里没有分支了，现在创建一个<code>reng</code>分支，然后将它重命名为<code>dev</code>分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">$ git branch reng</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  reng</span><br><span class="line">$ git branch -m reng dev</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>在我们开发的时候，不知道分支和分支之间的进度情况是什么，难免会产生冲突。当产生冲突的时候，就得将冲突的内容更正，然后提交。为了方便演示，我将本地的<code>learngit</code>删除，重新拉取远程的<code>gitlearn</code>仓库(因为我不知道我之前在本地仓库做的修改是啥，对了，我将远程的分支删除了，只剩下master主分支)。克隆下来后，如果还存在本地分支，也将它删除，之后我将在<code>master</code>和<code>dev</code>分支中重新填充里面的<code>README.md</code>的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/reng99/learngit.git</span><br><span class="line">Cloning into <span class="string">'learngit'</span>...</span><br><span class="line">remote: Counting objects: 43, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (17/17), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 43 (delta 4), reused 38 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (43/43), <span class="keyword">done</span>.</span><br><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"add master branch content"</span></span><br><span class="line">[master 1cfa0aa] add master branch content</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 271 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/reng99/learngit.git</span><br><span class="line">   d2f936f..1cfa0aa  master -&gt; master</span><br><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"add dev branch content"</span></span><br><span class="line">[dev 80faf6d] add dev branch content</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"change master content"</span></span><br><span class="line">[master ec18715] change master content</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line">$ git merge dev</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> README.md</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p><code>README.md</code>文件中冲突内容–</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD (当前更改)</span><br><span class="line"><span class="comment">## master content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line">=======</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev (传入更改)</span><br></pre></td></tr></table></figure><p>手动修改了<code>README.md</code>文件中冲突的内容–</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br></pre></td></tr></table></figure><p> 然后命令行执行–</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"fix confict content"</span></span><br><span class="line">[master dd848b4] fix confict content</span><br><span class="line">$ git <span class="built_in">log</span> --graph</span><br><span class="line">*   commit 980788b7690d8bcf14610072fc072460bee7e9f1</span><br><span class="line">|\  Merge: c49d09e 2929dca</span><br><span class="line">| | Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| | Date:   Thu Dec 21 11:14:10 2017 +0800</span><br><span class="line">| | </span><br><span class="line">| |     fix confict content</span><br><span class="line">| |   </span><br><span class="line">| * commit 2929dca91ef8f493adba7744cdad19656538334f</span><br><span class="line">| | Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| | Date:   Thu Dec 21 11:11:49 2017 +0800</span><br><span class="line">| | </span><br><span class="line">| |     add dev branch content</span><br><span class="line">| |   </span><br><span class="line">* | commit c49d09e33e7098d67b59c845d18e9c6f8a8f4fea</span><br><span class="line">|/  Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">|   Date:   Thu Dec 21 11:12:50 2017 +0800</span><br><span class="line">|   </span><br><span class="line">|       change master content</span><br><span class="line">|  </span><br><span class="line">* commit b07f0be8280e4e437cccf2a3f8fac6beef03ff41</span><br><span class="line">| Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| Date:   Thu Dec 21 11:10:51 2017 +0800</span><br><span class="line">| </span><br><span class="line">:</span><br></pre></td></tr></table></figure><p>上面操作过程是，我先从远程库中克隆<code>learngit</code>仓库到本地，目前的本地<code>learngit</code>的分支只有<code>master</code>分支，然后我在<code>master</code>分支的<code>README.md</code>中添加相关的文字(见代码)，接着把它推送到远程库。然后创建并切换<code>dev</code>分支，在<code>README.md</code>文件中添加新内容(见代码)，接着将它提交到<code>GIT仓库</code>。又切换到<code>master</code>分支，修改<code>README.md</code>到内容(见代码)，提交到<code>GIT仓库后</code>开始执行<code>merge</code>命令合并<code>dev</code>分支的内容。此时，产生了冲突，这就需要手动将冲突的内容解决，重新<code>commit</code>到<code>GIT仓库</code>，最后你就可以提交到远程库了(这步我没有演示，也就是git push origin master一行命令行的事情)。最后我还使用<code>git log ----graph</code>打印出整个分支合并图(从下往上看)，方便查看。⚠️ 此时退出<code>git log --graph</code>是书写英文状态按键盘的<code>q</code>键。</p><p>说这么多，目的只有一个 –&gt; 产生冲突后，需要手动调整😊</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>先放上一张分支管理策略图，然后再慢慢讲解相关的内容…</p><p><img src="http://omu538iq8.bkt.clouddn.com/tools/git/manager_branch_tactics.png" alt="tools/git/manager_branch_tactics"></p><p>在分支管理中，我们不断的新建分支，开发，合并分支，删除分支的操作。这里需要注意合并分子的操作，之前我们进行分支的时候是直接将<code>dev</code>开发的分支使用<code>git merge dev</code>进行合并，这样有个缺点：我们看不出分支信息。因为在默认情况下，合并分支的时候，<code>GIT</code>是使用了<code>Fast Foward</code>的模式，在这种模式下，删除分支后，会丢掉分支的信息。下面我重新克隆下我远程<code>learngit</code>仓库，然后创建并更改<code>dev</code>分支的信息，使用默认的模式进行合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line"><span class="comment">### new dev branch content</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"add new dev contentt"</span></span><br><span class="line">[dev 750e1f1] add new dev content</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ git merge dev</span><br><span class="line">Updating 980788b..750e1f1</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">$ git <span class="built_in">log</span> --graph</span><br><span class="line">* commit 750e1f17854872eed4d6cff8315e404079ecb18f</span><br><span class="line">| Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| Date:   Fri Dec 22 10:05:36 2017 +0800</span><br><span class="line">| </span><br><span class="line">|     add new dev content</span><br><span class="line">|    </span><br><span class="line">*   commit 980788b7690d8bcf14610072fc072460bee7e9f1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的合并就是将master分支上面的<code>HEAD</code>指向<code>dev</code>指针，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录是从上往下</span></span><br><span class="line">- before merge</span><br><span class="line">master</span><br><span class="line">* (begin)</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">*</span><br><span class="line">\</span><br><span class="line"> \</span><br><span class="line">  *</span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  * (end)</span><br><span class="line"> dev</span><br><span class="line"> </span><br><span class="line">- after merge</span><br><span class="line">master</span><br><span class="line">* (begin)</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">*</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">* </span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">* (end)</span><br></pre></td></tr></table></figure><p>为了保留分支的情况，保证版本演进的清晰，我们就得使用普通模式合并，也就是在<code>Fast Foward</code>的模式基础上加上<code>--no-ff</code>参数，即<code>git merge --no-ff branchName</code>，不过我们一般加上你合并的相关信息，即<code>git merge --no-ff -m &quot;your msg here&quot; banchName</code>。现在更改<code>dev</code>分支的内容，再进行合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line"><span class="comment">### new dev branch content</span></span><br><span class="line"><span class="comment">### merge with no-ff</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"add no-ff mode content"</span></span><br><span class="line">[dev 80b628c] add no-ff mode content</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">$ git merge dev --no-ff -m <span class="string">"merge with no-ff"</span> dev</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> README.md | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">$ git <span class="built_in">log</span> --graph</span><br><span class="line">*   commit 98746d93a9b64ea02b8ff1c7f0fa5e915405c0e6</span><br><span class="line">|\  Merge: 750e1f1 80b628c</span><br><span class="line">| | Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| | Date:   Fri Dec 22 14:39:32 2017 +0800</span><br><span class="line">| | </span><br><span class="line">| |     merge with no-ff</span><br><span class="line">| |   </span><br><span class="line">| * commit 80b628c334618711b77da81fa805ffc246a2cf7d</span><br><span class="line">|/  Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">|   Date:   Fri Dec 22 14:38:17 2017 +0800</span><br><span class="line">|   </span><br><span class="line">|       add no-ff mode content</span><br><span class="line">|  </span><br><span class="line">* commit 750e1f17854872eed4d6cff8315e404079ecb18f</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使用<code>--no-ff</code>参数的普通模式合并，会执行正常合并，在<code>master</code>主分支上面会生成一个新的节点，如下（<strong>我上面的分支管理策略图里面的合并就是使用了普通的模式</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录是从上往下</span></span><br><span class="line">- --no-ff合并</span><br><span class="line">master</span><br><span class="line">* (before)</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">*</span><br><span class="line">|\ </span><br><span class="line">| \</span><br><span class="line">|  *dev</span><br><span class="line">|  |</span><br><span class="line">|  |</span><br><span class="line">|  *</span><br><span class="line">| /</span><br><span class="line">|/</span><br><span class="line">* (after)</span><br></pre></td></tr></table></figure><p>我们在开发中，分支管理可以分成master主分支、dev开发分支、feature功能分支、release预发布分支、hotfixes修补bug分支。其中功能分支、预发布分支和修补bug分支可以归为<code>临时分支</code>。<code>临时分支</code>在进行分支的合并之后就可以被删除了。下面就一一讲解自己眼中的各种分支。</p><h4 id="主分支master"><a href="#主分支master" class="headerlink" title="主分支master"></a>主分支master</h4><p>主分支是在你初始化仓库的时候(git init)，自动生成的一个master分支，删除不了的哦（演示待会给）。主分支是有且仅有一个，也是发布上线的分支，团队合作的最终代码都会在master主分支上面体现出来。也许你也注意到了分支管理策略图里面的主分支会被打上<code>TAG</code>的标签，这是为了方便到某个时间段对版本的查找，标签tag的学习总结后面给出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录是从上往下</span></span><br><span class="line">master</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">*(tag 1.0)</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">*(tag 1.1)</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">*(tag 1.2)</span><br></pre></td></tr></table></figure><p>下面代码演示下不能放删除master的情况:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line">$ git branch -D master</span><br><span class="line">error: Cannot delete branch <span class="string">'master'</span> checked out at <span class="string">'/Users/reng/desktop/learngit'</span></span><br></pre></td></tr></table></figure><h4 id="开发分支develop"><a href="#开发分支develop" class="headerlink" title="开发分支develop"></a>开发分支develop</h4><p>在开发的过程中，项目合作者应该保持自己本地有一个开发环境的分支，在进行分支开发之前，需要进行<code>git pull</code>拉取<code>master</code>主分支的最新内容，或者通过其他的方法。在获取到最新的内容之后才可以进行本地的新功能的开发。在开发完成后将内容<code>merge</code>到主分支之后，不用将<code>dev</code>分支删除，因为你开发的就是在这里进行，何必删除后再新建一个开发环境的分支呢。</p><p>接着上面的情况，我目前已经拥有了<code>dev</code>开发分支:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h4 id="功能（特性）分支feature"><a href="#功能（特性）分支feature" class="headerlink" title="功能（特性）分支feature"></a>功能（特性）分支feature</h4><p>一个软件就是一个个功能叠加起来的，在软件的开发中，我们总不能在主分支开发，将主分支搞乱吧。当然，你可以在dev分支中开发，一般新建功能分支来开发，然后功能开发完再合并到dev分支，之后删除功能分支。需要的时候就可以将<code>dev</code>开发分支合并到<code>master</code>主分支，这样就随时保证<code>dev</code>分支功能的完整性。</p><p>下面演示功能分支<code>user</code>开发（随便写点内容）的合并（这里也演示了合并到master主分支，跳过了release分支的测试），删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ git branch user</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  user</span><br><span class="line">$ git checkout user</span><br><span class="line">Switched to branch <span class="string">'user'</span></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line"><span class="comment">### new dev branch content</span></span><br><span class="line"><span class="comment">### merge with no-ff</span></span><br><span class="line"><span class="comment">### function user</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"function user was acheive"</span></span><br><span class="line">[user 26beda3] <span class="keyword">function</span> user was acheive</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">$ git merge --no-ff -m <span class="string">"merge user feature"</span> user</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> README.md | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 3 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">$ git merge --no-ff -m <span class="string">"merge dev branch"</span> dev</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> README.md | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">$ git <span class="built_in">log</span> --graph</span><br><span class="line">*   commit f15a1e9012635fc21e944ab76c4cd4bbd539f82f</span><br><span class="line">|\  Merge: 98746d9 0ca83c6</span><br><span class="line">| | Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| | Date:   Fri Dec 22 16:35:43 2017 +0800</span><br><span class="line">| | </span><br><span class="line">| |     merge dev branch</span><br><span class="line">| |     </span><br><span class="line">| *   commit 0ca83c654df64724743a966f5f0989477e504cbc</span><br><span class="line">| |\  Merge: 80b628c 26beda3</span><br><span class="line">| | | Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| | | Date:   Fri Dec 22 16:33:27 2017 +0800</span><br><span class="line">| | | </span><br><span class="line">| | |     merge user feature</span><br><span class="line">| | |    </span><br><span class="line">| | * commit 26beda3b8246e047f10ac0461ca11d1a6f132819</span><br><span class="line">| |/  Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">| |   Date:   Fri Dec 22 16:31:41 2017 +0800</span><br><span class="line">| |   </span><br><span class="line">| |       <span class="keyword">function</span> user was acheive</span><br><span class="line">| |     </span><br><span class="line">* |   commit 98746d93a9b64ea02b8ff1c7f0fa5e915405c0e6</span><br><span class="line">|\ \  Merge: 750e1f1 80b628c</span><br><span class="line">| |/  Author: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">:</span><br><span class="line">$ git branch -D user</span><br><span class="line">Deleted branch user (was 26beda3).</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h4 id="预发布分支release"><a href="#预发布分支release" class="headerlink" title="预发布分支release"></a>预发布分支release</h4><p>在进行一系列的功能的开发和合并后，在满足迭代目标的时候，就可以打包送测了。这里就需要一个预发布分支release。预发布分支是指在发布正式版本之前（ 即合并到master分支之前，可查看上面分支管理策略图），需要一个有预发布的版本（可以理解为灰度环境）进行测试。</p><p>预发布环境是从<code>dev</code>分支上面分出来的，预发布结束之后，必须合并到<code>dev</code>和<code>master</code>分支上面。这里我就不演示了，跟功能分支差不多，就是合并的时候要合并到<code>dev</code>和<code>master</code>上，这时候<code>dev</code>分支和<code>master</code>的同步的代码，就不需要将<code>dev</code>分支合并到<code>master</code>了。最后将预发布分支删除掉。</p><h4 id="修复bug分支-bug-hotfixes"><a href="#修复bug分支-bug-hotfixes" class="headerlink" title="修复bug分支 bug/hotfixes"></a>修复bug分支 bug/hotfixes</h4><p>在写代码的过程中，由于种种原因 -&gt; 比如功能考虑不周全，版本上线时间有限，产品突然改需求等，我们写的代码就出现一些或大或小的bug或者需要紧急修复。那么我们就可以使用bug分支（其实就是新建一个分支处理bug而已啦，命名随意起的），然后在这个分支上处理编码出现的问题。我在<code>分支管理策略图</code>上面已经展示了一种出现bug的情况 -&gt; 就是在测试发布版本看似没问题的情况下，将<code>release</code>版本整合到<code>master</code>和<code>dev</code>中，这时候火眼精金发现了遗留的一个bug，然后新建一个<code>bug分支</code>处理，再合并到<code>master</code>和<code>dev</code>中，之后将<code>bug分支</code>移除啦。</p><p>在开发的过程中，无论咋样都是这样 : 新建bug分支 -&gt; 把分支合并 -&gt; 删除分支，这里的demo就不演示了，可以参考上面的<code>功能（特性）分支feature</code>。</p><p>这里需要注意⚠️的一点，当在开发的过程中，开发到一定的程度，需要停下来需改紧急的bug，那么需要停下手头的工作需改bug啦。这时候需要将工作现场储藏(stash功能)起来，等以后回复现场了后接着工作。现在我在原先的<code>gitlearn</code>仓库中<code>README.md</code>文件文末添加<code>### modify content</code>内容来进行演示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop</span><br><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line"><span class="comment">### new dev branch content</span></span><br><span class="line"><span class="comment">### merge with no-ff</span></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: 80b628c add no-ff mode content</span><br><span class="line">HEAD is now at 80b628c add no-ff mode content</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>然后过段时间(这里省略修改的演示)，代码已经修改好合并后，需要回到最新的内容区域进行工作，这就需要还原最新的内容了，demo如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: 80b628c add no-ff mode content</span><br><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (9e85bcc8435ae38c17db59ddc3cd8401af404827)</span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>⚠️ <code>git stash</code>不仅可以隐藏工作区的内容，也可以隐藏暂存区的内容。<code>git stash list</code>是查看隐藏的列表。<code>git stash pop</code>是将隐藏的内容恢复并删除，<code>git stash pop</code>相当于<code>git stash apply &amp;&amp; git stash drop</code>，这里的<code>git stash apply</code>是恢复隐藏内容，<code>git stash drop</code>是删除隐藏内容。</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>简单谈下自己git协作的过程吧。在负责人将搭建好的仓库上传到远程的仓库后（一般是包含了master默认的分支和dev分支），自己将远程仓库克隆到本地，然后在本地的仓库上新建一个<code>dev分支</code>，将远程的dev分支重新拉取下<code>git pull origin dev</code>，开发完成后就可以提交自己的代码到<code>远程的dev分支了</code>，如果提交之前或者之后需要修改bug或者添加新的需求的话，需要新建一个相关的分支并完成开发，将他们合并到<code>本地dev</code>分支后上传到<code>远程dev</code>分支。如果新建的<code>远程仓库中只有master分支</code>，我是这样处理的：依然要在本地新建一个<code>dev</code>分支，然后在完成特定版本的开发后，将分支合并到<code>本地master分支</code>然后再推送到<code>远程master</code>分支，本地的<code>dev分支</code>保留哦。我自己比较偏向于第一种情况。</p><p>注意⚠️ 如果<code>master</code>主分支有内容更新的话，而你又在分支上开发，如果要拉取主分支最新的内容，直接<code>git pull origin master</code>就行了。</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本前，为了唯一确定时刻的版本，我们通常在版本库中打一个标签(tag)，方便在发布版本以后，可以在某个时刻将某个历史的版本提取出来（因为标签tag也是版本库的一个快照）。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>创建标签是默认在你切换的分支最新提交处创建的。我这里在本地桌面的<code>learngit仓库</code>的<code>master分支</code>上打一个<code>v1.0标签</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> desktop/learngit</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ git tag</span><br><span class="line">$ git tag v1.0</span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>当然，你可以在非新commit的地方进行标签。这就需要你查找到需要打标签处的commit的id，然后执行<code>git tag tagName commitId</code>。这里我随意找master分支中的commit id进行标签<code>v0.9</code>的标签创建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">f15a1e9 merge dev branch</span><br><span class="line">0ca83c6 merge user feature</span><br><span class="line">26beda3 <span class="keyword">function</span> user was acheive</span><br><span class="line">98746d9 merge with no-ff</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现在在commit id为 <code>98746d9</code>处打标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 98746d9</span><br><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>在上面创建标签，我们已经有了标签<code>v0.9 v1.0</code>。有时候我们标签打错了，需要进行删除，那么就得更改啦，运用<code>git tag -d tagName</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag <span class="string">'v0.9'</span> (was 98746d9)</span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">$ git tag v0.8 80b628c -m <span class="string">"version 0.8"</span></span><br><span class="line">$ git tag</span><br><span class="line">v0.8</span><br><span class="line">v1.0</span><br><span class="line">$ git show v0.8</span><br><span class="line">$ git show v0.8</span><br><span class="line">tag v0.8</span><br><span class="line">Tagger: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">tag v0.8</span><br><span class="line">Tagger: reng99 &lt;1837895991@qq.com&gt;</span><br><span class="line">Date:   Wed Dec 27 16:07:46 2017 +0800</span><br><span class="line"></span><br><span class="line">version 0.8</span><br></pre></td></tr></table></figure><p>在上面的演示中，我删除了v0.9，然后在创建v0.8的时候追加了打标签的信息，之后使用<code>git show tagName</code>查看签名信息。</p><p>我们还可以进行分支切换标签，类似于分支的切换，我这里打的两个标签的内容是不同的，我可以通过观察内容的改表来得知时候成功切换标签了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.8</span><br><span class="line">v1.0</span><br><span class="line">$ git checkout v1.0</span><br><span class="line">HEAD is now at f15a1e9... merge dev branch</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line"><span class="comment">### new dev branch content</span></span><br><span class="line"><span class="comment">### merge with no-ff</span></span><br><span class="line"><span class="comment">### function user</span></span><br><span class="line">$ git checkout v0.8</span><br><span class="line">Previous HEAD position was f15a1e9... merge dev branch</span><br><span class="line">HEAD is now at 80b628c... add no-ff mode content</span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment">## master branch content</span></span><br><span class="line"><span class="comment">### new master branch content</span></span><br><span class="line"><span class="comment">### dev branch content</span></span><br><span class="line"><span class="comment">### new dev branch content</span></span><br><span class="line"><span class="comment">### merge with no-ff</span></span><br></pre></td></tr></table></figure><p>在确认好标签后，就可以像远程推送标签了，我这里推送<code>v1.0</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/reng99/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>上面是使用<code>git push origin tagName</code>推送特定的<code>tag</code>到远程库，但是我们能不能推送全部的tag呢？答案是肯定的，看者可以通过<code>git push origin --tags</code>进行推送。有时候，我们推送了<code>tag标签到远程库中了</code>，现在想删除掉怎么办？这个就略微麻烦点，我们不能像上面提到的删除本地库的标签那样，通过<code>git tag -d tagName</code>那样，而是通过<code>git push origin :refs/tags/tagName</code>，这里不演示，如果看者感兴趣可以自己来把弄一下哦。</p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰官方网站–Git教程</a></p><p><a href="http://wwwman.yiibai.com/git/" target="_blank" rel="noopener">易百教程–Git教程</a></p><p><a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a></p><p><a href="http://s3.51cto.com/wyfs02/M02/12/44/wKiom1MA0v-horoSAAS4v41ef_U068.jpg" target="_blank" rel="noopener">分支管理模型图</a></p><p><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">Git分支管理策略 - 阮一峰的网络日志</a></p><p style="color:red;text-align:center;">完结 @~@</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/tools/git/git-banner.jpg&quot; alt=&quot;tools/git/git-banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇博文是自己在学习git过程中的思考总结。本文仅仅代表个人的看法，如有不妥地方还请本文文末留言。 😊 &lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://reng99.cc/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://reng99.cc/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>桂林阳朔旅游</title>
    <link href="http://reng99.cc/2017/12/04/tourist-guiLin-and-yangShuo/"/>
    <id>http://reng99.cc/2017/12/04/tourist-guiLin-and-yangShuo/</id>
    <published>2017-12-04T08:04:20.000Z</published>
    <updated>2017-12-13T01:59:49.345Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/guilin_banner.jpg" alt="life/tourist/guilin/guilin-banner"></p><p>桂林市区的两江四湖的夜景很美丽，还有桂林市区的一些步行街走起来挺舒服的。然后就是阳朔啦，我喜欢那山里的清新的空气(哈哈哈，不过，我更喜欢家里海边的空气)。在山里面就好像与世隔绝，可能一个人在喧闹的城市呆久了，都会喜欢吧。⚠️ 多图博文，手机党要留意咯。</p><a id="more"></a><p>此次的桂林阳朔之旅三个人一起游玩放松，一个是好友从柳州过来桂林，另一个本身就在桂林读研究生，还有我啦–从广州这边过去呗，一共在那边呆三天，两天桂林市区(2017.12.01 &amp;&amp; 2017.12.03)和一天阳朔(2017.12.02)。</p><p>这次不像<code>丹霞山旅游</code>的流水帐那样写游记啦，仅仅谈下个人在阳朔的感受，桂林市区的没啥好谈的，毕竟是市区，都那样。</p><p>也许在广州呆的时间久了的原因，去到阳朔有不一样的体验—-第一次进山的新鲜感。第一次来阳朔，除了玩了一下当地人推荐的旅游的项目，比如坐竹筏游漓江啊。我比较喜欢租电驴(电动摩托)在山间闲逛一个下午的那段经历。哈哈,带着感冒开了一个下午。</p><p>开着电驴，进入山里面闲逛，没有目标，没有时间观念，抛离城市的喧闹与繁华。山里面的空气超级好，活脱一个天然的氧吧。自己开开停停，哎呀，这里的风景不错哦，那座山还行哦，这湖賊好看，这里有活动…嗯，我们就缺了个单反，还有如果朋友再高点，再瘦点，脸再…哈哈哈，我就有模特啦，不过手机拍出来的效果还不赖啦<del>(本博文的照片都是用自己的手机拍的啦)</del>。在阳朔的山间看到了一个新人在取景拍婚纱照，看到了骑着自行车的几个外国人在标着<code>村上春树</code>字样的山间小屋前面停下来欣赏，吃了当地阿婆自己种的柚子(虽然有些皱皮，时间久了，但是还是挺美味的啦)，感受到了山里人慢节奏的生活…嗯，没有更多的详细内容，要具体展开的话，我可以写一万字，看者可以亲自去体会下啦。</p><p>下面放上自己觉得还可以的照片啦—-</p><p><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/three_person_feet.jpg" alt="three_person_feet"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/hotel.jpg" alt="hotel"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/mountain01.jpg" alt="mountain01"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/mountain02.jpg" alt="mountain02"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/mountain03.jpg" alt="mountain03"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/motorcycle.jpg" alt="motorcycle"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/boat_and_mountain.jpg" alt="boat_and_mountain"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/school_grass.jpg" alt="school_grass"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/guilin_street_evening.jpg" alt="guilin_street_evening"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/two_towns.jpg" alt="two_towns"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/wedding_scene.jpg" alt="wedding_scene"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/delicious_food.jpg" alt="delicious_food"></p><p>文章的结尾简单谈下自己的一些攻略：</p><ol><li>广州出发的话，要提前坐交通工具到广州南站坐高铁，自己就是刚踩点过了安检，感觉就是在作死啊</li><li>广州南站出发到桂林，建议买到桂林站<del>(其次是桂林北)</del>，因为你可以在那边比较方便在繁华的地方租到房子，费用大概¥ 100/晚。当然啦，选择旅游淡季去，并且选择网购旅店，实体店买贵了¥40（我选择在西城步行街那里的青皮树酒店住下，网购¥99/晚，在那里可以逛夜市，并且离两江四湖比较近）</li><li>从桂林市区去阳朔的话，选择滴滴顺风车<del>（免费为滴滴打了一波广告）</del>，选择滴滴，当然是因为实惠啦，如果正常坐大巴过去阳朔的话，时间和金钱成本有所提升（看者可以自行比较呢）,我们从西城步行街滴滴顺风车过去阳朔的时间是一个小时左右，费用是¥33/人。从阳朔回来也是坐滴滴的顺风车。</li><li>在阳朔玩的时候，可以租借电驴（电动摩托）去玩，我们当初是¥40元/辆<del>滴滴司机说淡季一般是¥30/辆，看你砍价啦，我们从¥50/辆降到¥40/辆</del>，其他的景点看兴趣选择，进山必须是电驴啊，骑自行车踩累死你啦。</li><li>偶尔光顾阳朔街边的老奶奶老爷爷大叔大婶（请允许我这样称呼，年轻人没看到几个在路边摆摊的）</li><li>就餐的话，在桂林我推荐的是<code>椿记烧鹅</code>（倒数第二张餐厅图就是它）,在阳朔只要不在西街的饭店里面吃就行<del>(我们在饭店里面被坑了一次，东西贵而且味道不咋样，本来朋友要拉我走的，我都还没反应过来就点餐了)</del></li></ol><p>先就这么多攻略吧，后期如果有发现其他实用的我再放上去啦！😊 欢迎看者补充啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/life/tourist/guilin/guilin_banner.jpg&quot; alt=&quot;life/tourist/guilin/guilin-banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;桂林市区的两江四湖的夜景很美丽，还有桂林市区的一些步行街走起来挺舒服的。然后就是阳朔啦，我喜欢那山里的清新的空气(哈哈哈，不过，我更喜欢家里海边的空气)。在山里面就好像与世隔绝，可能一个人在喧闹的城市呆久了，都会喜欢吧。⚠️ 多图博文，手机党要留意咯。&lt;/p&gt;
    
    </summary>
    
      <category term="诗和远方" scheme="http://reng99.cc/categories/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
    
      <category term="旅游" scheme="http://reng99.cc/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>vue2.0 踩坑记</title>
    <link href="http://reng99.cc/2017/11/27/vue-attention/"/>
    <id>http://reng99.cc/2017/11/27/vue-attention/</id>
    <published>2017-11-27T13:10:52.000Z</published>
    <updated>2018-01-20T03:12:02.965Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/frontend/vuejs/attention/vue_attention_logo.jpg" alt="frontend/vuejs/attention/vue_attention_logo"></p><p>自己接触vuejs将近一年，在这段时间里面，一共参与了公司以vuejs技术为框架的两个项目—-工单系统（公司内部项目，不方便贴链接）和淘米淘手游交易平台移动端（未上线）。本文是自己在使用vuejs开发过程中踩到的坑，特此记录下来的文章。嗯，希望对相关的技术爱好者有所帮助啦<del>（如果你知道我在讲什么的话）</del> 😊</p><a id="more"></a><p>对了，在开始写文章之前，先说明下: 文章里面的代码，是在<code>.vue</code>后缀的文件中实现的，在脚手架<code>vue-cli</code>搭建的项目上已经验证过，如有疑问，请自行验证或者在文章底部留言功能那里留言(仅支持<a href="https://github.com/" target="_blank" rel="noopener">github</a>账号用户),或者邮箱留言(1837895991@qq.com)哦。</p><h2 id="父组件传递消息给子组件"><a href="#父组件传递消息给子组件" class="headerlink" title="父组件传递消息给子组件"></a>父组件传递消息给子组件</h2><p>使用props，下面先来看一个简单的例子:</p><p>父组件: parent.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"parent"</span>&gt;</span><br><span class="line">        &lt;child-component :title=<span class="string">'parentTitle'</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> childComponent <span class="keyword">from</span> <span class="string">'@/components/path/to/childComponent.vue'</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                parentTitle: <span class="string">'title form parent'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            childComponent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">    #parent&#123;&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>子组件: childComponent.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"child"</span>&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    export default &#123;</span></span><br><span class="line"><span class="regexp">        data () &#123;</span></span><br><span class="line"><span class="regexp">            return &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        props: &#123;</span></span><br><span class="line"><span class="regexp">            title: &#123;</span></span><br><span class="line"><span class="regexp">                type: String,   /</span><span class="regexp">/ 可设置类型</span></span><br><span class="line"><span class="regexp">                default: 'title from child'     /</span><span class="regexp">/ 默认值</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    #child&#123;&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>最后显示的结果是父亲传过来的消息，即信息为<code>title form parent</code>的h1标题。在父组件向子组件传递消息的过程中，首先，父亲需要拿到子组件<code>&lt;child-component /&gt;</code>,然后告诉子组件我要传递一个title给你<code>:title=&#39;parentTitle&#39;</code>，注意查收。接着，子组件通过<code>props</code>新建一个title的属性，并将数据读取到数据填充到相应的位置。详情看<a href="https://cn.vuejs.org/v2/guide/components.html#Prop" target="_blank" rel="noopener">官网Prop</a></p><h2 id="子组件传递消息给父组件"><a href="#子组件传递消息给父组件" class="headerlink" title="子组件传递消息给父组件"></a>子组件传递消息给父组件</h2><p>子组件是通过<code>$emit</code>向父组件发送事件和相关的数据，来传递信息给父组件。</p><p>子组件(child.vue)的demo代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=<span class="string">"child"</span>&gt;</span><br><span class="line">&lt;button @click=<span class="string">"toParent"</span>&gt;向父组件传递消息&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">name: "child",</span></span><br><span class="line"><span class="regexp">data () &#123;</span></span><br><span class="line"><span class="regexp">return &#123;</span></span><br><span class="line"><span class="regexp">message: 'message from children'</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">methods: &#123;</span></span><br><span class="line"><span class="regexp">toParent () &#123;</span></span><br><span class="line"><span class="regexp">var vm = this;</span></span><br><span class="line"><span class="regexp">vm.$emit('child-say',vm.message);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>父组件demo代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=<span class="string">"parent"</span>&gt;</span><br><span class="line">&lt;child-component :child-say=<span class="string">"parentEvent"</span> /&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import childComponent from '@/</span>components/path/to/child.vue<span class="string">';</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">name: '</span>parent<span class="string">',</span></span><br><span class="line"><span class="string">data () &#123;</span></span><br><span class="line"><span class="string">return &#123;</span></span><br><span class="line"><span class="string">msg : '</span><span class="string">'</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">methods: &#123;</span></span><br><span class="line"><span class="string">parentEvent: function (data) &#123; // data 是子组件传过来的数据</span></span><br><span class="line"><span class="string">var vm = this;</span></span><br><span class="line"><span class="string">vm.msg = data;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">components: &#123;</span></span><br><span class="line"><span class="string">childComponent</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码的过程是，点击了子组件里面的<code>向父组件传递消息</code>的按钮，将子组件里面的<code>message</code>信息放在<code>$emit</code>里面发送给父组件，而父组件在引用的子组件中新建一个事件来接受传过来的信息，然后在父组件中创建的方法对<code>data</code>里面的msg进行数据的改写。最终在页面上显示出的<code>h1</code>标题信息为<code>message from children</code>，即是子组件里面的信息。嗯，官网相关<a href="https://cn.vuejs.org/v2/api/#vm-emit" target="_blank" rel="noopener">传送门</a></p><h2 id="绑定HTML-Class"><a href="#绑定HTML-Class" class="headerlink" title="绑定HTML Class"></a>绑定HTML Class</h2><p>类名结合style的使用一般是用来动态改变样式，所以要用到<code>v-bind:class</code><br>简写<code>:class</code>。</p><p>demo如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"default-bg"</span> :<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123;'active-bg':flag&#125;"</span> @click=<span class="string">"changeBtnBg"</span>&gt;按钮&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">data () &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">flag : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">changeBtnBg: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">vm.flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">.default-bg&#123;</span></span><br><span class="line"><span class="regexp">background: red;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">.active-bg&#123;</span></span><br><span class="line"><span class="regexp">background: blue;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，实现了一个<code>红色按钮通过点击自身实现变成绿色按钮的功能</code>。首先，自己给到一个默认的红色的按钮，并且在按钮上绑定了<code>changeBtnBg</code>的方法，用于控制标志符<code>flag</code>的布尔值。值得注意的是，<code>:class</code>通过<code>flag</code>的真假值来决定是否改变按钮的背景色为定义的绿色。官网相关请戳<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#main" target="_blank" rel="noopener">这里</a></p><h2 id="v-model引用的数据需初始化"><a href="#v-model引用的数据需初始化" class="headerlink" title="v-model引用的数据需初始化"></a>v-model引用的数据需初始化</h2><p>也许你遇到这个问题，命名写了<code>&lt;input type=&quot;text&quot; v-model=&quot;inputMsg&quot; /&gt;</code>,可是相关的数据绑定<code>&lt;div&gt;&lt;/div&gt;</code>却没有消息，并报错。这是因为你还没有初始化相关的数据啊。正确的姿势应该像下面👇</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"inputMsg"</span>/&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;inputMsg&#125;&#125;&lt;div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">data () &#123;</span></span><br><span class="line"><span class="regexp">return &#123;</span></span><br><span class="line"><span class="regexp">inputMsg : ''  /</span><span class="regexp">/ 记得初始化数据哦</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h2 id="style中的scoped"><a href="#style中的scoped" class="headerlink" title="style中的scoped"></a>style中的scoped</h2><p>也许你注意到了我上面的代码中，在每个<code>&lt;style&gt;&lt;style&gt;</code>的元素中添加了<code>scoped</code>。scoped是用来限定样式的作用的范围，防止此组件里面的样式和其他组件的同名的样式产生冲突。比如—-</p><p>component1.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1 id = <span class="string">"title"</span>&gt;component1<span class="string">'s title&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string">&lt;style scoped&gt;</span></span><br><span class="line"><span class="string">#title&#123;</span></span><br><span class="line"><span class="string">color: red;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure><p>component2.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1 id=<span class="string">"title"</span>&gt;component2<span class="string">'s title&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string">&lt;style scoped&gt;</span></span><br><span class="line"><span class="string">#title&#123;</span></span><br><span class="line"><span class="string">color: blue;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的两个组将<code>component1.vue &amp;&amp; component2.vue</code>中，虽然都有相同的id，但是对各自没什么影响。简单说，加上scoped之后，样式的编写只对本组件有效。</p><p style="color:red;text-align:center;">精力有限，未能一次性更新完,忘见谅…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/frontend/vuejs/attention/vue_attention_logo.jpg&quot; alt=&quot;frontend/vuejs/attention/vue_attention_logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;自己接触vuejs将近一年，在这段时间里面，一共参与了公司以vuejs技术为框架的两个项目—-工单系统（公司内部项目，不方便贴链接）和淘米淘手游交易平台移动端（未上线）。本文是自己在使用vuejs开发过程中踩到的坑，特此记录下来的文章。嗯，希望对相关的技术爱好者有所帮助啦&lt;del&gt;（如果你知道我在讲什么的话）&lt;/del&gt; 😊&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://reng99.cc/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="vuejs" scheme="http://reng99.cc/tags/vuejs/"/>
    
      <category term="mvvm" scheme="http://reng99.cc/tags/mvvm/"/>
    
  </entry>
  
  <entry>
    <title>丹霞山旅游</title>
    <link href="http://reng99.cc/2017/11/26/tourist-danXia-mountain/"/>
    <id>http://reng99.cc/2017/11/26/tourist-danXia-mountain/</id>
    <published>2017-11-26T08:10:53.000Z</published>
    <updated>2017-11-26T16:12:43.848Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/tickets.jpg" alt="life/tourist/danxia/tickets"></p><p>由于公司的项目–<a href="https://www.taomitao.com/" target="_blank" rel="noopener">淘米淘手游交易平台</a>,自己已经有三个月没有离开过广州游玩了。刚好项目自己负责的部分已经ok，然后好友约了周末(2017.10.28～2017.10.29)去韶关爬丹霞山，自己不假思索的答应了！</p><a id="more"></a><p>我们是四个人一同前往—-两位女生两位男生，同行的四个人中，我只认识我的好友(那个肥嘟嘟脸的男生)，不认识两位女生，因为在旅行完之后没有联系了，忘了她们的名字了，暂且用女生A(戴帽子笑起来很甜的女生)和女生B(一直被吐槽摆不好poss的女生😂 )来区分吧。四人组见下图 :<br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/we.jpg" alt="life/tourist/danxia/we"></p><p>女生A : 好美啊！空气很好<br>女生B : 周末来得值啊，下次还来<br>好友 : 这山爬得都不累<br>我 : 能在这里住真是超级幸福的<br>…<br>以下省略若干在归途中的对话。是啊，这趟来得很ok啊，重阳节在这么美的地方爬山，真的是超级满足的呢。</p><p>我们这两天的计划是，去山顶上看日落和日出，剩下的时间就是在山间闲逛，感受自然。计划如此，除了没能在山顶（人太多，登不上阳元山的顶部看日落，只能够在山腰山看日落了）。</p><p>我们早上从广州火车站出发，坐火车直达韶关东，然后坐大巴去丹霞山，买了低配版的门票（150元/人的48小时有效的票）进入丹霞山里面，在兜兜转转后还是女生B电话给来过的同事请教攻略，果断的拒接了在景区山脚下拉客的旅店店主，坐着<code>免费的公交</code>（其实费用包含在票价里面了）兜兜转转的去到被推荐的景区里面当地人的旅店住下。此刻必须赞一下店主啊—-因为我们选好房间后，直接将随身带的行李放到各自的房间后就去吃午餐了没登记个人信息，但是店主知道有人介绍过来的并没有叫我们返回登记，还有店主很是热心的比划着路线给我们。对了，我们住的店是<a href="http://hotels.ctrip.com/hotel/4216382.html?isFull=F#ctm_ref=hod_sr_lst_dl_n_1_1" target="_blank" rel="noopener">放假啦客栈</a>，租了两间双人房（100元/天，ps:当地人的房子改装的租房，整片区域的价格都差不多）。</p><p>来到丹霞山的第一天，简单的吃了顿午饭，我们一行四人就奔着看日出的地点<code>长老峰</code>那里踩点去了，因为观日出的地方<code>阳元山</code>在另一边，得提前熟悉下呢。然后我们就坐车返回原地走路去<code>阳元山</code>看日落，可能我们去的比较晚又加上那天是<code>重阳节</code>,人多得我们上不了山顶，只能在山腰上观看了。对了，比较逗的是，爬<code>阳元山</code>的女生A因为山路陡恐高症瞬间爆发，腿软难以前行。<br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/sunset.jpg" alt="life/tourist/danxia/sunset"></p><p>第二天早上，我们五点就起床等车去<code>长老峰</code>看日出，这个点，公交的站点已经聚集了些人，此时天空还是可以看到星星几点。我们被送到长老峰不远处的终点站，大概是5:40分开始刷票进入长老峰，并沿着路灯一路爬上山顶。漆黑的凌晨借助着微弱的灯光，小心翼翼的爬着陡峭的山路，一大早就出着汗，还是第一次。我们爬到山顶的时候，有很多的人已经在山顶的平台了，我们很是难挤到里面去（对了，有人山顶上依靠帐篷过夜的）。选好一个不错的位置，在天边泛白的时候，踮着脚尖，看着太阳慢慢的奔出来，很是满足。<br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/sunrise1.jpg" alt="life/tourist/danxia/sunrise1"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/sunrise2.jpg" alt="life/tourist/danxia/sunrise2"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/sunrise3.jpg" alt="life/tourist/danxia/sunrise3"></p><p>之后，在日出一段时间后，我们便下山根据地图，依据着店主推荐的路线去逛下其他的风景，神奇的是，我们真能走，又闲逛了好远的地方，期间自己还担任了女生A的摄影师，哈哈哈，我的拍照技术还是ok的啦。四人组边走边聊，从本来有些约束到自然交流，在山间中走动，那山很俊，那林很绿，那水很清，倍感轻松😄<br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/idiom1.jpg" alt="life/tourist/danxia/idiom1"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/idiom2.jpg" alt="life/tourist/danxia/idiom2"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/idiom3.jpg" alt="life/tourist/danxia/idiom3"><br><img src="http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/idiom4.jpg" alt="life/tourist/danxia/idiom4"></p><p>对了，在吃的方面，我们在同一家店吃了走地鸡，味道棒棒的（原谅我忘记了店名），还有客家三宝这道菜，自己蛮喜欢的。</p><p>时间到了29号三四点的时候，我们就启程离开景区回广州了，结束丹霞山的两日游。</p><p>在本次的游玩中，自己整理了点旅游攻略，希望对见者有帮助或者重游的时候有提示：</p><ul><li>提前两三天联系景区的旅店老板，定好房间。有下面的原因：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 景区内和景区外的住房的价格是相差不大的，尽量在景区内订房，这样会节省你很多的时间</span><br><span class="line">2. 需要提前联系旅店的老板帮你定景区的票，这样会为你省下不少的经费（吐槽下，外来人的票价和当地人的票价相差太远）</span><br><span class="line">3. 寻找有去过丹霞山的朋友，取一下当初居住的旅店的老板的联系方式，在那里订房会得到一定程度的照顾</span><br></pre></td></tr></table></figure><ul><li><p>两天时间丹霞山游玩足够</p></li><li><p>过去韶关的话，如果经济条件还可以的话，还是不要选择火车吧</p></li><li><p>不要在什么国庆节啊节日过去，尽量选择周末</p></li><li><p>多多欣赏自然风光，拍照不游玩，游玩不拍照</p></li><li><p>学好拍照技术出去玩会更加惬意哦(带上专业的摄像机更好呢)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omu538iq8.bkt.clouddn.com/life/tourist/danxia/tickets.jpg&quot; alt=&quot;life/tourist/danxia/tickets&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于公司的项目–&lt;a href=&quot;https://www.taomitao.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;淘米淘手游交易平台&lt;/a&gt;,自己已经有三个月没有离开过广州游玩了。刚好项目自己负责的部分已经ok，然后好友约了周末(2017.10.28～2017.10.29)去韶关爬丹霞山，自己不假思索的答应了！&lt;/p&gt;
    
    </summary>
    
      <category term="诗和远方" scheme="http://reng99.cc/categories/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
    
      <category term="旅游" scheme="http://reng99.cc/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
</feed>
