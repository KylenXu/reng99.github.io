<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css清除浮动]]></title>
    <url>%2F2018%2F07%2F03%2Fclear-float%2F</url>
    <content type="text"><![CDATA[浮动对页面的影响：如果一个父盒子中有一个子盒子，并且子盒子没有设置高，子盒子在父盒子中进行浮动，那么将来父盒子的高度为0，由于父盒子的高度为0，下面的元素会自动补位，所以这个时候有必要进行浮动的清除。 下面代码来掩饰如何清除浮动： 原代码 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;清除浮动的方法&lt;/title&gt; &lt;style type="text/css"&gt; .outer&#123; background: #999; &#125; .red&#123; width:100px; height: 100px; background:red; &#125; .blue&#123; width:100px; height:100px; background: blue; &#125; .other&#123; width:300px; height: 30px; background:yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="outer"&gt; &lt;div class="red"&gt;&lt;/div&gt; &lt;div class="blue"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="other"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 原效果： 为红色和绿色方块添加左浮动后 原代码 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;清除浮动的方法&lt;/title&gt; &lt;style type="text/css"&gt; .outer&#123; background: #999; &#125; .red&#123; float: left; width:100px; height: 100px; background:red; &#125; .blue&#123; float: left; width:100px; height:100px; background: blue; &#125; .other&#123; width:300px; height: 30px; background:yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="outer"&gt; &lt;div class="red"&gt;&lt;/div&gt; &lt;div class="blue"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="other"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其效果为– 方法一：使用overflow属性来清除浮动1234.outer&#123; overflow:hidden;&#125; 先找到浮动盒子的父元素（盒子），在父元素中田间一个属性overflow:hidden，就是清除这个父元素中的子元素浮动对页面的影响。 效果如下： 注意：一般情况下不会使用这种方式，因为overfloat:hidden有一个特点，离开了这个元素所在的区域之后会被隐藏（overflow:hidden会将超出的部分隐藏起来）。 方法二：使用额外的标签这又分两种情况– 内部标签1234567&lt;div class="outer"&gt; &lt;div class="red"&gt;&lt;/div&gt; &lt;div class="blue"&gt;&lt;/div&gt; &lt;div style="clear:both;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="other"&gt;&lt;/div&gt; 放在浮动元素的父元素里面，效果如下图： 外部标签1234567&lt;div class="outer"&gt; &lt;div class="red"&gt;&lt;/div&gt; &lt;div class="blue"&gt;&lt;/div&gt; &lt;div style="clear:both;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="other"&gt;&lt;/div&gt; 放在浮动元素父元素同级位置，最终效果如下： 这两种种清除的方式有下面的特点： 1.内部标签：会将这个浮动盒子的父盒子的高度重新撑开 2.外部标签：会将这个浮动盒子的影响清除，但是不会撑开父盒子。 注意：⚠️一般情况下不会使用这种方式来清除浮动。因为这种清除浮动方式会增加页面的标签，造成机构混乱。 方法三：使用伪元素:afterouter利用其伪类clear:after在元素内部增加一个类似div.clear的效果。 12345678910111213.outer &#123; /*==for IE6/7 Maxthon2 为了兼容IE==*/ zoom:1; &#125; .outer:after&#123; content:"."; /*可以取值，也可以为空*/ clear:both; display: block; width:0; height: 0; visibility: hidden;／*visibility:hidden;的作用是允许浏览器渲染它，但是不显示出来*／ &#125; 这是网上使用比较广泛，拉风的清除方式。 其效果如下： 方法四：使用双伪元素清除浮动123456789.outer &#123; /*==for IE6/7 Maxthon2 为了兼容IE==*/ zoom:1; &#125; .outer:after,.outer:before&#123; content:"."; /*取值只能为空*/ clear:both; display: block; &#125; 其效果如下： 总结 第一种方法会将超出部分隐藏，在某些时候我们想清除浮动并且保留超出部分的时候做不到。 第二种方法会增加不必要的标签。 所以我们选择第三种方法来清除浮动。 为什么不选择第四种来清除呢？因为第四种是第三种的改良版，虽然比较简便，但是不够严谨，比如content的内容不为空的时候，会出现问题，感兴趣的话可以自行尝试下咯。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列]]></title>
    <url>%2F2018%2F06%2F18%2Falgorithm-hash%2F</url>
    <content type="text"><![CDATA[散列是一种常用的数据存储技术，散列后的数据可以进行快速地插入或取用。散列使用的数据结构叫做散列表（hash table, 也叫哈希表）。在散列表中插入、删除和取用数据都非常快，但是对于查找操作来说却效率低下，比如查找一组数据中的最大或者最小值。 散列算法的作用是尽可能快地在数据结构中找到一个值。在前面几个博文中提到的数据结构，我门如果在数据结构中获取一个值（使用get方法），需要遍历整个数据库来找到它。如果使用散列函数，就知道值的具体位置，因此你能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址。 见下图的例子（散列函数这里取ascii值相加-电子邮件地址薄）： 创建一个散列表搭建散列表类如下： 1234function HashTable() &#123; var table = [];&#125; 简单的散列函数如下（取上图的ascii值）: 12345678var loseloseHashCode = function(key) &#123; var hash = 0; for(var i = 0; i &lt; key.length; i++)&#123; hash += key.charCodeAt(i); &#125; return hash % 37;&#125; 基本完整代码hash表的简单demo的基本完整代码如下： 1234567891011121314151617181920212223242526272829var loseloseHashCode = function(key) &#123; var hash = 0; for(var i = 0; i &lt; key.length; i++)&#123; hash += key.charCodeAt(i); &#125; return hash % 37;&#125;function HashTable() &#123; var table = []; // 向散列表中增加一个新的项（也能更新散列表） this.put = function(key , value) &#123; var position = loseloseHashCode(key); console.log(position + ' - ' + key); table[position] = value; &#125;; // 返回检索到的特定的值 this.get = function (key) &#123; return table[loseloseHashCode(key)]; &#125;; // 根据键值从散列表中移除值 this.remove = function(key) &#123; table[loseloseHashCode(key)] = undefined; &#125;&#125; 业余时间补充…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>散列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字典]]></title>
    <url>%2F2018%2F06%2F18%2Falgorithm-dictionary%2F</url>
    <content type="text"><![CDATA[在字典中，存储的是[键,值]对，其中键名是用来查询特定元素的。字典和之前介绍的集合很相似，集合以[值,值]的形式存储元素，字典则是以[键,值]的形式来存储元素。字典也称做映射。 字典类字典类和之前介绍的集合类一样，基本的骨架如下: 123function Dictionary() &#123; var items = &#123;&#125;; // 存放数据&#125; 完整代码因为其和集合很是相似，部分的代码可以使用集合的代码，比如清空字典，字典的大小等等。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function Dictionary() &#123; var items = &#123;&#125;; //判断是否存在键-值 this.has = function(value) &#123; return value in items; &#125;; // 也可以是使用hasOwmProperty来实现 this.has = function(value) &#123; return items.hasOwnProperty(value); &#125;; // 设置新元素 this.set = function(key,value)&#123; items[key] = value; &#125;; // 展示字典的数据 this.values = function() &#123; // 临时存放数据 var values = &#123;&#125;; for(var k in items)&#123; if(this.has(k))&#123; values.push(items[k]); &#125; &#125; return values; &#125;; // 移除元素 this.remove = function(key) &#123; if(this.has(key))&#123; // 删除 delete items[key]; return true; &#125; return false; &#125;; // 获取特定的项 this.get = function(key)&#123; return this.has(key) ? items[key] : undefined; &#125;; // 清空集合中所有值 this.clear = function() &#123; items = &#123;&#125;; &#125;; // 获取集合的数量 // 下面的实现是在现代浏览器才能使用，当然借助babel可以转换成所有浏览器识别的代码 this.size = function() &#123; return Object.keys(items).length; &#125;; // 所有浏览器都可以运行 this.size = function() &#123; var count = 0; for(var prop in items)&#123; if(items.hasOwnProperty(prop))&#123; ++count; &#125; return count; &#125; &#125;; &#125; 更多的代码请查看https://github.com/reng99/algorithm。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合]]></title>
    <url>%2F2018%2F06%2F18%2Falgorithm-set%2F</url>
    <content type="text"><![CDATA[集合(Set)是一种包含不同元素的数据结构。集合中的元素称为成员，集合的两个最重要的特性是：首先，集合中的成员是无序的；其次，集合中不允许相同成员的存在。 集合的定义 不包含任何成员的集合称为空集{}，全集则是包含一切可能成员的集合。 如何两个集合的成员完全相同，则称两个集合相等。 如果一个集合中所有的成员都属于另外一个集合，则前一集合称为后一个集合的子集。 集合的操作对集合的操作基本是下面三种： 并集: 将两个集合中的成员进行合并，得到一个新的集合。 交集: 两集合中共同存在的成员组成一个新的集合。 差集: 属于一个集合而不属于另一个集合的成员组成的集合。 子集: 验证一个给定集合是否是另一个集合的子集。 创建集合类这里还是使用构造函数进行创建集合类: 123function Set() &#123; // some code here ...&#125; 这里我们将使用对象来表示集合var items = {}，集合的键-值是相同的。当然，你也可以使用数组来表示，但是不够直观。而使用对象一个好处是，javascript的对象不允许一个键指向两个不同的属性，保证了集合里的元素都是唯一性的。 完整代码基本的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134function Set() &#123; // 选择对象而不是数组来表示集合 var items = &#123;&#125;; //判断是否存在键-值 this.has = function(value) &#123; return value in items; &#125;; // 也可以是使用hasOwmProperty来实现 this.has = function(value) &#123; return items.hasOwnProperty(value); &#125;; // 添加元素 this.add = function(value) &#123; if(!this.has(value))&#123; items[value] = value; return true; &#125; return false; &#125;; // 提取items对象，返回所有属性，以数组形式返回 // 下面的实现是在现代浏览器才能使用，当然借助babel可以转换成所有浏览器识别的代码 this.values = function() &#123; return Object.keys(items); &#125;; // 下面的实现在任何浏览器上可以运行 this.values = function() &#123; var keys = []; for(var key in items)&#123; keys.push(key); &#125; return keys; &#125;; // 移除一个元素 this.remove = function(value) &#123; if(this.has(value))&#123; delete items[value]; return true; &#125; return false; &#125;; // 清空集合中所有值 this.clear = function() &#123; items = &#123;&#125;; &#125;; // 获取集合的数量 // 下面的实现是在现代浏览器才能使用，当然借助babel可以转换成所有浏览器识别的代码 this.size = function() &#123; return Object.keys(items).length; &#125;; // 所有浏览器都可以运行 this.size = function() &#123; var count = 0; for(var prop in items)&#123; if(items.hasOwnProperty(prop))&#123; ++count; &#125; return count; &#125; &#125;; // 并集 this.union = function(otherSet)&#123; // 定义一个并集 var unionSet = new Set(); // 本集合对象 var values = this.values(); for(var i = 0; i &lt; values.length; i++)&#123; unionSet.add(values[i]); &#125; // 已知的另外一个集合对象 values = otherSet.values(); for(var i = 0 ; i &lt; values.length; i++)&#123; unionSet.add(values[i]); &#125; return unionSet; &#125;; // 交集 this.intersection = function(otherSet) &#123; // 定义一个交集 var intersectionSet = new Set(); var values = this.values(); for(var i = 0; i &lt; values.length; i++)&#123; if(otherSet.has(values[i]))&#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet; &#125;; // 差集 this.difference = function(otherSet) &#123; // 定义一个差集 var differenceSet = new Set(); var values = this.values(); for(var i = 0; i &lt; values.length; i++)&#123; if(!otherSet.has(values[i]))&#123; differenceSet.add(values[i]); &#125; &#125; return differenceSet; &#125;; // 子集 this.subset = function(otherSet) &#123; // 如果个数越界肯定不是子集了 if(this.size() &gt; otherSet.size())&#123; return false; &#125; else &#123; var values = this.values(); for(var i = 0; i &lt; values.length ; i++)&#123; // 只要有一个元素不再另外的集合里面，则不是子集 if(!otherSet.has(values[i]))&#123; return false; &#125; &#125; return true; &#125; &#125;;&#125; 更多的代码请查看https://github.com/reng99/algorithm。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2018%2F06%2F17%2Falgorithm-linked-list%2F</url>
    <content type="text"><![CDATA[链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称为指针或链接，通常叫指针）组成。自己无聊的时候还翻译一点维基百科上的链表的介绍。 数组的缺点在栈和队列数据结构中，存储数据我们是使用了数组的形式。但是，数组不总是组织数据的最佳的结构。原因如下： 数组被实现成对象，与其他语言（比如C++和Java）的数组相比，效率很低。【主要原因】 数组的长度是固定的，所以当数组已被数据填满的时，再要加入新的元素会非常困难。 从数组的起点或中间插入或移除项的成本很高。虽然splice等方法能帮方便的实现，但是背后的原理还是需要移动元素。 所以，当数组的代价高的时候，需要考虑其他的数据结构，比如现在要说的链表。 创建链表类通过一个构造函数创建链表类: 123function LinkedList() &#123; // somecode here ...&#125; 节点数据也是使用一个类进行存放，这里我们叫做Node类： 1234function Node(element)&#123; this.element = element; this.next = null;&#125; 完整代码链表的基本的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155function LinkedList() &#123; // 辅助类 var Node = function(element) &#123; this.element = element; // 存放数据 this.next = null; // 存放指针 &#125;; // 链表的长度 var length = 0; // 初始化头指针为空 var head = null; // 向链表尾部追加元素 this.append = function(element)&#123; // 创建一个node节点 var node = new Node(element), current; // 当前的指向节点/元素 if(head == null)&#123; // 列表中的第一个节点 head = node; &#125; else &#123; current = head; // 循环列表，直到找到最后一项 while(current.next)&#123; current = current.next; &#125; // 找到追后一项，将next赋值为node，建立链接 current.next = node; &#125; // 更新链表的长度 length++; &#125;; // 从链表中移除元素,通过指定位置移除 this.removeAt = function(position)&#123; // 检查指定移除的position是否越界 if(position &gt; -1 &amp;&amp; position &lt; length)&#123; // 未越界 var current = head, // 当前元素指向头节点 previous, // 上一个节点 index = 0; // 节点的索引 // 移除第一项 if(position == 0)&#123; head = current.next; &#125; else&#123; while (index++ &lt; position)&#123; previous = current; current = current.next; &#125; // 将previous与current的下一项链接起来：跳过current，从而移除它 previous.next = current.next; &#125; // 链表长度减一 length--; // 返回删除的元素 return current.element; &#125;else&#123; // position越界的情况 return null; &#125; &#125;; // 任意位置插入一个元素 this.insert = function(position , element)&#123; // 检查position是否越界 if(position &gt;= 0 &amp;&amp; position &lt;=length)&#123; var node = new Node(element), // 新建一个节点 current = head, // 初始当前节点指向头节点 previous, // 前一个节点 index = 0; // 默认索引从第一个开始 if(position == 0)&#123; // 在第一个位置添加元素 node.next = current; head = node; &#125; else &#123; while(index++ &lt; position)&#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; &#125; // 更新列表长度 length++; return true; &#125; else&#123; // position越界 return false; &#125; &#125;; // 将LinkedList对象转换成一个字符串 this.toString = function() &#123; var current = head, string = ''; while(current)&#123; string += current.element; current = current.next; &#125; return string; &#125;; // 查找元素在链表中的位置 this.indexOf = function(element) &#123; var current = head; index = 0; while(current)&#123; if(element == current.element) &#123; return index; &#125; index++; current = current.next; &#125; // 找不到元素 return -1; &#125;; // 链表中移除元素，通过指定移除的元素 this.remove = function(element) &#123; var index = this.indexOf(element); return this.removeAt(index); &#125;; // 检查链表是否为空 this.isEmpty = function() &#123; return length == 0; &#125;; // 获取链表的长度 this.size = function() &#123; return length; &#125;; // 获取链表的头节点 this.getHead = function() &#123; return head; &#125; &#125; 更多的代码请查看https://github.com/reng99/algorithm。 循环链表上面所说的链表是单链表。尽管从链表的头节点遍历到尾节点很简单，但反过来，从后向前遍历九没有那么简单了。这时候我们可以通过给Node对象增加一个头指针的属性就容易多了。 Node类就变成下面这样了： 12345function Node(element) &#123; this.element = element; this.next = null; this.prev = null;&#125; 整个双向链表的类如下: 12345678910111213function DoublyLinkedList() &#123; var Node = function(element) &#123; this.element = element; this.next = null; this.prev = null; // 新增的前指针 &#125;; var length = 0; var head = null; var tail = null; // 新增的尾节点 // methods here ...&#125; 其相关的方法和单链表的方法是大同小异，还有一个循环链表也是差不多啦。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2018%2F06%2F17%2Falgorithm-queue%2F</url>
    <content type="text"><![CDATA[队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列在队尾添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。 定义一个队列类类似创建栈，创建队列也是使用构造函数： 123function Queue() &#123; // 这里是属性和方法&#125; 存放数据也是使用一个数组var items = []。 完整的基本代码直接上基本的完整代码和相关的代码注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445function Queue() &#123; // 存储数据的结构 var items = []; // 入队，相当于入栈 this.enqueue = function(element) &#123; items.push(element); &#125;; // 出队，相当于出栈 this.dequeue = function() &#123; return item.shift(); &#125; // 队首，队列的第一个元素 this.front = function() &#123; return items[0]; &#125;; // 队尾，队列的最后一个元素 this.end = function() &#123; return items[items.length - 1]; &#125;; // 检查队列是否是空的队列 this.isEmpty = function() &#123; return items.length == 0; &#125;; // 将队列置空 this.clear = function() &#123; items = []; &#125;; // 队列的长度 this.size = function() &#123; return items.lenght; &#125;; // 展示/打印队列信息 this.print = function() &#123; console.log(items.toString()); &#125;&#125; 基本的代码跟之前的栈的代码是大同小异，更多的代码请查看https://github.com/reng99/algorithm]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2018%2F06%2F16%2Falgorithm-stack%2F</url>
    <content type="text"><![CDATA[栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保留在栈的末尾，称为栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都靠近栈底。 定义一个栈类使用构造函数来定义一个栈类： 123function Stack ()&#123; // 各种属性和方法的声明&#125; 这里定义的存放的数据结构是数组。var item = []。 入栈数组本身就有方法push进来一个内容，这里也是使用这个方法，我们来写一下： 123function push(element)&#123; items.push(element);&#125; 出栈pop也是数组的方法，表示出栈，这里也是使用pop为函数名： 123function pop()&#123; return items.pop();&#125; 完整代码还有方法，比如返回栈顶元素，检查是否是空栈等。这里不展开讲，下面全列出代码： 123456789101112131415161718192021222324252627282930313233343536function Stack() &#123; // 定义存储的数据结构 var items = []; // 入栈，返回新的数组 this.push = function(element) &#123; items.push(element); &#125;; // 出栈，弹出栈顶元素 this.pop = function() &#123; return item.pop(); &#125;; // 获取栈顶元素 this.peek = function() &#123; return items[items.length-1]; &#125;; // 检查是否是空栈 this.isEmpty = function() &#123; return items.length == 0; &#125;; // 栈元素的个数 this.size = function() &#123; return items.length; &#125;; // 展示栈的元素 this.print = function() &#123; console.log(items.toString()); &#125;; &#125; 更多的代码请看https://github.com/reng99/algorithm]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript基础 -- 内部分享]]></title>
    <url>%2F2018%2F06%2F14%2Fjavascript-foundation%2F</url>
    <content type="text"><![CDATA[javascript不仅仅在前端比较重要（网页三剑客之一），在后端还是占有一席之地。本博文主要是介绍javascript的基础（主打es5标准）。 准备工作编写javascrip脚本不需要任何特殊的软件或者环境的配置，一个普通的文本编辑器和一个web浏览器就可以了。 相关的可运行的代码示例如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;demo&lt;/title&gt; &lt;script&gt; javascript goes here ... &lt;/script&gt; &lt;/head&gt; &lt;body&gt; mark-up goes here ... &lt;/body&gt;&lt;/html&gt; 语法Javascript的语法和Java与C++语言的语法非常相似。 语句在javascript中把各条语句放在不同的行上就可以分隔他们，比如： 12first statementsecond statement 如果是想放在同一行上，就必须像下面这样用分号来分隔它们： 12first statement; second statement; 为了养成一个良好的编程习惯，建议每条语句后面都添加一个分号。 注释注释能够有效得帮助你了解代码流程。在代码中扮演生活中的便条的角色，能够帮助看者弄清楚脚本到底在干什么。注释有多种方式，如下： 1234567// 这是单行注释/*这是多行注释*/&lt;!--这是在html页面中的注释--&gt; 变量javascript是松散型语言，在es6标准之前，其变量都是以var来进行定义。es6后就支持let，const等，这是后话了，这里主讲es5。当变量没有var定义的时候，浏览器会自动追加，但是，在不赋值的情况下会报错。 12345a; # Uncaught ReferenceError: a is not definedvar a ; # output is 'undefined'a = 100 ; # 100 相当于var a = 100; 数据类型javascript中数据类型包括基本类型和引用类型。基本类型是指简单的数据段，包括Undefined, Null, Boolean, Number 和 String；引用类型指那些可能由多个值构成的对象。我们可以使用typeof操作符进行检验： 123456'undefined' # 值未定义'boolean' # 布尔值'string' # 字符串'number' # 数值'object' # 值是对象或null , null 是历史遗留下来的问题'function' # 这个值是函数 操作要用javascript做一些有用的工作，需要能够进行计算和处理数据。也就是完成一些操作。 算术运算符简单的数字加减乘除就不多说了。数字的自加，自减也省略下。不过+号挺有意思的一个运算符号。它可以简单的数字的相加，也可以用于字符串的拼接，和数字转字符串： 123410 + 20 # 30'你好'+'name' # 你好name10 + '' # 1010 + '20' # 1020 条件语句基本的条件语句的语法如下： 123if(condition)&#123; statements;&#125; 运算符javascript提供了许多在条件语句里面使用的比较操作符，包括大于，小于，等于等等。返回的是一个布尔值。 还有一些逻辑运算符，比如&amp;&amp;和||等。 循环语句相对于条件语句，循环语句能够多次重复的执行代码。只要给定的条件满足，包含在循环语句里的代码就重复执行下去，一旦给定条件的求值结果不再是true，循环也就到此为止。 while循环相关的基本语法如下： 1234567while(condition)&#123; statements;&#125;或do&#123; statements;&#125; while (condition); for循环for循环重复执行一些代码也很方便，它类似于while循环。可以将while循环的代码改写下，称为for循环： 1234567891011initialize;while (condition)&#123; statements; increment;&#125;改写for(initial condition; test condition; alter condition)&#123; statement;&#125; 函数函数就是一组允许在你的代码里随时调用的语句。每个函数实际上就是一个短小的脚本。但是函数声明于函数表达式的调用又有所差别，见下面的代码： 1234console.log(sum(10 , 10)); // 20function sum(num1 , num2)&#123; return num1 + num2;&#125; 1234console.log(sum(10 , 10)); //TypeError: sum is not a functionvar sum = function(num1 , num2)&#123; return num1 + num2;&#125; 解析器会率先读取函数声明，并使其执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析。函数中有一个闭包的概念，感兴趣的可戳这里。 DOMDOM，文档对象模型。 文档：DOM中的D当创建了一个网页并把它加载到web浏览器中时，DOM就在幕后悄然而生了。浏览器会将你编写的网页文档转换成为一个文档对象。 对象：DOM中的O与某个特定对象相关联的变量被称为这个对象的属性。只能通过某个特定的对象去调用的函数被称为这个对象的方法。document对象的主要功能就是处理网页内容。 模型：DOM中的MDOM中的M代表了Model(模型)，但是说它代表着Map（地图）也未尝不可。模型也好，地图也罢，它们的含义都是某种事物的表现形式。就像一个模型火车代表一列真正的火者。DOM代表着加载到浏览器窗口的当前网页。浏览器提供了网页的地图（或者说模型），而我们可以通过javascript去读取这张地图。 节点在DOM里面有很多的节点，这里介绍三种：元素节点、文本节点和属性节点。 元素节点：DOM的原子就是元素节点。比如元素。 文本节点：比如content种标签包含的content。 属性节点：属性节点用来对元素作出更具体的描述。比如:mike中的title=&quot;name&quot;就是属性节点了。 获取元素有三种DOM方法可以获取元素节点，分别是通过元素ID、通过标签名字和通过类名字来获取。 getElementById 这个方法返回一个与那个有着给定id属性值的元素节点对应的对象。如document.getElementById(&#39;home&#39;) getElmentsByTagName 这个方法返回一个对象数组，每个对象分别对应文档里有着给定标签的一个元素。如document.getElementsByTagName(&#39;li&#39;) getElementsByClassName 这个方法能让我们通过class属性来访问元素。如document.getElementsByClassName(&#39;item&#39;) 当然我们还是可以通过querySelector,querySelectorAll来获取元素的，比如querySelector(‘.item’),它返回与该匹配模式的第一个元素，即类名是item的元素；querySelectorAll(‘.item’),返回的是一个NodeList实例。 获取和设置属性在获取到元素后，我们就可以设法获取它的属性。getAttribute方法就是用来做这件事的。相应的，setAttribute方法则可以更改属性节点的值。 getAttribute用法是object.getAttribute(attribute)，如下例子： 1234var paras = document.getElementsByTagName('p');for(var i = 0; i &lt; paras.length; i++)&#123; console.log(paras[i].getAttribute('title'));&#125; setAttribute用法是object.setAttribute(attribute,value)。它允许我们对属性节点的值作出修改。与getAttribute一样，setAttribute也只能用于元素节点。例子有： 12var shopping = document.getElementById('purchases');shopping.setAttribute('title','a list of goods'); BOMBOM，浏览器对象模型。 关于BOM具体指的是什么，可以参考DOM的解析。 window对象BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window有双重的角色，它既是通过javascript访问浏览器窗口的一个接口，又是规定的全局(Global)对象。这就意味着在网页中定义的任何一个对象，变量和函数，都是以window作为Global对象，因此有权访问parseInt()等方法。 窗口位置 用来确定和修改window对象位置的属性和方法很多。IE、Safari、Opera和Chrome（也可以说Trident内核、Webkit内核、Presto内核-&gt;目前废弃，改Blink内核、Blink内核）都提供了screenLeft和screenTop属性，分别表示用于窗口相对屏幕左边和上边的位置。Firefox（可以说是Gecko内核）则在screenX和screenY属性中提供相同的窗口信息，Safari和Chrome也同时支持这两个属性。Opera虽然也是支持screenX和screenY属性，但与screenLeft和screenTop属性并不对应。附上内核的说明链接。使用下列代码可以兼容到不同的浏览器： 123var leftPos = (typeof window.screenLeft == 'number') ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == 'number') ? window.screenTop : wnidow.screenY; 窗口大小 跨浏览器确定窗口大小不是一件容易的事情。虽然五大浏览器(上面窗口位置提到的浏览器就是了)都提供了innerWidth、innerHeight、outerWidth和outerHeight四个属性，但是不同浏览器和不同版本的相同浏览器的解析又是不一样。在 IE9+、Safari 和 Firefox 中，outerWidth 和 outerHeight 返回浏览器窗口本身的尺寸(无论是从最外层的 window 对象还是从 某个框架访问)。在 Opera 中，这两个属性的值表示页面视图容器1的大小。而 innerWidth 和 innerHeight 则表示该容器中页面视图区的大小(减去边框宽度)。在 Chrome 中，outerWidth、outerHeight 与 innerWidth、innerHeight 返回相同的值，即视口(viewport)大小而非浏览器窗口大小。 IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性;不过，它通过 DOM 提供了页面可见区域 的相关信息 虽然确定不了浏览器的大小，但是我们可以确定页面视口的大小。五大浏览器中，document.documentElement.clientWidth和document.documentElement.clientHeight上保存了页面视口的信息。在IE6中，这些属性必须在 标准模式下才有效;如果是混杂模式，就必须通过 document.body.clientWidth 和 document.body. clientHeight 取得相同信息。整个的兼容的代码如下： 123456789101112var pageWidth = window.innerWidth, pageHeight = window.innerHeight; if(typeof pageWidth != "number")&#123; // 针对IE8及以下版本 if(document.compatMode == 'CSS1Compat')&#123; // 标准模式下的低版本ie pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125;else&#123; // 混杂模式下的IE,Chrome pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 导航和打开窗口 window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。 1234window.open("http://www.wrox.com/","_blank","height=400,width=400,top=10,left=10,resizable=yes");# 参数一是url# 窗口名称# 窗口样式设置 更多内容感兴趣自己了解啦。 间歇调用和超时调用 123456789# 间歇调用setInterval(function()&#123; alert('hello')&#125;,1000);# 超时调用setTimeout(function()&#123; alert('hello')&#125;,1000); 系统对话框 浏览器通过alert(),confirm()和prompt()方法调用系统对话框向用户显示信息。在浏览器的控制台上面走一遍就知道了。 location对象location对象是一个很特别的对象，因为它既是window对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。location对象的用处不只表现在它保存当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。比如，hash,host,hostname,href,pathname,port,protocol,search。 navigator对象navigator对象提供了与浏览器有关的信息。到底提供了哪些新秀，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如userAgent）存在于所有浏览器中。更多的属性请戳这里 history对象history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为 history 是 window 对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的 history 对象与特定的 window 对象关联。 使用go()方法可以在用户的历史浏览记录中任意跳转。比如： 12345678# 后退一页history.go(-1); # 可以写成history.back()# 前进一页history.go(1); # 可以写成history.forward()# 前进两页history.go(2) 后话内部分享就到这里为止吧！自己之前有整理过一个《javascript高级程序设计》的内容，感兴趣请戳这里]]></content>
      <categories>
        <category>技术交流</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[d3js学习]]></title>
    <url>%2F2018%2F06%2F09%2Fd3js-learning%2F</url>
    <content type="text"><![CDATA[D3.js是一个基于数据处理文档的JavaScript库。D3帮助你使用HTML,SVG和CSS将数据呈现出来。D3依赖于标准的web技术来绘制可视化的元素。 介绍D3允许你将任意的数据绑定到文档对象模型(DOM)，然后将数据驱动的转换应用到文档中。比如，可以使用D3将数组数据生成一个HTML文档。或者，使用相同的数据创建具有平滑过渡和交互的交互式SVG条形图。 D3不是一个旨在提供所有可能功能的单一框架。相方的，D3解决了问题的关键：根据数据有效地处理文档。这就避免了专有代理，并提供了非凡的灵活性，展示了诸如HTML，SVG和CSS等网络标准的全部功能。以最小的开销，D3非常快，支持大数据集和动态行为以进行交互和动画。D3的功能风格允许通过各种官方和开发社区模块来重复使用代码。 选择使用W3C DOM API修改文档是很乏味的：方法名是冗长的，并且命令式的方法需要手动迭代和记账临时状态。比如下面改变段落的文字颜色： 1234&lt;p&gt; paragraph first &lt;/p&gt;&lt;p&gt; paragraph second &lt;/p&gt;&lt;p&gt;paragraph third &lt;/p&gt; 123456var paragraphs = document.getElementsByTagName('p');for(var i = 0; i &lt; paragraphs.length; i++)&#123; var paragraph = paragraphs.item(i); paragraph.style.setProperty('color','blue'); &#125; D3采用了一种声明式的方法，使用选择(selection)操作任意的节点集合。比如，我们可以重写上面的循环，如下： 12d3.selectAll('p').style('color','blue'); # 有点类似jquery的$('p') 当然，我们也可以根据需要操作单个节点： 12d3.select('body').style('background-color','black'); 选择器依据W3C选择器API定义，并被现代浏览器很好的支持。 D3提供了许多用于改变节点的方法：设置属性或样式；注册时间监听器；添加、删除或排序节点；和更改HTML或文字的内容。这些满足绝大多数需求。直接访问底层DOM也是可能的，因为每个D3选择只是一个节点数组。 动态属性熟悉其他DOM框架(如jquery)的读者能够立即意识到与D3的相似的地方。然而，D3中的样式，属性(attributes)和其他属性(properties)可以指定为数据的函数，而不仅仅是简单的常量。尽管它们看起来简单，但是这些功能很是强大。比如这个d3-shape。 下面来个例子，随机指定段落的颜色： 12345d3.selectAll('p').style('color',function()&#123; # H: Hue 色相(0-360) S：Saturation 饱和度(0-100) L Lightness 明度(0-100) return "hsl(" + Math.random() * 360 + ",100%,50%)";&#125;); 指定奇偶节点的灰色阴影的交替： 1234d3.selectAll('p').style('color',function(d , i)&#123; return i % 2 ? '#fff' : '#eee';&#125;); 计算属性通常指的是绑定数据。数据被指定是一个值数组，并且每个值都被作为第一个参数（d）传递给选择函数。使用默认的索引连接，数据数组中的第一个元素被传递给选择中的第一个节点，第二个元素被传递给第二个选择中的第二个节点，以此类推。比如，将数组数据绑定到段落元素中，就可以使用这些数据来动态计算字体的大小了： 123456d3.selectAll('p') .data([8,16,20]) .style('font-size',function(d)&#123; return d + 'px'; &#125;); 一旦数据绑定之后，我们就是可以省略数据运算符了；D3将检索先前绑定的数据。这允许我们重新计算属性而不需要重新绑定。 Enter 和 Exit使用D3的进入和退出选择，可以为传入的数据创建新节点，并删除不需要的传出节点。当数据绑定到选择器的时候，数组数据中的每个元素都与选择中的对应节点配对。如果节点的数量少于数据，则额外的数据形成输入选择，我们可以通过追加输入选择来实例。例如： 123456d3.select('body') .selectAll('p') .data([4,8,15,16,23,42]) .enter().append('p') .text(function(d)&#123;return "I'm number " + d + "!";&#125;) 更新节点是默认选择–数据运算符的结果。因此，如果忘记了enter和exit选择器，你将只会自动选择存在的相应数据的元素。一种常见的模式是将初始选择分为三部分：要更新的更新节点，要添加的输入节点以及要移除的现有节点。 12345678910111213// Updata...var p = d3.select('body') .selectAll('p') .data([4,8,15,16,23,42]) .text(function(d) &#123; return d; &#125;); // Enter...p.enter().append('p') .text(function(d) &#123; return d; &#125;); // Exit...p.exit().remove(); 通过分别处理这三种情况，我们可以准确地指定在哪些节点上运行哪些操作。这可以提高性能并提供对转换的更好控制。例如，对条形图，我们可以使用旧比例初始化输入条，然后将输入条更新为新比例以及退出。 D3让我们能根据数据来转换成文档，包括创建和销毁元素。D3允许我们更改现有文档以响应用户交互，动画，和来自第三方的异步通知。 Transformation, not RepresentationD3没有引入新的视图表现.与Processing或Protovis不同，D3的图形标记词汇直接来自Web标准：HTML，SVG和CSS。例如，你可以使用D3创建SVG元素并使用外部的样式进行设置。你可以使用复合的滤镜效果，虚线描边和裁剪，如果浏览器供应商明天提出新功能，我们可以立马使用上–无需更新工具包。而且，如果我们将来决定使用D3以外的工具包，可以自身请整合。 最重要的是，D3易于浏览器的内置元素检查器进行调试：我们使用D3操作的节点恰好是浏览器本身理解的节点。 过渡随着时间的推移，过渡逐渐应用到样式和属性中。可以通过一些令人舒服的效果，比如“弹性”，“立方体进出”和“线性效果”来控制补间。 比如，背景颜色渐变为黑色： 123d3.select('body').transition() .style('background-color','black'); 再比如，使用延时策略来更改圆圈的大小： 12345d3.selectAll('circle').transition() .duration(750) .delay(function(d ,i) &#123; return i * 10&#125;) .attr('r',function(d) &#123; return Math.sqrt(d * scale)&#125;) 通过只修改实际改变的属性，D3减少了开销，并允许在高帧率时具有更高的图形复杂度。D3还允许通过事件对复杂转换进行排序。而且，你仍然可以CSS3转换。 一些常用的api讲解数组Arrays(d3-array)统计 d3.min 数组中最小值 d3.max 数组中最大值 d3.extent 数组中数据的范围 d3.sum 数组数据的总和 d3.mean 数组中算数平均值 d3.median 数组数据的中位数 d3.quantile 一个排好序的数字数组的分位数 d3.variance 数字数组的方差 d3.deviation 一组数据的标准差 查找 d3.scan 对指定的数据执行线性扫描，根据指定的比较器返回最小元素的索引 d3.bisect 通过二分法获取某个数在排好序中的数组中插入的位置（同d3.bisectRight） d3.bisectRight 通过二分法获取某个数在排好序的数组中的插入位置（相等的值归右边） d3.bisectLeft 通过二分法获取某个数在排好序的数组中的插入位置（相等的值归左边） d3.bisector 自定义一个二等分访问器或比较器 d3.ascending 比较两个数是否升序 d3.descending 比较两个数是否降序 变换 d3.cross 获取两个数组的笛卡尔积 d3.merge 合并多个数组为一个数组 d3.pairs 根据相临的元素合并成数组 d3.permute 根据数组索引重排数组 d3.shuffle 随机排序数组（打乱数组排列） d3.ticks 从数字区间生成代表值 d3.tickIncrement 同上 d3.tickStep 同上 d3.range 生成一个数值的范围 d3.transpose 转置二位矩阵 d3.zip 转置可变数量的数组 矩形图 兼容性虽然D3没有明文规定一定要在缩放矢量图形（SVG,Scalable Vector Graphics）中绘图，但是D3提供了众多的SVG图形生成器，它们都是只支持SVG的。因此，建议使用SVG画布,而SVG除了IE8之前的版本外，现代浏览器都支持。如果你要支持IE8以及IE8-的话，建议使用ECharts，其使用了canvas。 精力有限，未能一次更新完…]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>d3js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从前慢]]></title>
    <url>%2F2018%2F05%2F30%2Fslow-in-past%2F</url>
    <content type="text"><![CDATA[从前的日光很慢 车，马，邮件很慢 一生只够爱一个人 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176Time was slower in the past,Carriage, horse, mail needs time a little bit.Even one greeting needs days to be passed从前的日子很慢，车，马，邮件很慢一个问候，要等上好几天The moonlight was slower in the pastWith leisure, being indolentThe whole dawn needs a cup of tea to interpretWith little stars twinkling,moments in your dreams move fast从前的月光很慢有点闲，有点懒在一杯茶里消磨了整个黄昏在半个梦里看星星满天The pace was slower in the pastFrom one village to another near itOne needs a whole day on foot从前的脚步好慢从一个村子到另一个村子要走上一天的时间The days were slowerbut warmer in the pastThrough a touch of light mistYear after year, time is out.从前的日子很慢很暖裹在淡淡的烟火里日日年年The handerchiefs were finer in the pastYoung ladies with soft eyebrowsin their perfect fitstitch by stitch,more delicate从前的手帕也很好看最是那低眉的女子精致的，一针一线It took time to fall in love in the pastSo slow, one needs one's lifetimeseeking for Mr/Ms RightSo slow, you need your whole lifeto love people that suit从前的爱情很慢慢的，用一辈子去等一个人慢的，一生只爱一个人Now with everything on the go,one gets up earlier a little bitNo time to say good morning,even a hug you cannot wait现在快快到每天早早起床来不及说早安来不及拥抱In fact, in the city center,even 5 minutes' on footOr a bit of leisure timeafter your breakfastEverything is different其实在中成，市中心，5分钟茶余饭后的那一点点闲暇时光就变了一个样Now is fastereverything is in the replacementSo fast that life is easily to be partedeven you cannot notice it现在快什么都在更新换代快到将生活扰得七零八落In fact, cluttered life can be combined by one after one highlightLike the classical furnishings mixed with modern decorationsin a sample apartmentLess dull, less stale, much more exquisite其实，杂乱的生活也可以拼凑出一个个美好就像样板间里带着古典气息的摆设和现代化装修的搭一起少了分沉闷古旧多了份细腻Now time flies faster,just keep the pace after complaintStrive for your dream with your daring heartEmbrace your leisure time until you are old but not in the pastWhy not plan for your future earlier to some extent?现在快，抱怨几句，仍要跟上节奏朝着自己的梦想，再努把力把从前的悠闲搬到老年时享受其实，何不早早规划未来？Now is faster, dating with your love, after dinner no time leftIn fact, time is innocent, but it is all your mind’s fault现在快，与恋人约会吃个饭，没了时间其实与时间无关是心理在作祟With a peaceful mind, walking around the Bell Tower in the old streetChoosing a book in the county library, wandering in the old avenue on footYou forget time has vanished怀着一份平和从钟楼老街溜达一圈县图书馆选本书老巷子里逛一逛老了时光 Now is faster, so fast that we always recall beauty in the pastPassionately think of the world once in its purest现在快，快到我们总是回忆起以前的美然后疯狂想念那些纯净的世界In fact, for your current anguish, beat itGo to the North Square, and close your eyes in a momentoverwhelming yourself with those golden days in the pastEnjoy yourself with nothing in your heart其实，暂且搁置现在的烦闷去到北广场，然后闭上双眼任那些美好将自己淹没放空那个美好的世界享受下就好It is good to be an ordinary person at hard thoughtWhen you said slow pace is fine, I back you a lot其实想想，做个中庸的人也不错你说慢节奏生活好，我附和着When he told fast pace adds more spice to life , I agree without second thoughtLike mansion with its luxury, tiny apartment with its refinementGood or bad, tell me not他说快节奏生活刺激，我也赞同就像小公寓精致，大宅奢阔各有千秋，委实难分好坏No matter how slow the past time was, how fast it is in the current无论从前有多慢无论现在有多快I know, the earth under your feet,the love around your heartTreasure them with your best,no matter in the past or in the right moment.我知道，脚下的土地和身边的爱人无论从前还是现在都要尽全力守护和珍惜 -- 木心 我知道，脚下的土地和身边的爱人 无论从前还是现在 都要尽全力守护和珍惜]]></content>
      <categories>
        <category>诗和远方</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2018%2F05%2F29%2Flinked-list%2F</url>
    <content type="text"><![CDATA[在计算机科学领域，链表就是一组数据的线性集合，这种集合的顺序不是根据数据被存放在内存中的顺序决定的。而是根据每个元素的指向下一个的指针决定。 链表是由类队列的一组节点组合而成的数据。每个节点包括了数据和一个指向下一个节点的指针。这种结构在对数据的添加和移除是非常方便的，不管数据所在的位置。 缺点 相比数组，链表因为使用指针来存储会更耗内存 链表的节点必须是从头开始按照顺序读取，因为它本质上就是顺序访问 节点不连续存储，大大增加了访问列表中元素的所需的时间端，尤其在cpu的缓存中 当反向便利链表的时候会比较困难。比如，单链表向后导航比较麻烦，而双链表比较容易阅读，内存消耗在为后向指针分配空间 基本概念和术语链表中的每条记录通常被称为元素或节点（一般叫节点）。 每个节点的字段包含下一个节点的的地址，这个字段通常被叫做下个链接或者下个指向（一般叫指针）。剩下的字段被称为数据，信息，值，负载或者载荷（一般称为值）。 列表的头是它的第一个节点，列表的尾部可以指除头节点后其余部分，或者指列表最后的一个节点。 单向链表单链表包含数据字段和指向下个节点的尾指针字段。可以在单链表上执行的操作包括插入，删除和遍历。 以下的代码演示了如何将具有数据值的新节点添加到单链表的末尾： 123456789101112131415node addNode(node head , int value)&#123; node temp,p; // 声明两个节点temp和p temp = createNode(); // 假设方法createNode创建一个data=0和指向空的指针节点 temp-&gt;data = value; // 添加元素的值到创建的节点data字段 if(head == NULL)&#123; head = temp; // 当链表尾空时 &#125;else&#123; p = head; // head节点赋值给p节点 while(p-&gt;next != NULL)&#123; p = p-&gt;next; // 遍历链表到最后一个节点。最后一个节点的指向为空 &#125; p-&gt;next = temp; &#125; return head;&#125; 双向链表在双向链表中，节点中除了指向下一个节点的指针，还包含指向序列中上一个节点的指针字段。 许多现代操作系统使用双向链接列表来维护。 权衡和计算机编程和设计中的大多数选择一样，没有一种方法是可以适用多种情况的。链表数据结构可能在一种情况下运行良好，在另外一个情况下就有问题了。下面列表是包含链表的数据结构的权衡。 参考维基百科link_list 后话自己在维基百科上查找到的介绍，然后翻译了一丢丢，链接请见上面的参考。翻译到此为止，如果看者感兴趣可以自行查看啦 @～@]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的三次握手和四次挥手]]></title>
    <url>%2F2018%2F05%2F01%2Ftcp-three-handshake-four-bandge%2F</url>
    <content type="text"><![CDATA[UDP（用户数据报协议）和TCP（传输控制协议）都是传输层的协议，但是前者无连接，不安全，而后者提供面向链接的服务，倡导网络安全的环境下，还是推荐使用TCP。然而，TCP里面的知识点够啃一丢丢的时间了，这里只是解析TCP的三次握手和四次挥手啦😊 TCP报文段的首部格式TCP报文段首部的前20个字节是固定的，后面的有4n字节是根据需要而增加的选项（n是整数）。因此TCP首部的最小长度是20字节。见下图： 相关字段的意义： 源端口和目的端口分别写入源端口号和目的端口号。 序号TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须再链接建立时设置。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节序号。比如，一段报文的序号字段值是301，而携带的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，而最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文的序号字段值为401.这个字段的名称也叫做报文段序号。 确认号是期望收到对方下一个报文段的第一个数据字节的序号。 例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（501～700），这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B再发送给A的确认报文段中把确认号置为701。注意⚠️：现在的确认号不是501，也不是700，而是701。 总之： 若确认号 = N ，则表明：到序号 N - 1 为止的所有数据都已经正确收到。 数据偏移指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。但是应该注意，数据偏移的单位是32位字（即以4字节长的字位计算单位）。由于4位二进制数能够表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大长度（即选项长度不能超过40字节）。 保留占六位，保留为今后使用，但目前应该置为0。 紧急 URG(URGent)当URG = 1时，表明紧急指针字段有效。它告诉系统次报文段中有紧急数据，应尽快传送（相当于高优先级的数据），而不要按原来的排队顺序来传送。 例如：已经发送了很长的一个程序要在远地的主机上运行。但是后来发现了一些问题，需要取消该程序的运行。因此用户从键盘发出中断命令（control + c）。如果在所有的数据被处理完毕后这两个字符才被交付接收方的应用程序。这样做就浪费了许多时间。 当URG置1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针(Urgent Pointer)字段配合使用。 确认 ACK(ACKnowlegment)仅当ACK = 1时确认号字段才有效。当ACK = 0时，确认号无效。TCP 规定，在连接建立后所有传送报文段都必须把ACK置1。 推送PSH（PuSH）当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令行后立即就能够收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文，就尽快地（即“推送”向前）交付接受应用进程，而不再等到整个缓存都填满了后再向上交付。 复位 RST(ReSeT)当RST = 1时，表明TCP连接中出现严重差错（如有雨主机奔溃或其他原因），必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位。 同步SYN(SYNchronization)在连接建立时用来同步序号。当SYN = 1而ACK = 0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应的报文中使SYN = 1和ACK = 1。因此，SYN置为1就表示这是一个连接请求或连接接收报文。 终止 FIN(FINis)用来释放一个连接。当FIN = 1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输链接。 窗口窗口指的是发送本报文段的一方的接收窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。之所以要有这个限制，是因为接收方的数据缓存空间有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据 例如，设确认号是701，窗口字段是1000。这就表明，从701号算起，发送此报文段的一方还有接收1000个字节数据（字节号是701-1700）的接收缓存空间。 总而言之：窗口字段明确指出了现在允许对方发送的数据量。窗口值是经常在动态变化着。 检验和检验和字段检验的范围包括首部和数据这两部分。 紧急指针紧急指针只有在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。 选项长度可变，最长可达40字节。当没有使用选项时，TCP的首部长度是20字节。 TCP的链接建立（三次握手）B的TCP服务器进程先创建传输控制块TCP，准备接收客户A进程的链接请求。然后服务器进程就处于LISTEN（接收）状态，等待客户的连接请求。如有，即作出响应。 精力有限，未能一次更新完，亲见谅…]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端安全]]></title>
    <url>%2F2018%2F04%2F13%2Ffrontend-security%2F</url>
    <content type="text"><![CDATA[哈哈哈，本来想在本博文中进行前端安全的讲解的，无奈在断断续续整理的一段时间后… 简述写了一段文字后，发现安全的信息全放在一篇博文中讲述，hold不住，所以会分解进行个人理解。主要是分为下面的几点———— ⚠️ 链接会在后续添加 点击劫持 CSRF攻击 XSS攻击 DDos攻击 SQL注入 文件上传漏洞 参考 某诺同事分享文档 图解HTTP]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解原型对象和原型链]]></title>
    <url>%2F2018%2F04%2F05%2Fprototype-object-chain-md%2F</url>
    <content type="text"><![CDATA[原型对象和原型链在前端的工作中虽然不怎么显式的使用到，但是也会隐式的使用了，比如使用的jquery，vue等啦。在进入正题的时候，我们还是需要明白什么是__proto__，prototype等知识点，主要讲解构造函数，这篇博文大多是问答形式进行… 问答环节Javascript创建对象的方式？也许你会说出工厂模式、构造函数模式、原型模式、组合使用构造函数和原型模式、动态原型模式、寄生构造函数模式和稳妥构造函数这些，但是我们可以对他们进行以下归类–属于函数创建对象。 我们可以简单的将创建对象的方式分为三种：函数创建对象、字面量创建、Object创建。当然，也可以只是分成两类：函数创建对象和字面量创建对象，因为new Object()中的Object是本身就是一个函数。 1Object // f Object()&#123; [native code] &#125; 什么是prototype?function(注意是function哦)定义的对象有一个prototype属性，prototype属性又指向了一个prototype对象，注意prototype属性与prototype对象是两个不同的东西，要注意区别。用伪代码表示如下： 123var function&#123; prototype: prototype&#123;&#125; // function的prototype属性指向prototype对象&#125; 注意上面说的是function里面才会有prototype属性，而我们new出来的对象里面是没有的哦。 12345678910111213141516171819# functionfunction Fun(name)&#123; this.name = name;&#125;Fun.prototype // &#123;constructor:f&#125;var fun = new Fun('嘉明');fun.prototype // undefined# ObjectObject.prototype // &#123;constructor:f,__defineGetter__:f,...&#125;var object = new Object();object.prototype // undefined# 字面量，字面量可以理解没有prototype啦var jack = &#123;&#125;;jack.prototype // undefined proto是什么？在官方的es5种，定义了一个名叫做[[prototype]]的属性，每个对象(除了null)都拥有这样一个属性，这个属性是一个指针，它指向一个名叫做原型对象的内存堆。而原型对象也是一个对象，因此又含有自己的[[prototype]]属性，又指向下一个原型对象，终点指向我们的Object.prototype对象。 注意⚠️ 这里使用的是[[prototype]]，而并非proto。可是他们是同一个东西哈：[[prototype]]是官方所定义的属性，而proto是浏览器（就是任性）自己对[[prototype]]所做的实现。 分三种情况来说对象内部的__proto__： 使用字面量定义一个普通对象: var foo = {} 创建一个函数: function Foo(){};包含Object()啦 创建对象实例: var foo = new Foo(); 情况一：{} 123456var foo = &#123;&#125;;foo.__proto__; // &#123;&#125;foo.__proto__ === Object.prototype; // truefoo.hasOwnProperty('prototype'); // false 函数才有prototype属性foo.hasOwnProperty('__proto__'); // falseObject.prototype.hasOwnProperty('__proto__'); // true 代码的最后一行，一个是返回了false，另一个是true。⚠️因为它并不存在于foo对象(foo.__proto__)或者Foo.prototype（Foo.prototype.__proto__）或者Foo（Foo.__proto__）中【下面情况二和三会有代码验证】，实际上，它是来自于Object.prototype，与其说是一个属性，不如说是一个getter/setter。 情况二：function Foo(){} 123456781. function Foo()&#123;&#125;;2. Foo.__proto__; // [Function]3. Foo.__proto__ === Object.prototype; // false4. Foo.__proto__.__proto__ === Object.prototype; // true5. Foo.prototype.__proto__ === Object.prototype; // true 函数的原型对象指向6. Foo.__proto__ == Foo.prototype; //false7. Foo.hasOwnProperty('__proto__'); // false8. Foo.hasOwnProperty('prototype'); // true 在函数中，通过上面代码2，3，4，5可以知道Foo.proto可以理解为指向了Foo.prototype(广义上理解)，而实际上两个又有差别（狭义上，第6点可以说明，欢迎补充）。然后就是每个函数都有一个默认的prototype属性，其指向函数的原型对象。 情况三：对象实例 new Foo() 123456function Foo()&#123;&#125;;var foo = new Foo();foo.__proto__; // Foo &#123;&#125;foo.__proto__ === Foo.prototype ; truefoo.hasOwnProperty('prototype'); falsefoo.hasOwnProperty('__proto__'); false 上面可知，实例中是没有prototype这个属性的，对比上面的三种情况，也说明了只有在函数中才默认创建了prototype属性，而且指向了相应的函数原型对象。 constructor是什么？在javascript语言中，constructor属性是专门为function而设计的，它存在于每一个function的prototype属性中，这个constructor保存了指向function的一个引用。 1234567function F()&#123; // some code&#125;# javascript内部会执行如下的动作# 1.为该函数添加一个原型（即prototype）属性# 2.为prototype对象额外添加一个constructor属性，并且该属性保存指向函数F的一个引用 对象的实例中也有一个constructor属性（从prototype那里获取的），每一个对象实例都可以通过constructor对象访问它的构造函数，如下： 123var f = new F();f.constructor === F; // truef.constructor === F.prototype.constructor; // true 既然可以访问实例的类型f.constructor，那么我们就可以对实例进行特殊的处理啦： 123if(f.constructor == F)&#123; // some code&#125; 不过别这样操作，因为constructor是不稳定的（见下文对象中的constructor的作用是什么呢？），一般不会采取上面的这种操作，而是通过instanceof： 123if(f instanceof F)&#123; // some code&#125; 对象中的constructor的作用是什么呢？这里推荐贺师俊前辈的回答，原文复制如下： constructor属性不影响任何javascript的内部属性。instanceof检测对象的原型链，通常你是无法修改的（不过某些引擎通过私有的__proto__属性暴露出来）。 constructor其实没有什么用，只是javascript语言设计的历史遗留物。由于constructor属性是可以变更的，所以未必真的指向对象的构造函数，只是一个提示。不过，从编程习惯上，我们应该尽量让对象的constructor指向其构造函数，以维持这种习惯。 例子解析： 123delete Object.prototype.constructor; // true(&#123;&#125;).constructor; // undefined(&#123;&#125;) instanceof Object; // true 原型链的最高指向？《javascript高级程序设计》中有说到所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。那么原型的最高指向就是Object了嘛？你可以理解是Object，可是我认为是null。 12Object.prototype.__proto__; // nullObject.prototype.__proto__===null ; // true 最高指向是Object/null，无伤大雅。 实例和原型的关系？当读取实例的属性时，如果找不到实例的属性，就会查找与对象关联的原型的属性，如果还是查找不到，就查找原型的原型，一直到顶级为止。 1234567891011121314151617181920function Person()&#123;&#125;Person.prototype.name = "嘉明";var person = new Person();person.name = "jiaming";console.log(person.name); // "jiaming"// 删除实例的属性后delete person.name;console.log(person.name); // "嘉明"// 追加一个疑问 在__proto__中加属性会覆盖原来的嘛person.__proto__.name = "嘉";console.log(person.name); // "嘉" 证明成功，不建议这样修改，毕竟__proto__是浏览器厂商实现的，非标准的// 再追加一个疑问 __proto__添加的属性或者方法是放在对象的原型上的嘛var another_person = new Person();console.log(another_person.name); // "嘉" 证明是放在对象的原型上的 原型的原型呢？属性或者方法在自己的原型上没有找到的话，那就要跑到原型上去找啦。之前有提到过所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。 那么一个构造函数function Person(){}就存在这样的一个关系，实例出来的var person = new Person()person通过proto指向构造函数的原型Person.prototype，然后构造函数的原型指向Object的原型，即是Person.prototype.__proto__指向Object.prototype。 总结下呗嗯，还是针对构造函数来说哈，将上面提到的知识点汇总一下啦。上面都是纯文字说明，下面就配上图片好好理解下。 先上相关代码: 1234567891011121314function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function()&#123; console.log(this.name);&#125;var person = new Person("嘉明");person.age = 12;person.sayName(); // "嘉明"console.log(person.name.toString()); // "嘉明"var another_person = new Person("jiaming");another_person.sayName(); 上面代码中，相关的关系如下图 实验环节小demo是使用canvas画出小星光，代码如下： 1234567891011121314151617181920212223242526272829&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;canvas&lt;/title&gt; &lt;style&gt; body&#123; margin: 0; padding: 0; position: relative; &#125; #myCanvas&#123; position: absolute; left: 50%; top: 50%; background: #000; margin-left: -300px; margin-top: -150px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="600" height="300" style="border: 1px solid #000;"&gt; &lt;/canvas&gt; &lt;script src="path/to/canvas.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253window.onload = function()&#123; var c = document.getElementById('myCanvas'); var grd = ""; // 渐变的颜色 // 上下文 var context = c.getContext("2d"); if(context)&#123; // x,y,r 坐标和半径 function Star(x,y,r)&#123; this.x = x; this.y = y; this.r = r; this.init(this.x,this.y,this.r); &#125; // 绘制星星 Star.prototype.init = function(x,y,r)&#123; context.beginPath(); // 渐变颜色 grd = context.createRadialGradient(x,y,r-2,x,y,r+2) grd.addColorStop(0, 'white'); grd.addColorStop(1, 'yellow'); context.fillStyle=grd; // 画圆 context.arc(x,y,r,0,2*Math.PI); // 填充颜色 context.fill(); context.closePath(); &#125; // 创建星星 for(var i = 0; i &lt; 300; i++)&#123; var x = Math.floor(Math.random()*600); var y = Math.floor(Math.random()*300); var r = Math.floor(Math.random()*3)+2; new Star(x,y,r) &#125; &#125;else&#123; var div = document.createElement("div"); div.innerHTML = "您的浏览器不支持canvas，请升级浏览器！"; document.getElementsByTagName("body")[0].appendChild(div); &#125;&#125; 实现的简单效果如下图哈（ps，您可自行验证哈，改善啥的）：]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小结http]]></title>
    <url>%2F2018%2F03%2F11%2Fsummerize-http%2F</url>
    <content type="text"><![CDATA[了解http是前端工程师必备的一个技能哈，虽然现在自己不是很了解，但是根据查阅的资料，自己谈下自己的总结啦！路漫漫兮其修远… 概述Web使用一种名为HTTP(HyperText Transfer Protocol，超文本传输协议)的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定。可以说，Web是建立在HTTP协议上通信的。 HTTP是干什么的？http是数据传输协议（超文本传输协议），用来沟通客户端和服务器。 什么是资源?网络上的一切内容皆资源，无论是静态文件还是动态生成的代码等。 什么是媒体类型?最初设计MIME（Multipurpose Internet Mail Extension，多用途英特网邮件扩展）是为了解决在不同的电子邮件系统之间搬迁报文时存在的问题。MIME在电子邮件系统中工作得非常好，因此HTTP也采纳了它，用它来描述并标记多媒体内容。 其实多媒体类型就是一种数据类型的标记，用来告诉接收端，接收到的数据是什么类型，让接收端知道怎么才能处理该文件。常见的标记方式就是MIME(见上解析)，MIME描述了文件的主要类型以及特定子类型，例如：&quot;Content-Type&quot;:&quot;text/html&quot;，其中text描述的文件主要类型是文本，而其特定类型是html文档！ 怎么理解URI以及它的子集（URL,URN）URI（Uniform Resource Identifier，统一资源标志符）的作用就是在网络上确定唯一资源，这就好比，在中国，身份证能唯一确定一个人一样。知道身份证号，就一定能确定一个人的信息。 URL（Uniform Resource Locator，统一资源定位符）是跟资源在网络上的位置有关，比如文章的banner图的位置为http://omu538iq8.bkt.clouddn.com/network/http/http_banner.jpg，广义上讲，我们说的URI就是指URL。 URN（Uniform Resource Name，统一资源名称）是作为特定内容的唯一名称使用的，与目前的资源所在地无关。URN是未来的趋势(试想一下人不可能是在一个地理位置不动吧，而ID_card的一定不会变的)，不过貌似具体实施还在商讨中。 什么是事务事务就是一次http连接（不包括tcp/ip连接，只包括一次http报文发送与接收）的整个过程，由请求命令和响应结果组成。中间数据格式是http报文。本文的banner图示就是一次http的事务。我们平常打开一个网站，里面包括很多事务，比如：请求网页文档、请求某张图片以及请求某个视频/音频。 方法指什么？HTTP方法会告诉服务器要执行什么动作（获取一个web页面、运行一个网关程序、删除一个文件等）。这些方法包括GET , PUT , DELETE , POST , HEAD 。 状态码有什么用？状态码是一个三位数字的代码，告知客服端请求是否成功，或者是否需要采取其他动作。状态码带着一个原因短语，方便人解读，比如304 Not Modified ，当发送GET请求资源返回上面的代码时候，可以解读成：客户端已经执行了GET，但文件没发生改变（和上次请求的资源一模一样）。 简单介绍一些报文首先报文是http协议一种纯文本的数据格式，分为请求报文和响应报文，两种报文都具有类似的结构，分别由三部分构成：起始行、首部、主体。起始行描述了报文干了什么；首部描述报文传输的具体细节；主体描述传输的实际内容。 什么是TCP/IP?更HTTP有什么关系？TCP/IP是全世界的计算机和网络设备常用的层次化交换网络协议集。简单说，HTTP协议是一个应用层协议，位于TCP/IP协议的上一层，TCP/IP协议的主要作用就是过滤掉每个计算机的差异性，隐藏相关弱点，使得对于HTTP协议来说提供的都是”相同的”接口。 在一次网络请求中，经历了哪些过程？(a).浏览器从RUL中通过解析出服务器的主机名 (b).浏览器将服务器的主机名转换成服务器的IP地址 (c).浏览器将端口号(如果有的话，默认是80)从URL中解析出来 (d).浏览器建立一条与web服务器的TCP连接 (e).浏览器向服务器发送一条HTTP请求报文 (f).服务器向浏览器回送一条HTTP响应报文 (g).关闭连接，浏览器显示文档 HTTP协议有哪些版本？HTTP/0.9：这个协议有很多严重的设计缺陷； HTTP/1.0：使用广泛； HTTP/1.0+：是非官方的HTTP/1.0的扩展版本； HTTP/1.1：是目前正在广泛使用的版本，修复相关的设计缺陷，增加相关特性； HTTP-NG（又名HTTP/2.0）：将来使用与否正在商讨中 Web的一些结构组件上面有介绍了两个应用程序（Web浏览器和Web服务器）是如何互相发送报文来实现基本事务处理的。下面将列其他一些比较重要的应用程序，如下： 代理：位于客户端和服务器之间的HTTP中间实体。具体来说就是代理位于客户端和服务器之间，接收所有客户端的HTTP请求，并把这些请求转发给服务器（可能会对请求进行修改之后转发）。对于用户来说，这些应用程序就是一个代理，代表用户访问服务器。代理的主要作用有过滤、屏蔽等，比如，在企业中对下载的应用程序进行病毒检测，或者对小学生屏蔽一些成人才能看的内容。（注意⚠️ 代理即可以代表服务器对客户端进行响应，又可以代表客户端对服务器进行请求） 缓存(cache)：HTTP的仓库，使常用页面的副本可以保存在离客户端更近的地方。首先说明一下：缓存某种意义上来说是一种代理服务器。它主要使用代表服务器对客户端进行响应。发送于预先缓存好的资源的副本（浏览器上就有缓存哈）。这样会加快事务响应速度、同时也会减少服务器的负载、减轻带宽等问题。 网关(gateway)：是连接其他应用程序的特殊的web服务器。网关是一种特殊的服务器，面对客户端时好像它就是服务器，而对于服务器，它又充当客户端的角色，它的主要作用就是协议转换。例如下面的HTTP/FTP网关。 隧道(tunnel)：对HTTP通信报文进行盲转发的特殊代理。HTTP隧道通常用来在一条或多条HTTP数据，转发时不会窥探数据。 Agent代理：发起自动HTTP请求的半只能Web客户端。说白了就是我们平时所说的浏览器，以及web机器人、爬虫等。 URL和资源上面提到过，URN还没成熟，说的URI可以等同说URL，即URI == URL , URI !== URL。 URL的语法下面是URL的组成： 1234567891011&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;# scheme:方法描述了请求资源时用了什么协议，用“:”与url其它部分隔开；# user:用户名描述了访问是带的用户名# password:密码描述了用户名后面可能跟的密码，用“:”跟用户名隔开；# host:主机描述了网站主机名或ip地址，如果前面有用户名和密码，用@分开；# post:服务器当前正在监听的端口，http默认为80，https默认为443;# path:路劲描述了资源在服务器上的位置，用‘/’跟前面部分隔开；# params:参数描述了请求需要附加的参数，用“;”与其他部分隔开；# query:查询是用来激活服务器程序去执行某些操作，比如查询数据库等，用“?”与其余部分隔开；# frag/fragments:片段只在客户端使用，不发送到服务器端； URL快捷方式URL快捷方式描述了一个程序如何通过相对地址解析处绝对地址的过程以及在浏览器地址栏输入部分URL浏览器自动补全主机名的一种机制。 相对地址转换为绝对地址：首先会根据一个基础地址来得到出协议、主机名、端口等。 浏览器扩展地址主要通过主机名扩展和历史扩展等方式实现自动地址补全。 URL编码为什么需要编码？ 主要从URL的一致性、安全性、以及完整性来强调需要对URL字符进行编码。比如因为一个URL连接的两端可能出现的机器种类很多，为了让大家能够解析出一个相同的url，所以有必要对某些不安全的URL字符进行转义。 URL字符集由什么编码构成？ 早起的URL是由US-ASCII码编码，但是随着网络全世界的流行，有很多字符是US-ASCII不能编码的，因为US-ASCII码最多只能编译127个字符。通过转义序列，就可以用US-ASCII字符集的有限子集字符值或数据进行编码了。 编码机制？ 为了避开安全字符集表示法带来的限制，人们设计了一种编码机制，用来在URL中表示各种不安全的字符。这种编码机制就是通过一种“转义”表示法来表示不安全字符的，这种转义表示法包含一个百分号（%），后面跟着两个表示字符的ASCII码的十六进制数。 哪些字符不建议在URL里面使用？ 在URL中，有几个字符被保留起来，有着特殊的含义。有些字符不在定义的US-ASCII可打印字符集中。还有些字符会与某些因特网网关和协议产生混淆，因此不赞成使用，比如“%”。 HTTP报文如果说HTTP是因特网的信使，那么HTTP 报文就是它用来搬东西的包裹了。我们将了解： 报文是如何流动的 HTTP报文的三个组成部分（起始行、首部和实体的主体部分） 请求和响应报文直接的区别 请求报文支持的各种功能（方法） 和响应报文一起返回的各种状态码 各种各样的HTTP首部都是用来干什么的 报文流HTTP报文是以一种类似的流方式来发送数据的，所以报文流讲述了HTTP报文的一些客观状态，相关的术语：流入、流出形容事物的处理。HTTP报文任何时候是从上流流入，其中经过的节点既可能是上流，也有可能是下流，如果从某个节点流出，那么相对于此节点流入的那个节点就是上游，翻过它就是下游。 报文的组成部分报文是由三部分组成：起始行、首部、主体。起始行和首部都是ASCII文本，而主体可以是任意类型文件，比如二进制，视频等。且起始行和首部都以一个crlf作为结束符，并且首部与主体之间应始终存在一个以crlf序列作为结束的空行。当然了，为了兼容老版本的http，这里有时并不是那么严格要求非要crlf同时存在。 请求报文和响应报文直接的区别两者的报文语法如下： 12345# 请求报文 &lt;method&gt;&lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 12345# 响应报文&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;&lt;headers&gt;&lt;entity-body&gt; 上面的请求报文和响应报文的字段解析如下： 1234567# method是客户端希望执行的动作，如GET、POST等# request-URL是指请求资源的路径# version报文版本号，格式为http/&lt;major&gt;.&lt;minor&gt;，分别代表主要版本和次要版本号，其含义应分开理解# status就是用一个三位的数字表示当前事务处于什么状态，便于开发者处理# reason-phrase原因短语，方便查看状态码的意思# headers首部是一个包含零个或多个的键值对，键值对以crlt隔开，而键，值之间以":"隔开，期间包含一个可选的空格# 任意格式组成的数据块，也是实际发送的内容 请求报文支持的方法安全方法 能在服务器端操作的就是非安全方法，比如DELETE、PUT、POST，不在服务器端游操作的就是安全方法，比如GET、HEADER。当然了，安全方法并非不能在服务器端有操作，这是开发者可以控制的。 GET 用来请求服务器端发送某个资源。 HEADER 此方法跟GET方法类似，区别就是不返回主体。HEAD请求的回应部分的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标志的资源的信息。常用于测试超链接的有效性，是否可以访问，以及最近是否更新。 PUT 用于向服务器端修改、插入数据。 POST 用于向服务器端发送数据。常用于表单的提交，用于登录注册页面。 TRACK 用于向服务器端请求报文在发送过程中经过了什么修改，主要是用来测试。 OPTIONS 用来请求服务器告知其支持什么功能。 DELETE 用于向服务器删除某个指定的资源。 状态码 # 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 常见的状态码 1234567891011121314151617181920212223242526272829303132333435363738394041424344200 OK# 表示从客户端发过来的请求在服务器端被正常处理了204 No Content# 表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分206 Partial Content# 表示客户端进行了范围请求301 Moved Permanently# 永久性重定向。该状态码表示请求的资源已经被删除，重新分配了新的URI，以后应使用资源现在所指的URI302 Found# 临时性重定向。该状态码表示请求分配的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。和301状态相似，但是302代表的资源不是被永久转移，只是临时性质的。303 See Other# 该状态码表示由于请求对应的资源存在着另一个URI，应该使用GET方法定向获取请求的资源。304 Not Modified# ⚠️ 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304虽然被划分到3XX类别里面，但是和重定向没有关系。400 Bad Request# 表示请求报文中存在语法错误。401 Unauthorized# 表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。403 Forbidden# 表示对请求资源的访问被服务器拒绝了。404 Not Found# 表示服务器上无法找到请求的资源。500 Internal Server Error# 表明服务器端执行请求时发生了错误503 Server Unavailable# 表明服务器暂时处于负载或者正在进行停机维护，无法处理请求。 更多的状态码请自行百度。 HTTP首部首部和方法配合工作，共同决定了客户端和服务器能够做什么事情。首部分为通用首部、请求首部、响应首部、主体首部、扩展首部！具体的信息请查看《HTTP权威指南》。 代理Web代理(proxy)服务器是网络的中间实体。代理位于客户端和服务器之间，扮演“中间人”的角色，在各端点之间来回传送HTTP报文。 缓存web缓存是可以自动保存常见文档副本的http设备。当web请求抵达缓存时，如果本地有已缓存的副本，就可以从本地存储设备而不是原始服务器中提取这个文档。使用缓存的优点有： 缓存减少了冗余的数据传输，节省了你的网络费用。 缓存缓解了网络的瓶颈问题。不需要更多的带宽就能更快的加载页面。 缓解降低了对原始服务器的要求。服务器可以更加快地响应，避免过载的出现。 缓存降低了距离时延，因为从较远的地方加载页面会更慢些。 冗余的数据传输每次从服务器上拿数据（客户端频繁访问同一个页面），那么带来的后果就是：服务端多次发送重复的数据浪费流量、耗费昂贵的网络带宽从而减低传输速率、加大服务器的负载。而有了缓存之后，这些问题可以迎刃而解。 带宽瓶颈很多本地的网络客户端提供的带宽比远程服务器提供的带宽要宽。客户端会以路径上最慢的网速访问服务器，这样本地的带宽优势就没有体现出来。如果在客户端方向配置一个高速缓存服务器，那么就可以很快得到响应，由此也可以看出带宽对报文传输速率的影响。 瞬间拥塞瞬间拥塞描述的是一种情况：一个爆炸性的新闻和热点事件，如果没有配置缓存的情况下，那么在短时间内，服务器会收到突变的请求增长，负荷会爆炸性增长，肯定会吃不消。但是又了缓存，可以大大分担服务器的负载数量。 距离时延距离时延说明的一个问题就是传输数据过程这个过程需要的时间，而且路程越长，那么需要的时间也会越多，即时延越长。所以在距离客户端较近的地方部署缓存服务器，减少了传输路程，那么就减少了传输时延。平时使用的cdn就是这个原理啦。 命中与未命中 缓存命中与缓存未命中：一次http事务请求如果是从得到的响应是从缓存得到的原始副本，那么这样的过程就称之为缓存命中。如果缓存没有响应的副本，而要去请求原始服务，那么久把这个过程称之为缓存未命中。 http再验证：原始响应内容是在变化的，所以缓存应该在文档过期时间之后去验证缓存的副本是不是新鲜的，这个过程就叫做http再验证。如果再验证之后得知副本是新鲜的，那么原始服务器就会返回304 not modified。此时，称之为再验证命中或者缓存慢命中。如果得知缓存不是新鲜的，那么服务器返回200 ok。此时，称之为再验证未命中。如果原始对象被删除，返回404 not found响应。响应的缓存副本要删除。 命中率：指由缓存返回副本事务在全部事务中所占的比例，称之为缓存命中率。这个数据实际意义不是很大，而字节命中率从资源大小总量的角度说明缓存命中所占的比例。因为它从数据流量的角度出发，所以实际中这个数据的意义挺大的。 区分命中和未命中：简单来说，http没有相应的机制来告知客户端响应是从缓存得到的还是从原始服务器得到的。但是我们可以从http响应报文首部中的date字段得知这一情况：如果这个字段的时间比当前时间更早得多，说明这是从缓存得到的，因为date描述的服务器第一次响应的时间，而缓存是不会对这个字段进行修改的。 缓存的拓扑结构 分类：缓存分为私有缓存（只为一个客户端服务，比如我们给浏览器配置的代理）和共有缓存（为多个客户端服务，现实中是以代理缓存服务器的形式出现） 代理缓存的层级结构：此种结构描述的以父、子层级出现的层级结构，同时离客户端越近的子缓存命中率较低（较廉价），可以把请求上升到父缓存（较昂贵），从而在父缓存那里实现事务处理。 代理缓存的网状结构：它描述的缓存结构并不是很明显呈现父子关系的结构，而是呈现无规则的网状。这种结构的思想就是子缓存可以动态选择上一级缓存，从而实现更灵活的缓存控制。 缓存的处理步骤 接收————缓存从网络中读取抵达的请求报文。 解析————缓存对报文进行解析，提取出url和各种首部。 查询————缓存查看是否有本地副本可用，如果没有，就去获取一份副本（根据情形和配置，到原始服务器或父代理中去取，将副本存在本地，或者获取不到返回错误信息） 新鲜度检测————缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。 创建响应————缓存会用新的首部和已缓存的主体来构建一条响应报文。 发送————缓存通过网络将响应发送给客户端。 日志————缓存可选地创建一个日志文件条目来描述这个事务。 保存副本的新鲜度 文档过期通过特殊的http首部cache-control和expires，http让原始服务器为每个文档设置一个“过期时间”，如： 12345Cache-Control: Max-Age = 484200 // 除了Max-Age , 还可以有其他的字段啦Expire: Fri, 28 Oct 2016 12:00:00 GMT// Max-Age 是相对时间，以秒为单位，理解为使用期 推荐使用// Expires 为绝对时间，理解为到期时间 不推荐使用--由于很多服务器的时钟都不同步，或者不正确，所以最好使用剩余秒数（相对时间）来表示过期时间 服务器再验证：仅仅是已缓存文档过期了并不意味着它和原始服务器目前处于活跃状态的文档有诗集的区别；这知识意味着到了要进行核对的时间了。这种情况被称为服务器再验证，说明缓存需要询问服务器是否发生了变化。 用条件再验证：涉及到的两个首部为If-Modified-Since和If-None-Match。如下： 12345If-Modified-Since: &lt;data&gt;If-None-Match: &lt;verson&gt;// date为服务器响应报文里面Last-Modified时间// version是实体标签ETag。其机制跟If-Modified-Since不同在于：后者是根据修改时间来判断文档的新鲜度，但是有些情况下是不适合的，比如我们只是加了注释什么的，其中实际内容并没有什么变化。 缓存的控制能力 缓存控制能力描述的是服务器可以通过设置相关的首部来控制文档的缓存过期时间的能力。相关首部解析如下： 指令 目的 Cache-Control:no-store 不能缓存/尽快从存储器中删除文档的所有痕迹，因为里面可能有敏感信息 Cache-Control:no-cache 除非资源进行了再验证，否则这个客户端不会接受已缓存的资源 Cache-Control:must-revalidate 严格遵守新鲜验证规则 Cache-Control:max-age 设置多长时间过期（相对时间） Expires: 设置多长时间过期（绝对时间）不建议使用 试探性过期 不设置首部，让缓存来决定，这个方式涉及到一种算法，比如缓存服务器通过查看最后修改时间，从而得到该文档的修改频繁度，从而为其设置缓存过期时间 上面的优先级从上到下依次降低。 客户端的新鲜度限制：web浏览器都有refresh（刷新）或者reload（重载）按钮，可以强制对浏览器或者代理缓存中可能过期的内容进行刷新。refresh按钮会发布一个附加了cache-control请求首部的get请求，这个请求会强制进行再验证，或者无条件地从服务器获取文档。refresh的确切行为取决于浏览器、文档以及拦截缓存的配置。客户端可以用cache-control请求首部来强化或者放松对过期时间的限制，相关的首部介绍如下： 指令 目的 Cache-Control: max-stale = 缓存可以随意提供过期的文件。如果指定了参数，这段时间内，文档就不能过期。这条指令放松了缓存的规则 Cache-Control: min-fresh = 至少在未来秒内文档要保持新鲜。这就使缓存规则更加严格了 Cache-Control: max-age = 缓存无法返回缓存时间长于秒的文档。这条指令会使缓存规则更加严格，除非同时还发送了max-stale指令，在这种情况下，使用期可能会超过其过期时间 Cache-Control: no-cache Pragma: no-cache 除非资源进行了再验证，否则这个客户端不会接受已缓存的资源 Cache-Control: no-store 缓存应该尽快从存储器中删除文档的所有痕迹，因为其中可能会包含敏感信息 Cache-Control: only-if-cached 只有当缓存中有副本存在时，客户端才会获取一份副本 设置缓存控制不通的web服务器为HTTP Cache-Control 和 Expiration首部的设置提供了一些不同的机制。下面讲解下面这些： 控制Apache的HTTP首部 默认没有开启，需要进行相关的配置：mod_headers,mod_expires,mod_cern_meta 通过HTTP-EQUIV控制HTML缓存 例子如下： 123456&lt;html&gt; &lt;head&gt; &lt;title&gt;this is the title&lt;/title&gt; &lt;meta HTTP-EQUIV="Cache-control" CONTENT="no-cache"/&gt; &lt;/head&gt; ... 此方法只是对html文件有用，并不是很好。 参考《HTTP权威指南》 《图解HTTP》 精力有限，未能一次性更新完，还望体谅…]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端优化：雅虎35条原则]]></title>
    <url>%2F2018%2F03%2F06%2Ffrontend-optimization%2F</url>
    <content type="text"><![CDATA[整理前端优化的方案，主要是雅虎的35条原则。欢迎补充哈 😊 [内容]尽量减少HTTP请求数80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本，Flash等等。减少组件数必然能减少页面提交的HTTP请求书。这是让页面更快的关键。 合并文件是通过把所有脚本(javascript)放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。 CSS Sprites(精灵图)是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的background-image和background-position属性来定位要显示的部分。也可以只用position就行了。 图像映射可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在页面中连续的时候才有用，比如导航条。给image map设置坐标的过程既无聊又容易出错，用image map来做导航也不容易，所以不推荐用这种方式。 行内图片(Base64编码)用data:URL模式来把图片嵌入图片。这样会增加HTML文件的大小，把行内图片放在(缓存的)样式表中是个好办法，而且成功避免了页面变重。但目前主流浏览器并不能很好地支持行内图片。 [服务器]使用CDN(Content Delivery Network)用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。当具体要怎么做呢？ 实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务。缩短用户和内容之间的距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。 记住终端用户80%到90%的响应时间都花在下载组件上了：图片，样式，脚本，Flash等等，这是业绩黄金法则。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。 内容分发网络(CDN)是一组分散在不同地理位置的web服务器，用来给用户更高效地分发内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数(hop)最少的或者响应时间最快的服务器。 [服务器]添上Expires或者Cache-Control HTTP头这条规则有两个方面： 对于静态组件：通过设置一个遥远的将来时间作为Expires来实现用不失效 多余动态组件：用适合的Cache-ControlHTTP头来让浏览器进行条件性的请求 网页设计越来越丰富，这意味着页面里有更多的脚本，图片Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这就避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但是它们应该用在所有组件上，包括脚本、样式和Flash组件。 浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2020年03月06日前不会改变。 1Expires: Fri, 06 Mar 2020 21:00:00 GMT 用一个遥远的未来时间做有效期HTTP头，只有在用户已经访问过站点之后才会影响页面视图。如果是新访客或者浏览器的缓存被清空时，对HTTP请求的数量并没有影响。因此这种性能提升取决于已缓存各个组件的用户访问站点的频率。我们在Yahoo!测量了这个数据，发现已缓存各个组件的页面访问量（PV）占75%到85%。通过把一个遥远的未来时间作为有效期HTTP头，增加了被浏览器缓存的组件数量，在后续页面的访问中不需要用Internet连接多发哪怕一个字节。 [服务器]Gzip组件前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽，网络服务商，对等交换点的距离问题等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。 从HTTP/1.1开始，web客户端就有了支持压缩Accept-Encoding HTTP请求头。 1Accept-Encoding: gzip,deflate 如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding: gzip响应头来通知客户端。 1Content-Encoding: gzip Gzip是目前最常见的高效压缩方法，由GNU项目开发并被RFC 1952标准化。唯一一个你可能会看到的其它压缩格式是deflate，但它效率不高而且并不常见。 Gzipping一般能够把响应压缩到70%左右，目前大约90%的通过浏览器的网络传输都支持gzip。如果是Apache服务器，配置gzip的模块取决于版本Apache 1.3用mod_gzip而Apache 2.x是mod_deflate模块。 浏览器和代理的某些因素可能会引起浏览器所期望的和它收到的压缩内容不匹配。幸运的是，随着老旧浏览器的淘汰，这些极少遇到的情况正在逐渐减少，而且Apache模块可以通过自动添加合适的Vary响应头来帮你搞定。 服务器会根据文件类型来决定要不要用gzip压缩，但这非常有限。大多数网站都有gzip压缩HTML文件，其实压缩脚本，样式表也是不错的选择，但是很多网站却错失了这个机会。其实，可以压缩任何文本内容，包括XML和JSON，而图片和PDF不用压缩，因为它们已经被压缩过了，再用gzip压缩不仅浪费CPU，还可能会越压越大。 尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。 [CSS]把样式表放在顶部在Yahoo!研究性能的时候，我们发现把样式表放在文档的HEAD部分能让页面看起来加载得更快。这是因为把样式表放在head里能让页面逐步渲染。 关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显示得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被记录下来了。在我们的例子中，HTML页面就是进度条！当浏览器逐渐加载页面头部，导航条，顶部logo等等的内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整个用户体验。 在很多浏览器（包括IE）中，把样式表放在HTML文档底部会阻止页面逐渐渲染。这些浏览器阻塞渲染过程，以避免因为样式变动而重绘页面元素，用户这时就只能盯着空白页面。 HTML官方文档清楚的描述了样式表应该放在页面的HEAD里面：Unlike A,[LINK] may only appear in the HEAD section of a document, although it may appear any number of times.（不像a标签,link标签可能只出现在head部分，虽然它可以出现多次）。空白屏幕或者没有样式的falsh内容都是不可取的。理想的方案就是遵循HTML官方文档，把样式表放在HTML文档的HEAD部分。 [javascript]把脚本放在底部脚本会阻塞并行下载，HTTP/1.1官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同的名下的。 有时候，并不容易吧脚本移动到底部。举个例子，如果脚本是用document.write插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在大多数情况下，这些问题都是可以解决的。 一个常见的建议是用推迟(deferred)脚本，有DEFER属性的脚本意味着不能含有document.write，并提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持DEFER属性。在IE中，脚本可能被推迟，但不尽人意。如果脚本可以推迟，我们就可以把它放在页面底部，页面就可以更快地载入。 [CSS]避免使用CSS表达式用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式吧背景颜色设置成按小时交替的： 1background-color: expression((new Date()).getHours()%2 ? "#f00" : "#fff"); 上面的代码中，expression方法可以接受一个javascript表达式。css属性会被设置成表达式的计算结果。expression方法会被其他浏览器忽略，所以只有想办法实现垮浏览器的与IE一致的用户体验才有用。 表达式最大的问题是它们经常被重复计算，比我们想象的次数还要多。不仅仅是页面渲染和调整大小的时候，在页面被滚动，甚至用户在页面上移动鼠标时都被重新计算表达式。给css表达式添加一个计算器就可以追踪它重新计算的时间和频率，而在页面上动动鼠标就可以引发10000多次重新计算。 减少css表达式重新计算的一种方式就是用一次性表达式，即在表达式第一次计算后就把样式属性设置成一个明确的值，换掉表达式。如果必须要在页面的整个生命周期中动态设置样式属性，可以用事件处理器来代替css表达式。如果必须使用css表达式，要记得它们可能被重复计算千次，从而影响整个页面的性能。 [javascript ,css]把javascript和css放到外面很多性能原则都是关于如何管理外部组件的，然而，在这些顾虑出现之前你应该问一个基础的问题：应该把javascript和css放到外部文件中还是直接卸载页面里？ 实际上，用外部文件可以让页面更快，因为javascript和css文件会被缓存在浏览器。HTML文档中的行内javascript和css在每次请求该html文档的时候都会重新下载。这样做是减少了所需的HTTP请求数，但是增加了html文档的大小。另一方面，如果javascript和css在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。 关键因素是，外部文件被缓存的频率和页面被请求数量之间的关系。尽管这个因素很难量化，但我们还是可以用各种各样的指标来衡量的。如果用户的每个会话中都有多次页面访问，那么相同的脚本和样式表就可以被多个页面复用，缓存的外部文件就会带来巨大的好处。 很多站点在度量中都处于中等水平，对这些站点来说，一般最好的解决方案就是把javascript和css部署为外部文件。唯一的例外是主页上汗哪方式的优先。在每个会话中访问量比较少的主页会发现行内javascript和css能让终端用户的响应时间更快。 对典型的站点来说，首页是众多访问量的开始，有很多技术可以对减少HTTP请求起到杠杆作用，就像用外部文件缓存的好处一样。这样的一种技术就是在首页使用行内javascript和css，但是在页面载入完成之后动态加载外部文件，这样后续的页面所需的外部文件就已经被放在浏览器的缓存里面了。 [内容]减少DNS查找域名系统建立了主机名和IP地址间的映射，就像电话薄上人名和号码的映射一样。当你在浏览器输入www.yahoo.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完之前，浏览器无法从主机名下载任何东西。 DNS查找被缓存起来更加有效，由用户的ISP(网络提供商)或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己cache。只要浏览器在自己的cache里还保存着这条记录，它就不会向操作系统查询DNS。 IE默认缓存DNS查找30分钟，写在DnsCacheTimeout注册表设置中。Firefox缓存1分钟，可以用network.dnsCacheExpiration配置项设置。（Fasterfox把缓存时间改成了1小时P.S.Fasterfox是FF的一个提速插件） 如果客户端的DNS cache是空的（包括浏览器和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。 减少不同主机名的数量同时也减少了页面能够并行下载的组件的数量，避免了DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散到2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。 [javascript,css]压缩javascript和css压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行符和tab）。在javascript中这样做能够提高响应性能，因为要下载的文件变小了。自己一般使用gulp来压缩。 [内容]避免重定向重定向用301和302状态码，下面是一个有301状态码的HTTP头： 123HTTP/1.1 301 Moved Permanently Location: http://example.com/newuri Content-type: text/html 浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元素和javascript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。 牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。 有一种常见的极其浪费资源的重定向，而且WEB开发人员一般意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到http://reng99会返回一个重定向到http://reng99/的301响应（注意添加在尾部的斜线）。在Apache中可以用Alias,mod_rewrite或者DirectorySlash指令来取消不必要的重定向。 重定向最常见的用途就是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户账号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。 [javascript]去除重复脚本页面含有重复脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的javascript代码，而影响页面性能。 IE会产生不必要的HTTP请求，而Firefox不会。在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载的时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。 除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的javascript代码。 避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中使用SCRIPT标签： 1&lt;script type="text/javascript" src="path/to/*.js"&gt;&lt;/script&gt; [服务器]配置ETags实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETag可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的ETag来指定组件的ETag: 1234HTTP/1.1 200 OK Last-Modified; Tue,12 Dec 2006 03:03:58 GMT ETag: "17hkh23-3hn-42kj23jlj" Content-Length: 12195 然后，如果浏览器必须验证一个组件，它用If-None-Match请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。 12345GET /i/yahoo.gif HTTP/1.1 Host: us.yimg.com If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT If-None-Match: "10c24bc-4ab-457e1c1f" HTTP/1.1 304 Not Modified ETags存在的问题是它们由特定服务器构造的，所以如果浏览器从一个服务器获取最初的组件，然后想验证另一个服务器上的相同组件，ETags是无法匹配成功的，而用一群服务器处理请求在web站点中又非常普遍。默认情况下，Apache和IIS会在ETag中嵌入谁，以大大降低在服务器站点上有效性测试成功的几率。 [内容]让Ajax可缓存Ajax的一个好处是可以给用户提供即时反馈，因为它能够从后台服务器异步请求信息。然而，用Ajax就无法保证用户在等待异步javascript和XML响应返回期间不会非常无聊。在很多应用程序中，用户能够一直等待取决于如何使用Ajax。例如，在基于web的电子邮件客户端中，用户为了寻找符合他们搜索标准的邮件信息，将会保持对Ajax请求返回结果的关注。重要的是，要记得”异步”并不意味着”即时”。 要提高性能，优化这些Ajax响应至关重要。最重要的提高Ajax性能就是让响应变得可缓存，就像添上Expires或者Cache-Control HTTP头讨论的一样。下面适用于Ajax的其他规则： Gzip组件 减少DNS查找 压缩javascript 避免重定向 配置ETags 我们看下例子，一个web 2.0的电子邮价客户端用了Ajax来下载用户的通讯录，以便实现自动完成功能。如果用户从上一次使用之后再没有修改过她的通讯录，而且Ajax响应是可以缓存的，有尚未过期的Expires或者Cache-Control HTTP头，那么之前的通讯录就可以从缓存中读出。必须通知浏览器，应该继续使用之前之前缓存的通讯录响应，还是去请求一个新的。可以通过给通讯录的Ajax URL里添加一个表明用户通讯录最后修改时间的时间戳来实现，例如&amp;t=1190241612。如果通讯录从上一次下载之后再没有被修改过，时间戳不变，通讯录就将从浏览器缓存中直接读出，从而避免一次额外的HTTP往返消耗。如果用户已经修改了通讯录，时间戳也可以确保新的URL不会匹配缓存的响应，浏览器将请求新的通讯录条目。 即使Ajax响应是动态创建的，而且可能只适用于单用户，它们也可以被缓存，而这样会让你的WEB 2.0应用更快。 [服务器]尽早清空缓存区当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个flush()函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很轻的前端页面上（PS也就是说，响应时耗主要在后台方面时最能体现优势）。 比较理想的清空缓存区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和javascript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。 例如： 12345 ... &lt;!-- css, js --&gt;&lt;/head&gt;&lt;?php flush(); ?&gt;&lt;body&gt; ... &lt;!-- content --&gt; Yahoo!搜索开创了这项技术，而且真实用户测试研究也证明了使用这种技术的诸多好处。 [服务器]对Ajax用GET请求Yahoo!邮箱团队发现使用XMLHttpRequest时，浏览器的POST请求是通过一个两步的过程来实现的： 先发送HTTP头，再发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。 POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如HTTP说明文档中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。 [内容]延迟加载组件javascript是分隔onload事件之前和之后的一个理想选择。例如，如果javascript代码和支持拖放以及动画的库，这些都可以先等会儿，因为拖放元素是在页面最初渲染之后的。其它延迟加载的部分，包括隐藏内容（在某个交互动作之后才出现的内容）和折叠的图片。 工具可以帮你减轻工作量:YUI Image Loader可以延迟加载折叠的图片，还有YUI Get utility是一种引入javascript和css的简单方法。Yahoo!主页就是一个例子，可以打开Firebug的网络面板仔细看看。 最好让性能目标符合其它WEB开发最佳实践，比如”渐进增强”。如果客户端支持javascript，可以提高用户体验，但必须确保页面在不支持javascript时也能正常工作。所以，在确定页面运行正常之后，可以用一些延迟加载脚本增强它，以支持一些拖放和动画之类的华丽效果。 [内容]预加载组件预加载可能看起来和延迟加载是相反的，但它实际有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得很快的。 时间应用中有以下几种预加载的类型： 无条件预加载 ： 尽快开始加载，获取一些额外的组件。google.com就是一个sprite图片预加载的好例子，这个sprite图片并不是google.com主页需要的，而是搜索结果页面上的内容。 条件性预加载 ： 根据用户操作猜测用户跳转到哪里并据此预加载。 提前预加载 ： 在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但是比以前更慢了”，一部分原因是用户访问之前的页面都是旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。 [内容]减少DOM元素的数量一个复杂的页面意味着要下载更多的字节，而且用javascript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素是有区别的。 大量的DOM元素是一种征兆 ： 页面上有些内容无关的标记需要清理。正在用嵌套表格来布局吗？还是为了修复布局问题而添加了一堆的&lt;div&gt;？或许应该用更好的语义化标记。 DOM元素的数量很容易测试，只需要在Firebug的控制台输入: 1document.getElementsByTagName("*").length; 那么多少DOM元素才算是太多呢？可以参考其他类似的标记良好的页面，例如Yahoo!主页是一个相当繁忙的页面，但只有不到700个元素(HTML标签)。 [内容]跨域分离组件分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在www.example.org，而把静态组件分离到static1.example.org和static2.example.org。 更多信息请查看Tenni Theurer和Patty Chi的文章：Maximizing Parallel Downloads in the Carpool Lane [内容]尽量少使用iframe用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。 &lt;iframe&gt;的优点： 引入缓慢的第三方内容，比如标志和广告 安全沙箱 并行下载脚本 &lt;iframe&gt;的缺点： 代价昂贵，即使是空白的iframe 阻塞页面加载 非语义 [内容]杜绝404HTTP请求代价昂贵，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。 有些站点用的是有帮助的404 ： “你的意思是xxx？”，这样做有利于用户体验，但是也浪费了服务器的资源（比如数据库等等）。最糟糕的是连接到的外部javascript有错误而且结果是404。首先，这种下载将阻塞并行下载。其次，浏览器会试图解析404响应体，因为它是javascript代码，需要找出其中可以用的部分。 [cookie]给Cookie减肥使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。 更多信息请查看Tenni Theurer和Patty Chi的文章：When the Cookie Crumbles。相关经验原则可以总结如下： 清除不必要的cookie 保证cookie尽可能小，以最小化对用户响应时间的影响 注意给cookie设置合适的域级别，以免影响其他子域 设置适合的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间 [把组件放在不含cookie的域下]当浏览器发送静态图像的请求时，cookies也会一起发送，而服务器根本就不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署到那儿。 如果域名是www.example.org，可以把静态组件部署到static.example.org。然而，如果已经在顶级域example.org或者www.example.org设置了cookie，那么所有对static.example.org的请求都会含这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是yimg.com,YouTube是ytimg.com，亚马逊是images-amazon.com等等。 把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是www.example.org作为主页，可以考虑下cookie的影响。省略www的话，就只能把cookie写到*.example.org，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。 [javascript]尽量减少DOM访问用javascript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该： 缓存已访问过的元素的索引 先“离线”更新节点，再把它们添加到DOM树上 避免用javascript修复布局问题 更多信息请查看YUI影院里Julien Lecomte的文章：High Performance Ajax Applications [javascript]用智能的事件处理器有时候感觉页面反应不够灵敏，是因为有太多频繁执行的事件处理器被添加到DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。 不需要为了处理DOM树而等待onload事件，通常只有目标元素在DOM树中可以访问即可，而不必等待所有的图片下载完成。可以考虑用DOMContentLoaded来替代onload事件，但为了让它在所有浏览器中都可用，可以用YUI Event工具，它有一个onAvailable方法。 更多信息请查看YUI影院里Julien Lecomte的文章：High Performance Ajax Applications [CSS]选择舍弃@import前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。 在IE中用@import与底部用&lt;link&gt;效果一样，所以最好不要用它。 [CSS]避免使用滤镜IE专有的AlphaImageLoader滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个过滤会阻塞渲染，卡住浏览器，还会增加内存消耗而且被应用到每个元素的，而不是每个图片，所以会存在一大推问题。 最好的方法是干脆不要用AlphaImageLoader，而优雅地降级到用IE中支持性很好的PNG8图片来代替。如果非要用AlphaImageLoader，应该用下划线hack：_filter来避免影响IE7及更高版本的用户。 [图片]优化图片设计师做好图之后，在把这些图通过FTP上传到web服务器之前，我们还可以做一些事情。 检查GIF图片，看看图片中是不是用了调色板大小对应的颜色数，用imagemagick可以简单地检查：identify -verbose image.gif如果4色图片用了调色板中256色的“槽”，那就还有改进的余地 试着把GIF图片转换成PNG，看能不能缩减大小，往往可以。开发者通常不愿意用PNG图片，因为浏览器支持有限，但这都是过去的事情了。真正的问题是PNG图片完全支持alpha透明度，而GIF图片却不支持透明度渐变，所以GIF能做的任何事情,PNG都可以（除了动画）。下面这个简单的命令就能让PNG图片可以安全使用：convert image.gif image.png“我们强调的是：给PNG一个机会。” 用pngcrush（或者其他的PNG优化工具）处理所有的PNG图片，例如：pngcrush image.png -rem alla -reduce -brute result.png 用jpegtran处理所有JPEG图片，这个工具支持对JPEG图片的无损操作比如旋转，还可以用来去除注释和其他无用信息（比如EXIF信息 P.S.数码照片信息，焦距光圈之类的）：jpegtran -copy none -optimize -perfect src.jpg dest.jpg [图片]优化CSS Sprite 在Sprite图片中横向排列一般都比纵向排列的最终文件小 组合Sprite图片中的相似颜色可以保持低色度，最理想的是256色以下PNG8格式 “对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会有很大程度上影响文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100 x 100的图片是1万个像素，而1000 x 1000的图片就是100万个像素了。 [图片]不要用HTML缩放图片不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要&lt;img width=&quot;100&quot; height=&quot;100&quot;src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot;&gt;那么图片本身(mycat.jpg)应该是100 x 100px的，而不应该是去缩小500 x 500px的图片。 [图片]用更小的可缓存的favicon.ico（P.S.收藏夹图片）favicon.ico是放在服务器根目录的图片，它会带来一大堆麻烦，因为即使你不管它，浏览器也会自动请求它，所以最好不要给一个404 Not Found响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。 所以为了缓解favicon.ico的缺点，应该确保: 足够小，最好在1K以下 设置合理的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。 Imagemagick可以用来处理小收藏夹图标 [移动]保证所有组件都小于25K这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。 更多信息请查看Wayne Shea和Tenni Theurer的文章：Performance Research, Part 5: iPhone Cacheability – Making it Stick [移动]把组件打包到一个复合文档里把各个组件打包成一个像附有的电子邮件一样的符合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。 [服务器]避免图片src属性为空Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现： 1.straight HTML 2.Javascript var img = new Image();img.src = “” 这两种形式都会引起相同的问题：浏览器会向服务器发送另一个请求。 IE向页面所在目录发起一个请求 Safari和Chrome想当前页面本身发送一个请求 Firefox3及更早版本与Safari和Chrome处理方式一样，但3.5解决了这个问题bug 444931，不会再发送请求了 Opera遇到有空src属性的图片不做任何处理 为什么图片src属性为空不好？ 1.意外发送大量的通信量对服务器来说是很伤的，尤其是在每天有几百万访问量页面的时候。 2.浪费服务器资源去生成一个根本不可能看到的页面 3.可能会污染用户数据，如果追踪请求状态，要么通过cookie要么是其它方式，可能会破坏用户数据。即使图片请求并没有返回图片，整个HTTP头部也会被浏览器接受并读取，包括所有的cookie。虽然其余部分会被丢弃，但这可能已经造成破坏了。 参考前端优化：雅虎35条 精力有限，未能一次更新完毕，还请见谅…]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重读《JavaScript高级程序设计》]]></title>
    <url>%2F2018%2F03%2F01%2Fjavascript-high-level%2F</url>
    <content type="text"><![CDATA[最近自己在休假，打算闭门几天将《JavaScript高级程序设计》(第3版)这本良心教材再回顾一遍。目前自己进入前端领域两年多，现在重读并记录下这本教材的“硬”知识点 😊 。 函数没有重载ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数类型和数量）不同即可[p66]。ECMAScript的类型是松散形的，没有签名，所以是没有重载的。 12345678function load(num)&#123; return num + 100;&#125;function load(num,name)&#123; return num + 200;&#125;var result = load(100); // 200# 后面的函数声明覆盖掉前面的函数声明 基本的数据类型基本类型值指的是简单的数据段，而引用类型指那些可能由多个值构成的对象[p68]。这里指出来的基本的数据类型是说的es5的哈：Undefined,Null,Boolean,Number和String。 传递参数ECMAScript 中所有的函数的参数都是按值传递的[p70]。也就是说，把函数外部的值复制给函数内部的参数，就是把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。下面分开例子介绍两种不同类型为什么是按值传递。 基本类型值基本类型这个按值传递比较好理解，直接复制变量的值传递： 123456789function addTen(num)&#123; num += 10; return num;&#125;var count = 20;var result = addTen(count);console.log(result); // 30console.log(count); // 20 ，没有变化哈 引用类型值有些人认为引用类型的传参是按照引用来传的，那暂且认为他们的理解是正确的，那下面的示例结果怎么解析呢？ 12345678function setName(obj)&#123; obj.name = '嘉明'; obj = new Object(); obj.name = '庞嘉明';&#125;var person = new Object();setName(person);console.log(person.name); // '嘉明'，为啥不是'庞嘉明'呢？ 如果是按照引用传的话，那么新建的对象obj = new Object()应该是指向堆内容的对象啊，那么改变它本有的name属性值应该生效，然而并没有生效。所以它也是按值传递滴。 函数声明与函数表达式解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁[p111]。解析器会率先读取函数声明，并使其执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析。 1234console.log(sum(10 , 10)); // 20function sum(num1 , num2)&#123; return num1 + num2;&#125; 1234console.log(sum(10 , 10)); //TypeError: sum is not a functionvar sum = function(num1 , num2)&#123; return num1 + num2;&#125; apply和call每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值[116]。call和apply在对象中还是挺有用处的。 apply()方法和call()方法的作用是相同的，区别在于接收参数的方式不同。 applyapply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组，这里的参数数组可以是Array的实例，也可以是arguments对象（类数组对象）。 1234567891011function sum(num1 , num2)&#123; return num1 + num2;&#125;function callSum1(num1,num2)&#123; return sum.apply(this,arguments); // 传入arguments类数组对象&#125;function callSum2(num1,num2)&#123; return sum.apply(this,[num1 , num2]); // 传入数组&#125;console.log(callSum1(10 , 10)); // 20console.log(callSum2(10 , 10)); // 20 callcall()方法接收的第一个参数和apply()方法接收的一样，变化的是其余的参数直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。 1234567function sum(num1 , num2)&#123; return num1 + num2;&#125;function callSum(num1 , num2)&#123; return sum.call(this , sum1 , sum2);&#125;console.log(callSum(10 , 10)); // 20 创建对象虽然Object构造函数或者对象字面量都可以用来创建单个对象，但是这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。[p144] 工厂模式工厂模式就是造一个模子产生一个个对象。 12345678910111213function createPerson(name , age ,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson('nicholas' , 29 , 'software engineer');var person2 = createPerson('greg' , 27 , 'doctor'); 工厂模式解决了创建多个相似对象的问题（解决创建对象时产生大量重复代码），但是没有解决对象识别的问题（即怎么知道一个对象的类型，是Person还是Animal啊）。 构造函数模式下面使用构造函数创建特定类型的对象。这里是Person类型： 12345678910111213function Person(name , age , job)&#123; // 注意构造函数的首字母为大写哦 this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;&#125;var person1 = new Person('nicholas' , 29 , 'software engineer');var person2 = new Person('greg' , 27 , 'doctor');alert(person1.constructor == Person); // true 可以理解为person1的创造者是Person，也就是对象的类型Person 在创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此this指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 构造函数解决了重复实例话问题（也就是创建多个相似对象的问题）和解决了对象识别的问题。但是，像上面那样，person1和person2共有的方法，实例化的时候都创建了，这未免多余了。当然可以将共有的方法提取到外面，像这样： 1234567891011function Person(name , age , job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName()&#123; alert(this.name);&#125;var person1 = new Person('nicholas' , 29 , 'software engineer');var person2 = new Person('greg' , 27 , 'doctor'); 将sayName提取出来，就成了全局的方法了，然而这里只有Person类创建对象的时候才使用到，这样就大才小用了吧，所以提取出来到全局方法这种操作不推荐。 原型模式创建的每个函数都有一个prototype（原型）属性，这个属性就是一个指针，指向一个对象，而这个对象的用途就是包含可以由特定类型的所有实例共享的属性和方法。 123456789101112131415function Person()&#123;&#125;Person.prototype.name = 'nicholas';Person.prototype.age = 29;Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); // nicholasvar person2 = new Person();person2.sayName(); // nicholasconsole.log(person1.sayName == person2.sayName); // true 可以有关系图如下： 上面的Person.prototype不建议使用字面量来写Person.prototype={},虽让效果一样，但是这里重写了原本Person.prototype的对象，因此constructor属性会指向Ohject而不是Person。当然也是可以处理的啦，将指向指正确并指定’construtor’的枚举属性为enumerable: false。 原型模式解决了函数共享的问题，但是也带了一个问题：实例化中对象的属性是独立的，而原型模式这里共享了。 组合使用构造函数模式和原型模式创建自定义类型的最常见的方式，就是组合使用构造函数模式和原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。 123456789101112131415161718function Person(name , age ,job)&#123; this.name = name; this.age = age; this.job = job; this.friends = ['shelby' , 'court'];&#125;Person.prototype.sayName = function()&#123; alert(this.name);&#125;var person1 = new Person('nicholas' , 29 , 'software engineer');var person2 = new Person('greg' , 27 , 'doctor');person1.friends.push('van');console.log(person1.friends); // 'shelby,court,van'console.log(person2.friends); // 'shelby,court'console.log(person1.friends === person2.friends); // falseconsole.log(person1.sayName === person2.sayName); // true 动态原型模式其他的OO语言，比如java，创建对象的类中是包含了自身的属性、方法和共有的属性、方法，如下小狗的例子： 12345678910111213141516171819202122232425public class Dog&#123; int age; public Dog(String name )&#123; this.age = age; System.out.println('小狗的名字是: ' + name); &#125; public void setAge(int age)&#123; age = age; &#125; public int getAge()&#123; System.out.println('小狗的年龄为: ' + age); return age; &#125; public static void main(String []args)&#123; /* 创建对象 */ Dog dog = new Dog('tom'); /* 通过方法来设定age */ dog.setAge(2); /* 调用另外一个方法获取age */ dog.getAge(); /* 也可以通过 对象.属性名 获取 */ System.out.println('变量值: ' + dog.age); &#125;&#125; 为了看起来是类那么一会事，动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。如下: 1234567891011121314function Person(name , age ,job)&#123; // 属性 this.name = name; this.age = age; this.job = job; // 方法 if(typeof this.sayName != 'function')&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125; &#125;&#125;var friend = new Person('nicholas' , 29 , 'software engineer');friend.sayName(); 寄生构造函数模式在前面几种模式都不适应的情况下，可以用寄生构造函数模式（数据结构中就使用到哈），寄生构造函数模式可以看成是工厂模式和构造函数模式的结合体。其基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。 12345678910111213function Person(name , age , job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125; return o;&#125;var friend = new Person('nicholas', 29 , 'software engineer');friend.sayName(); // nicholas 关于寄生构造函数模式，需要说明：返回的对象与构造函数或者与构造函数的原型属性直接没有什么关系；也就是说，构造函数返回的对象与构造函数外部创建的对象没有什么区别。为此，不能依赖instanceof操作符来确定对象类型。由于存在上面的问题，建议在可以使用其他模式的情况下，不要使用这种模式。 稳妥构造函数模式稳妥对象适合在一些安全的环境中（这些环境中会禁止使用this和new），或者防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但是有两点不同：意识新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数。 1234567891011121314151617function Person(name , age , job)&#123; // 创建要返回的对象 var o = new Object(); // 可以在这里定义私有的变量和函数 // 添加方法 o.sayName = function()&#123; alert(name); // 不使用this.name &#125;; // 返回对象 return o;&#125;var friend = Person('nicholas', 29 , 'software engineer'); // 不使用newfriend.sayName(); // 'nicholas' 继承许多的OO语言都支持两种继承方法：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现主要是依靠原型链来实现的。[p162] 原型链原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。回顾下构造函数、原型和实例的关系: 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 12345678910111213141516171819function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;function SubType()&#123; this.subProperty = false;&#125;// 继承了SuperType,重点哦SubType.prototype = new SuperType();SubType.prototype.getSubValue = function()&#123; return this.subProperty;&#125;var instance = new SubType();console.log(instance.getSuperValue()); // true 上面代码中原型链如下： 原型链继承带来两个问题：一是原型实际上变成了另一个类型的实例，于是，原先的实例属性也就变成了现在原型的属性，共享了属性。二是在创建子类型的实例时，不能在没有影响所有对象实例的情况下向超类型的构造函数传递参数。 借用构造函数借用构造函数解决原型链继承带来的不能向构造函数传递仓鼠的问题。这里使用到了apply()或者call()方法在新创建的对象上执行构造函数。 1234567891011121314function SuperType()&#123; this.colors = ['red','blue','green'];&#125;function SubType()&#123; // 继承SuperType SubType.call(this); // 使用SubType.apply(this)同效&#125;var instance1 = new SubType();instance1.color.push('black');console.log(instance1.colors); // 'red,blue,green,black'var instance2 = new SubType();console.log(instance2.colors); // 'red,blue,green' 上面的例子中，我在父类型构造函数中没有传参数，看者感兴趣的话可以自己加下参数来实验一番咯。 借用构造函数解决了原型链继承的确定，但是又没有接纳原型链的优点：共享。下面的组合继承结合了原型链和借用构造函数，容纳了两者的优点。 组合继承组合继承的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 123456789101112131415161718192021222324252627282930function SuperType(name)&#123; this.name = name; this.colors = ['red','blue','green'];&#125;SuperType.prototype.sayName = function()&#123; console.log(this.name);&#125;function SubType(name,age)&#123; // 继承属性 SuperType.call(this,name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.constructor =SubType; // 避免重写构造函数指向错误SubType.prototype.sayAge = function()&#123; console.log(this.age);&#125;var instance1 = new SubType('nicholas' , 29);instance1.colors.push('black');console.log(instance1.colors); // 'red,blue,green,black'instance1.sayName(); // 'nicholas'instance1.sayAge(); // 29var instance2 = new SubType('greg' , 27);console.log(instance2.colors); // 'red,blue,green'instance2.sayName(); // 'greg'instance2.sayAge(); // 27 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为了JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。 原型式继承原型式继承是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义的类型。 1234567891011121314151617181920function object(o)&#123; // 传入一个对象 function F()&#123;&#125;; F.prototype = o; return new F();&#125;var person = &#123; name : 'nicholas', friends: ['shelby','court','van']&#125;;var anotherPerson = object(person);anotherPerson.name = 'greg';anotherPerson.friends.push('rob');var yetAnotherPerson = object(person);yetAnotherPerson.name = 'linda';yetAnotherPerson.friends.push('barbie');console.log(person.friends); // 'shelby,court,van,rob,barbie' 寄生式继承寄生式继承是与原型继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即是创建了一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的做了所有工作一样返回对象。 123456789101112131415161718function object(o)&#123; // 传入一个对象 function F()&#123;&#125;; F.prototype = o; return new F();&#125;function createAnother(original)&#123; var clone = object(original); clone.sayHi = function()&#123; console.log('hi'); &#125;; return clone;&#125;var person = &#123; name : 'nicholas', friends : ['shelby','court','van']&#125;var anotherPerson = createAnother(person);anotherPerson.sayHi(); // 'hi' 上面的例子中，新对象anotherPerson不仅具有person的所有属性和方法，而且还有了自己的sayHi()方法。 寄生组合式继承组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。寄生组合式继承能够解决这个问题。 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型的原型的一个副本而已。寄生组合式继承的基本模式如下： 123456function inheritPrototype(subType,superType)&#123; var prototype = Object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象，防止下面重写constructor属性 subType.prototype = prototype; // 指定对象 &#125; 一个完整的例子如下,相关插图见书[p173]: 123456789101112131415161718192021222324function inheritPrototype(subType,superType)&#123; var prototype = Object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype; &#125;function SuperType(name)&#123; this.name = name; this.color = ['red','blue','green'];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;function SubType(name, age)&#123; SuperType.call(this,age); // 只在这调用了一次超类型的构造函数&#125;inheritPrototype(SubType , SuperType);SubType.prototype.sayAge = function()&#123; console.log(this.age);&#125;var instance = new SubType('nicholas' , 29); 上面的例子的高效处体现在它只调用了一次SuperType构造函数，并且避免了在SubType.prototype上创建不必要的，多余的属性。与此同时，原型链还能保持不变；因此还能正常使用instanceof和inPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 闭包闭包是指有权访问另一个函数作用域中的变量的函数。我的理解是，函数内的函数使用到外层函数的变量延长变量的生存时间，造成常驻内存。例子见下： 1234567891011121314function foo()&#123; var a = 2; return function()&#123; a += 1; console.log(a); &#125;&#125;var baz = foo();baz(); // 3baz(); // 4baz(); // 5baz(); // 6 上面的例子中，外部的函数foo()执行完成之后，正常的情况下应该销毁a变量的，但是内部的返回的匿名函数使用到该变量，不能销毁。如果需要销毁的话，可以改写成下面： 1234567891011function foo()&#123; var a = 2; return function()&#123; a += 1; console.log(a); &#125;&#125;var baz = foo();baz(); // 3baz = null; // 将内部的匿名函数赋值为空 从闭包说起谈到了闭包，这让我想起了不久前刷知乎看到一篇文章。自己整理如下： 12345678for(var i = 0 ; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,1000)&#125;console.log(i);// 5,5,5,5,5,5 上面的代码是输出了6个5，而这6个5是这样执行的，先输出全局中的console.log(i)，然后是过了1秒种后，瞬间输出了5个5（为什么用瞬间这个词呢，怕看者理解为每过一秒输出一个5）。解读上面的代码的话，可以通过狭义范围(es5)的理解：同步 =&gt; 异步 =&gt; 回调 （回调也是属于异步的范畴，所以我这里指明了狭义啦）。先是执行同步的for,遇到异步的setTimeout(setTimeout和setInterval属于异步哈)后将其放入队列中等待，接着往下执行全局的console.log(i)，将其执行完成后执行异步的队列。 追问1:闭包 改写上面的代码，期望输出的结果为：5 =&gt; 0,1,2,3,4。改造的方式一： 12345678910for(var i = 0; i &lt; 5; i++)&#123; (function(j)&#123; setTimeout(function()&#123; console.log(j); &#125;,1000); &#125;)(i);&#125;console.log(i);// 5,0,1,2,3,4 上面的代码巧妙的利用IIFE(Immediately Invoked Function Expression:声明即执行的函数表达式)来解决闭包造成的问题，闭包的解析看上面。 方法二：利用js中基本类型的参数传递是按值传递的特征，改造代码如下 1234567891011var output = function(i)&#123; setTimeout(function()&#123; console.log(i); &#125;,1000);&#125;;for(var i = 0; i &lt; 5; i++)&#123; output(i); // 这里传过去的i值被复制了&#125;console.log(i);// 5,0,1,2,3,4 上面改造的两个方法都是执行代码后先输出5，然后过了一秒种依次输出0,1,2,3,4。 如果不要考虑全局中的console.log(i)输出的5，而是循环中输出的0,1,2,3,4。你还可以使用ES6的let块级作用域语法,实现超级简单: 1234567for(let i = 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,1000);&#125;// 0,1,2,3,4 上面是过了一秒钟后，依次输出0,1,2,3,4。这种做法类似于无形中添加了闭包。那么，如果使用ES6语法的话，会怎样实现5,0,1,2,3,4呢？ 追问2:ES6 改造刚开始的代码使得输出的结果是每隔一秒输出0,1,2,3,4，大概第五秒输出5。 在不使用ES6的情况下： 123456789101112for(var i = 0; i &lt; 5; i++)&#123; (function(j)&#123; setTimeout(function()&#123; console.log(j); &#125;,1000*j); &#125;)(i);&#125;setTimeout(function()&#123; console.log(i);&#125;,1000*i);// 0,1,2,3,4,5 上面的代码简单粗暴，但是不推荐。看题目是每隔一秒输出一个值，再回调实现最后的5输出，这个时候应该使用ES6语法来考虑，应该使用Promise方案： 1234567891011121314151617181920const tasks = [];for(var i = 0; i &lt; 5; i++)&#123;// 这里的i声明不能改成let，改成let的话请看下一段代码 ((j)=&gt;&#123; tasks.push(new Promise((resolve)=&gt;&#123; // 执行tasks setTimeout(()=&gt;&#123; console.log(j); resolve(); // 这里一定要resolve,否则代码不会按照预期执行 &#125;,1000*j); &#125;)) &#125;)(i);&#125;Promise.all(tasks).then(()=&gt;&#123; // 执行完tasks，回调 setTimeout(()=&gt;&#123; console.log(i); &#125;,1000);&#125;);// 符合要求的每隔一秒输出// 0,1,2,3,4,5 如果是使用let，我的改造如下： 1234567891011121314151617const tasks = [];for (let i = 0; i &lt; 5; i++) &#123; tasks.push(new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i); resolve(); &#125;, 1000 * i); &#125;));&#125;Promise.all(tasks).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(tasks.length); &#125;, 1000);&#125;);// 0,1,2,3,4,5 上面的代码比较庞杂，可以将其颗粒话，模块化。对上面两段代码的带var那段进行改造后如下： 1234567891011121314151617181920const tasks = []; // 这里存放异步操作的Promiseconst output = (i) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(()=&gt;&#123; console.log(i); &#125;,1000*i);&#125;);// 生成全部的异步操作for(var i = 0; i &lt; 5; i++)&#123; tasks.push(output(i));&#125;// 异步操作完成之后，输出最后的iPromise.all(tasks).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;,1000);&#125;);// 符合要求的每隔一秒输出// 0,1,2,3,4,5 追问3:ES7 既然ES6的Promise可以写，那么ES7是否可以写呢，从而让代码更加简洁易读？那就使用到到了异步操作的async await特性啦。 1234567891011121314151617// 模拟其他语言中的sleep，实际上可以是任何异步操作const sleep = (time) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(resolve , time);&#125;);(async () =&gt; &#123; for(var i = 0; i &lt; 5; i++)&#123; await sleep(1000); console.log(i); &#125; await sleep(1000); console.log(i);&#125;)();// 符合要求的每隔一秒输出// 0,1,2,3,4,5 浏览器窗口位置IE、Safari、Opera和Chrome都提供了screenLeft和screenTop属性，分别表示浏览器窗口相对于屏幕左上角和上边的位置[p197]。Firefox则以screenX和screenY属性来表示。为了兼容各个浏览器，可以入下面这样写： 12var leftPos = (typeof window.screenLeft == "number")?window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == "number")? window.screenTop : window.screenY; 浏览器窗口大小由于浏览器厂商以及历史的问题，无法确认浏览器本身的大小，但是可以取得视口的大小[p198]。如下： 123456789101112var pageWidth = window.innerWidth, pageHeight = window.innerHeight; if(typeof pageWidth != "number")&#123; if(document.compatMode == 'CSS1Compat')&#123; // 标准模式下的低版本ie pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125;else&#123; // 混杂模式下的chrome pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 上面的示例可以简写成下面这样： 12var pageWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;var pageHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; canvas中的变换为绘制上下文应用变换，会导致使用不同的变换矩阵应用处理，从而产生不同的结果。[p453] 可通过下面的方法来修改变换矩阵: rotation(angle):围绕原点旋转图像angle弧度 scale(scaleX,scaleY) translate(x,y): 将坐标原点移动到(x,y)。执行这个变换后，坐标(0,0)会变成之前由(x,y)表示的点。 JSON关于JSON，最重要的是要理解它是一种数据格式，不是一种编程语言。 对象字面量和JSON格式比较先来看下对象字面量demo写法： 12345678910var person = &#123; name : "nicholas", age : 29&#125;;# 上面的代码也可以写成下面的var person = &#123; "name" : "nicholas", "age" : 29&#125;; 而上面的对象写成数据的话，就是下面这样了： 123456&#123; "name": "nicholas ", "age": 29&#125;# 可到网站 https://www.bejson.com/ 验证 ⚠️ 与JavaScript对象字面量相比，JSON对象又两个地方不一样。首先，没有声明变量(JSON中没有变量的概念)。其次，没有分号(因为这不是JavaScript语句，所以不需要分号)。留意的是，对象的属性必须加双引号(不是单引号哦)，这在JSON中是必须的。 stringify()和parse()可以这么理解：JSON.stringify()是从一个object中解析成JSON数据格式，而JSON.parse()是从一个字符串中解析成JSON数据格式。 12345678910var person = &#123; name: 'nicholas', age: 29&#125;;var jsonText = JSON.stringify(person);console.log(jsonText);// &#123;"name":"nicholas","age":29&#125; 1234var strPerson = '&#123;"name":"nicholas","age":29&#125;';var jsonText = JSON.parse(strPerson);console.log(jsonText); // &#123; name: 'nicholas', age: 29 &#125; XMLHttpRequest对象XMLHttpRequest对象用于在后台与服务器交换数据。它是Ajax技术的核心[p571]。 XMLHttpRequest对象能够使你： 在不重新加载页面的情况下更新网页 在页面已加载后从服务器请求数据 在页面已加载后从服务器接收数据 在后台向服务器发送数据 XMLHttpRequest的使用： 123456789101112131415161718192021222324252627282930313233343536373839# 创建XHR对象 =&gt; open()准备发送 =&gt; send()传送数据// 创建对象，对浏览器做兼容function createXHR()&#123; if(typeof XMLHttpRequest != 'undefined')&#123; // IE7+和其他浏览器支持 return new XMLHttpRequest(); &#125;else if(typeof ActiveXObject != 'undefined')&#123; if(typeof arguments.callee.activeXString != 'string')&#123; var versions = ['MSXML2.XMLHttp.6.0','MSXML2.XMLHttp.3.0','MSXML2.XMLHttp']; // 低版的ie可能遇到三种不同版本的XMR对象 var i , len; for(i = 0,len = versions.length; i &lt; len ; i++)&#123; try&#123; new ActiveXObject(version[i]); arguments.callee.activeXString = versions[i]; break; &#125;catch (ex)&#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125;else&#123; throw new Error("No XHR object available."); &#125;&#125;var xhr = createXHR();// 准备发送数据xhr.open("get","path/to/example.txt",false);// 非异步，异步的话第三个参数改为true// 传送数据xhr.send(null); // get方法不需要传数据// 判断状态嘛，获取服务器返回的数据if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log(xhr.responseText);&#125;else&#123; console.log("Request was nsuccessful : " + xhr.status);&#125; 跨域解决方案何为跨域呢？只要访问的资源的协议、域名、端口三个不全相同，就可以说是非同源策略而产生了跨域了，这是狭义的说法。广义的说法：通过XHR实现Ajax通信的一个主要限制，来源于跨域的安全策略；默认情况下,XHR对象只能访问包含它的页面位于同一个域中的资源[p582]。注：部分文字和代码引用自前端常见跨域解决方案（全） CORSCORS（Cross-Origin Resource Sharing，跨资源共享）定义了在必须访问跨资源时，浏览器与服务器应该如何沟通。其背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 复杂的跨域请求应当考虑使用它。 普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无需设置，如果要带cookie请求：前后端都要设置。 1.前端设置 1.) 原生ajax 1234567891011121314151617181920212223242526272829303132333435function createCORSRequest(method,url)&#123; // 兼容处理，ie8/9需要用到window.XDomainRequest var xhr = new XMLHttpRequest(); // 前端设置是否带cookie xhr.withCredentials = true; if("withCredentials" in xhr)&#123; // 其他的用到withCredentials xhr.open(method,url,true); &#125;else if(typeof XDomainRequest != 'undefined')&#123; xhr = new XDomainRequest(); xhr.open(method , url); &#125;else&#123; xhr = null; &#125; return xhr;&#125;// get请求var request = createCORSRequest("get","http://www.somewhere-else.com/page/");if(request)&#123; request.onload = function()&#123; // 对request.responseText 进行处理 &#125;; request.send();&#125;// post请求，带cookievar requestXhr = createCORSRequest("post","http://www.somewhere-else.com/page/");requestXhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");requestXhr.send("user=admin");xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;; 2.)jquery ajax 上面写了一大堆原生的，看得头都有点大了，还是使用jquery ajax 比较舒服: 12345678$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); 3.) vue框架 在vue-resource封装的ajax组建中加入以下代码: 1Vue.http.options.credentials = true; 2.服务器设置 若后端设置成功，前端浏览器控制台上就不会出现跨域报错的信息，反之，说明没有成功。 1.） java后台 123456/* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com"); // 若有端口需写全（协议+域名+端口）response.setHeader("Access-Control-Allow-Credentials", "true"); 2.) node后台 123456789101112131415161718192021222324252627282930var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var postData = ''; // 数据块接收中 req.addListener('data', function(chunk) &#123; postData += chunk; &#125;); // 数据接收完毕 req.addListener('end', function() &#123; postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, &#123; 'Access-Control-Allow-Credentials': 'true', // 后端允许发送Cookie 'Access-Control-Allow-Origin': 'http://www.domain1.com', // 允许访问的域（协议+域名+端口） 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取cookie &#125;); res.write(JSON.stringify(postData)); res.end(); &#125;);&#125;);server.listen('8080');console.log('Server is running at port 8080...'); JSONPJSONP是JSON with padding(填充式JSON或参数式JSON)的简写，是应用JSON的一种新方法，在后来的web服务中非常流行。简单的跨域请求用JSONP即可。 通常为了减轻web服务器的负载，我们把js,css,img等静态资源分离到另一台独立域名的服务器，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 1.前端实现 1.）原生实现 12345678910111213&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res)&#123; console.log(JSON.stringify(res)); &#125;&lt;/script&gt; 服务器返回如下（返回时即执行全局函数）： 1onBack(&#123;"status": true,"user":"admin"&#125;) 2.）jquery ajax 1234567$.ajax(&#123; url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: 'onBack', // 自定义回调函数名 data: &#123;&#125;&#125;); 3.）vue.js 123456this.$http.jsonp('http://www.domain2.com:8080/login',&#123; params: &#123;&#125;, jsonp: 'onBack '&#125;).then((res)=&gt;&#123; console.log(res);&#125;); 2.后端nodejs代码的示范： 1234567891011121314151617var qs = require('querystring');var http = require('http');var server = http.createServer();server.on('request',function(req,res)&#123; var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200,&#123;"Content-Type":"text/javascript"&#125;); res.write(fn + '('+JSON.stringify(params)+')'); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080 ...'); ⚠️ jsonp缺点： jsonp只支持get请求而不支持post请求，也就是说如果想传给后台一个json格式的数据，此时问题就来了，浏览器回报一个http状态码415错误，告诉你请求格式不正确。 存在明显的安全性问题，容易收到xss攻击 WebSocket协议跨域WebSocket protocol 是 HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯。 原生的WebSocket API使用起来不太方便，示例中使用了socket.io，它很好的封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 1.前端代码 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type="text"&gt;&lt;/div&gt;&lt;script src="./socket.io.js"&gt;&lt;/script&gt;&lt;script&gt;var socket = io('http://www.domain2.com:8080');// 连接成功处理socket.on('connect', function() &#123; // 监听服务端消息 socket.on('message', function(msg) &#123; console.log('data from server: ---&gt; ' + msg); &#125;); // 监听服务端关闭 socket.on('disconnect', function() &#123; console.log('Server socket has closed.'); &#125;);&#125;);document.getElementsByTagName('input')[0].onblur = function() &#123; socket.send(this.value);&#125;;&lt;/script&gt; 2.node socket后台 123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) &#123; // 接收信息 client.on('message', function(msg) &#123; client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); &#125;); // 断开处理 client.on('disconnect', function() &#123; console.log('Client socket has closed.'); &#125;);&#125;); requestAnimationFrame()帧动画requestAnimationFrame 创建平滑的动画[p682]。在此之前都是使用setTimeout或者setInterval实现，requestAnimationFrame与它们相比： 不需要时间间隔，会贴切浏览器的刷新频率 在切换到另外的页面时，会停止运行 使用的示范如下： 1&lt;div id="num"&gt;1&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637// 兼容浏览器(function()&#123; var lastTime = 0; var vendors = ['webkit','moz','ms','-o']; for(var x = 0;x &lt;vendors.length &amp;&amp; !window.requestAnimationFrame; ++x)&#123; window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x] + 'cancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame']; &#125; if(!window.requestAnimationFrame)&#123; window.requestAnimationFrame = function(callback)&#123; var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function()&#123; callback; &#125;,timeToCall); lastTime = currTime - timeToCall; return id; &#125; &#125; if(!window.cancelAnimationFrame)&#123; window.cancelAnimationFrame = function (id)&#123; clearTimeout(id); &#125; &#125;&#125;)();// 简单的计数var num = 1, timer;fn();function fn()&#123; document.getElementById('num').innerText = ++num; timer = requestAnimationFrame(fn);&#125;document.onclick = function()&#123; cancelAnimationFrame(timer);&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2018计划]]></title>
    <url>%2F2018%2F02%2F21%2Fmy-2018-plans%2F</url>
    <content type="text"><![CDATA[嗖～嗖～嗖～～～🚀现在是农历正月初六的晚上十一点多，第二天就得上班了呢，一年的时间过得真是賊快，来不及感叹2017年自己做了什么，只想着眼现在，立flag啦，鬼知道我会在新的一年会遇到什么人和事情呢。希望一年后回头看不打脸咯… 看书看完下面的推荐书籍中的3-5本： 保罗.约翰逊 《文明的解析》 乔治.阿克洛夫 《动物精神》 南希.休斯顿 《断层线》 安德鲁.罗斯.索尔金 《大而不倒》 保罗.克利尔 《被掠夺的星球》 马特.里德利 《理智的乐观者》 丹.艾瑞里 《非理性的积极力量》 莱茵哈特.罗格夫 《这次不一样》 乔纳森.弗兰岑 《自由》 里查德.克拉克和罗伯特.克纳克 《网络战争》 巴塞维奇 《华盛顿规则》 查布里斯.西蒙斯 《看不见的大猩猩》 托尼.朱特 《乡土式微》 阿维沙伊.马加利特 《关于妥协和卑微的妥协》 奇普.希思 《瞬变》 刘易斯 《大空头》 查尔斯.默里 《人类成就》 瓦茨拉夫.斯米尔 《能源神话与现实》 南丹.尼莱卡尼 《印度畅想》 克莱.舍基 《未来是湿的》 深造好吧，过年回去已经跟家人达成协议，2018要把考研列入其中(虽然感觉2018年考进是不可能的，还是立下flag咯)，嗯，工作之余努力读书哦，除了程序猿一职，我还有一职—-永远都是学生哈哈哈。对了，英文提高很重要，这也涉及到下面的技能提升。 技能作为一个码农，自己的码农技能总得上升一个阶段吧。将javascript的使用不仅仅局限于前端。自己的工作不仅仅是前端。相关的技能是html/html5,css/css3和javascript为主，java等为辅。 旅游下面的地点选择1-2进行旅游: 泰国 新疆 云南 海南 成都 杭州 北京 潮汕 厦门 成都 就此打住了，这么列下来，感觉自己2018年要累成狗。希望能完成这些模糊又肯定的目标，对了，希望在新的一年里面能够遇到对的那个人 😂]]></content>
      <categories>
        <category>诗和远方</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack从零构建vue项目]]></title>
    <url>%2F2018%2F01%2F16%2Fwebpack-build-vue-project%2F</url>
    <content type="text"><![CDATA[看官别急 工作之余更新 预计2018.3.30(乐观的时间，因为自己时间感觉不够用)前完成本博文更新 可文末留言更新建议或打赏 看者可以到自己几个月前搭建的一个小的webapck项目github仓库下简单看搭建过程啦，如果你在webpack项目中留颗星星那就更好了。 本博客因为自己事情忙暂时停，完成的时间待定，望见谅… webpack是什么官方描述：At its core, webpack is a static module bundler for modern JavaScript applications. When webpack processes your application, it recursively builds a dependency graph that includes every module your application needs, then packages all of those modules into one or more bundles. 鄙人的翻译：webpack的核心是现代javascript程序的静态模块打包工具。当webpack处理你的应用的时候，它会根据你的应用需要的模块递归的描绘出一个依赖图，然后打包这些模块到指定的一个或者多个文件中。 翻译不妥，还请指出。 webpack核心概念webpack的核心包括： 入口(entry)，出口(output)，加载器(loader)和插件(plugin)。 Entry入口entry指明webpack应该从哪个文件开始解析去构建它内部的依赖图。入口的语法可以分为下面的这些 ： 单一的入口 使用方法： entry: string|Array&lt;string&gt; 相关的demo如下 ： 1234const config = &#123; entry: '/path/to/my/entry/file.js'&#125;;module.exports = config; 多入口（类型入口） 使用方法： entry:{[entryChunkName: string]: string|Array&lt;string&gt;} 相关的demo如下 ： 1234567const config = &#123; entry: &#123; app: '/path/to/app.js', vendors: '/path/to/vendors.js' &#125;&#125;;module.exports = config; Output输出点output是告诉webpack它处理后的文件命名和文件应该存放在哪里。 用法 (1) 属性filename是用来告诉webpack输出到的文件 (2) 属性path是确定文件的绝对路径，一般是用path.resolve(__dirname,’directoryName’) 单文件出口 单文件出口就是webpack处理后只输入一个文件，demo如下: 1234567const config = &#123; output: &#123; filename: 'bundle.js', path: '/path/to/project/assets' &#125;&#125;;module.exports = config; 多文件输出 如果想在多入口文件中输出对应的文件的话，就需要用到webpack带的name属性了，demo如下: 12345678910&#123; entry: &#123; app: '/path/to/app.js', search: '/path/to/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist' # 一般是存放在dist文件夹下啦 &#125;&#125; 执行相关的命令行后，就会在dist文件下面看到app.js和search.js文件了。 Loaderswebpack它本身只能够识别javascript文件，那么要webpack来处理除了javascript文件之外的文件，就需要用到loaders了。简单来讲，Loaders能够转换你应用中所有类型的文件到依赖的视图里面。 在webpack的配置中，Loaders需要注意以下的两点: (1) test属性定义哪种类型的文件应该被转换 (2) use属性指明哪种加载器应该用来转换文件 如下面的demo的rule字段中匹配后缀名为.txt的文件(假设你已经安装了raw-loader) ： 1234567891011121314151617const path = require('path)const config = &#123; entry: '/path/to/file.js', output: &#123; path: path.resolve(__dirname,'dist'), filename: 'file.name.js' &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;&#125; PluginsPlugin范围可以从优化和压缩的方法到定义类似环境的变量。英文原话Plugins range from bundle optimization and minification all the way to defining environment-like variables。 如果你要使用插件，你需要使用require()方法将它添加到plugins的数组中，然后创建相关的实例。下面以html-webpack-plugin插件为例子(前提是你已经安装了这个插件): 123456789101112131415161718192021222324252627const HtmlWebpackPlugin = require('html-webpack-plugin');const webpack = require('webpack');const path = require('path');const config = &#123; entry: '/path/to/entry/file.js', output: &#123; path: path.resolve(__dirname,'dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: '/\.txt$/', use: 'raw-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;) ]&#125;;module.exports = config; webpack项目搭建过程简单的讲解了webpack的核心概念，那么接下来就使用webpack来搭建项目吧。下面讲解整个的项目搭建的过程。😊 项目的初始化通过命令行npm init -y的初始化项目，建议在桌面新建文件（因为后面好找啊）还有通过npm init进行项目的初始化（自己可以控制内容）。自己在osx系统上是经过下面的步骤建项目的，如果你使用的电脑是其他系统，有所出入，请留意。 1234567891011121314$ cd desktop # 进入桌面$ mkdir projectName &amp;&amp; cd cd projectName # 新建目录并进入$ npm init # 开始初始化项目package name: as you like # 填写包名称，默认projectNameversion: as you like # 项目的版本号，默认1.0.0description: as you like # 关于项目的描述，默认为空entry point: as you like # 项目的入口文件，默认是index.jstest command: as you like # 测试命令，默认为空git repository: relatived git repository that you like # 相关的git仓库，如果有请关联一个，这样好管理。默认为空keyword: as you like # 项目的关键词，默认为空author: your name # 项目的作者/发起人，默认为空license: license you write # 相关的证书，默认是ISCIs this ok?(yes) # 询问你设置是否确认，确认的话就按回车键。如果放弃请英文输入法输入n，再按下回车键，就放弃更改，回到最初状态了，再执行 npm init 如果你直接执行npm init -y就会直接使用默认状态啦，如下： 1234567891011121314151617$ cd desktop$ mkdir projectName &amp;&amp; cd projectName$ npm init -yWrote to /Users/reng/Desktop/demo/package.json:&#123; "name": "projectName", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], "author": "", "license": "ISC"&#125; 个人还是比较偏向npm init啦！ 有待补充 全栈项目是什么全栈项目呢？说实在，自己还没想好 😂 看情况写或者不写 有待补充 参考webpack官网 vue官网 精力有限，未能一次性更新完,忘见谅…]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>mvvm</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex 要点]]></title>
    <url>%2F2018%2F01%2F01%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex是一个状态管理模式，通过用户的actions触发事件，然后通过mutations去更改数据（你也可以说状态啦 -&gt; state），最后通过getters对状态进行获取，更改页面展示的内容。哈哈 😄 ，详细的内容请接着往下看，如有不妥请文末留言啊。原创文章，转载请注明出处。 注意 ⚠️ 文章中涉及到项目代码是使用Vue官方提供的脚手架vue-cli进行搭建的，如果看者感兴趣，可以自行用vue-cli搭建项目，并进行代码的验证。 Vuex是什么官网介绍:Vuex是一个专门为Vuejs应用程序开发的状态管理模式。（类似react的redux）。Vuex采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex在构建中大型的应用比较适用，小型的应用用组件之间的通信就可以了，小型应用用上Vuex就显得比较臃肿了。 Vuex的安装因为自己是使用npm来辅助开发的，所以我也只说下通过npm安装Vuex的方法。其他的安装方法，请戳传送门。 进入你项目的根目录，然后执行: 123$ npm install vuex --save 或$ npm install vuex --save-dev 然后在store主入口的javascript文件，一般是store/index.js中通过use进行引用，前提是你已经安装了vue : 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 为了方便在各个组件中使用store，需要在程序的根组件中将其注入到每个子组件。我们需要在实例化Vue的时候将store引入（实例化Vue的文件一般是main.js主入口文件）。 123456import Vue from 'vue'import store from '/path/to/store/index.js'const initApp =new Vue(&#123; store: store &#125;).$mount('#app') 核心概念在使用Vuex进行开发的过程中，你可以理解核心的概念只有State、Action和Mutation三个，就像本文章开篇给出的截图流程那样简单明了。但是，我们使用Vuex开发一个应用，肯定是想要方便管理等等。这里自己按照五个核心概念来谈谈，五个核心概念也是官网推荐使用的。Vuex的五个核心概念除了上面指出的三个之外，还包括Getter和Module两个。先一句话来概括下它们 : State : 数据源的存放地 Getter : store的计算属性 Mutation : 处理数据逻辑，使得数据和视图分离（同步） Action : 类似Mutation（异步），改变状态的话，还得触发Mutation Module : 将store分解成模块 下面来详细讲解各个核心概念咯 😊 StateVuex是使用单一状态树，一个对象就包含了全部的应用层级状态。这也就表明，一个应用仅仅包含一个store的实例。 状态State对应于Vue对象中的data，因为两者是对应的关系，所以在这里可以称状态==数据的。如下代码指出： 12345678910&lt;script&gt; export default &#123; name: '', data() &#123; // state对应的地方 return &#123; ... &#125; &#125; &#125;&lt;/script&gt; State里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新。也就是说数据和视图是同步的。 局部状态 虽然说Vuex的Store仓库让我们统一管理数据变得更加方便，但是代码一多也会变得冗长和不直观。有些组件的数据是自己严格使用，我们可以将state放在组件自身，作为局部数据，专供此组件使用。比如现在只想在一个组件中使用emotion: happiness，那就不必要在store的state中进行定义了，只在本组件初始化就行了： 12345data () &#123; return &#123; emotion: 'happiness' &#125;&#125; 获取状态 在Vue组件中获取store中的数据（状态），最直接的就是通过计算属性获取。因为在上面我将store注册到根组件上了，所以在这里直接通过this.$store就可以调用了。比如我获取状态（state）中的count: 100 : 12345computed: &#123; count: function ()&#123; return this.$store.state.count; &#125;&#125; mapState辅助函数 mapState辅助函数把全局的State映射到当前组件computed计算属性中，即是帮助我们生成计算属性。简化我们的代码操作，不需要使用this.$store.state获取了。以上面状态（state）中的count: 100为例子 : 1234567import &#123; mapState &#125; from 'vuex' // 注意别漏了引入export default &#123; computed: mapState(&#123; count: state =&gt; state.count &#125;),&#125; Getter上面的state中我们了解到，在store仓库里，state是用来存储数据的。在多个组件中要进行使用同一种状态的话，对数据进行简单操作，我们可以通过在组件的computed中进行获取this.$store.state.theDataName。简单操作没问题，但是，我们进行其他的操作，比如过滤操作，我们就得写一堆的代码 : 1234567computed: &#123; filterData: function () &#123; this.$store.state.theDataName.filter(function(item)&#123; // do something ... &#125;) &#125;&#125; 然后在每个组件中复制这一大堆的代码，或者你单独新建一个文件把代码写进入，每个组件都引入（如果你不觉得很麻烦的话）。 而Getter可以把组件中共享状态抽取出来，这也是Getter存在的意义。我们可以认为，Getter是Store的计算属性。 如何使用Getter 为了方便管理，需要一个单独的getters.js的文件，假如已经有对数据进行过滤的函数了: 12345export default &#123; filterDatas (state,getter,rootState) &#123; // do something ... &#125;&#125; 那么只要在相关的组件的computed中引入就可以了，是不是很方便啊 ： 12345computed: &#123; filterItems: function () &#123; return this.$store.getters.filterDatas; &#125;&#125; mapGetters辅助函数 mapGetters辅助函数仅仅是将store中的getter映射到局部计算属性，看情况使用，类似mapState。下面使用mapGetter改写上面的filterItems ： 1234567import &#123; mapGetters &#125; from 'vuex' // 记得引入export default &#123; computed: mapGetters(&#123; filterItems: 'filterDatas' &#125;)&#125; MutationVuex的中文官网中明确指出更改Vuex的store中的状态（state）的唯一的方法是提交mutation。 Mutation可以理解为：在Mutation里面装着一些改变数据方法的集合。即把处理数据逻辑方法全部放在Mutation里面，使得数据和视图分离。 使用Mutation Mutation的结构：每个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)也可以理解为{type:handler()}，这和订阅发布有点类似。先是注册事件，当触发响应类型的时候调用handle()，调用type的时候需要用到store.commit(&#39;typeName&#39;)方法。比如我想在要触发mutations.js中的INCREASE处理函数: 1234567// mutations.jsconst INCREASE = 'INCREASE'; // 不能漏export default &#123; [INCREASE](state,data)&#123; // change the state ... &#125;&#125; 因为我注册了store到根组件，那么在.vue组件中就可以通过this.$store.commit(&#39;INCREASE&#39;)触发这个改变相关状态的处理函数了。如果在actions.js中调用，直接使用提供的commit参数进行commit(&#39;INCREASE&#39;)触发处理函数。 提交载荷（Payload） 可以向store.commit传入额外的参数，参数一般为object类型。我这里接着上面的示例，组件触发的时候传入一个100的数字到data里面 ： 12345methods:&#123; increase: function ()&#123; this.$store.commit('INCREASE',100); &#125;&#125; 使用mutation-types.js 使用mutation-types.js(名称可根据爱好随便取)是为了方便管理项目mutation的类型。我在知乎上也回答过为什么要使用mutation-types.js，当然你完全没必要使用它，不过我自己喜欢使用它。将使用mutation内容中的mutations.js代码拆分为两部分，一部分是mutation-types.js，另一部分是mutations.js，示范如下 ： 12345678910// mutation-types.jsexport const INCREASE = 'INCREASE';// mutations.jsimport &#123;INCREASE&#125; from '/path/to/mutation-type.js'export default &#123; [INCREASE](state,data)&#123; // change the state ... &#125;&#125; mapMutations辅助函数 为了简化你的代码量，使得代码看起来逼格更高点，你可以使用mapMutations辅助函数将组件中的methods映射为store.commit调用(需要在根节点注入store哦)。demo来映射上面的increase ： 12345678import &#123;mapMutations&#125; from 'vuex' // 不能漏哦export default &#123; methods: &#123; ...mapMutations([ 'INCREASE' ]) &#125;&#125; ActionAction 类似于 Mutation，不同点是 ： Action提交的是 mutation，而不是直接变更状态 Action是异步的，而Mutation是同步的 详细的相似点可以回滚看Mutation的啦，或者直接戳vue官网Store 组件内分发Action 因为我在全局组件中挂载了store，所以引用就可以这样写 -&gt; this.$store.dispatch(&#39;dispatchEvent&#39;)，当然你可以传参过去啦。比如：this.$store.dispatch(&#39;dispatchEvent&#39;,param)，param一般是obj类型的。 mapActions辅助 为了简化操作，Action像Mutaion一样有一个映射的函数mapActions。使用方法也类似Mutation，demo如下 ： 123456789101112import &#123;mapActions&#125; from 'vuex' // 不能漏哦export default &#123; methods: &#123; ...mapActions([ 'INCREASE' ]) 或 ...mapActions([ increase: 'INCREASE' ]) &#125;&#125; Module由于vue中使用单一的状态树，当管理的项目中大型的时候，所有的状态都集中在一个对象中会变得比较复杂，难以管理，显得项目比较臃肿。为了解决这些问题，我们可以使用vuex提供的Module功能，将store分割成模块。每个模块都有自己的state、mutation、action、getter。现在假设你的应用的功能包括登录和音乐两个功能模块页面，那么store的结构可以这样写： 12345678910111213141516171819- module - music actions.js getters.js index.js // music module 的入口文件 mutations.js state.js - user actions.js getters.js index.js // user module的入口文件 mutations.js state.jsactions.jsindex.js // store 的入口文件mutation-types.js // 管理所有的mutationsmutations.jsstate.js 模块的局部状态 对于模块内部的mutation，接收的第一个参数是state，也就是接收本模块的局部状态，比如上面的music模块，我在其state.js中写上 : 123456export default &#123; music: &#123; list: [], total: 100 &#125;&#125; 我在同级的mutations.js中有 ： 1234567import * as types from '../../mutation-types'export default &#123; [types.UPDATE_MUSIC](state,data)&#123; console.log(state.music.total); // 打印出100 ...other handle &#125;&#125; 命名空间 默认情况下，模块内部的action、mutation 和 getter是注册在全局命名空间的 -&gt; 这样使得多个模块能够对mutation和action作出响应。 如果看者希望你写的模块具有更高的封装度和复用性，你可以通过添加namespaced:true的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。比如上面的music模块 : 12345678910111213import state from './state' //stateimport getters from './getters' //gettersimport * as actions from './actions' //actionsimport mutations from './mutations' //mutations//modulesexport default &#123; namespaced: true, // 添加命名空间 state, getters, actions, mutations&#125; 详细的情况请戳vuex官网modules store结构vuex的官网谈项目结构，我这里谈store结构，因为我觉得每个人的项目的结构布局有所不同，但是vuex可以是一个模版化的使用。当然，这模版化的使用遵循了官网所定的规则： 应用层级的状态应该集中在单个 store对象中 提交mutation是更改状态（state）的唯一方法，并且这个过程是同步的 异步逻辑都应该封装到action里面 整理的store结构如下： 123456789101112131415161718.├── ...│└── store ├── actions.js // 根级别的 action ├── index.js // 我们组装模块并导出 store 的地方 ├── mutation-types.js // store所有mutations管理 ├── mutations.js // 根级别的 mutation ├── state.js // 根级别的 state └── modules ├── moduleA ├── moduleB └── moduleC ├── actions.js // moduleC 的 action ├── getters.js // moduleC 的 getter ├── index.js // moduleC 的 入口 ├── mutations.js // moduleC 的 mutation └── state.js // moduleC 的 state 上面的结构比较通用，模版化，我在接下来的完整小项目中就是使用上面的store结构来管理啦 😝 完整小项目自己在上面讲了一大推的废话，嗯哈，为了证明那不是废话，下面就结合上面讲的知识点来一个综合的min-demo吧，欢迎指正啊！ @~@ 是什么项目呢思来想去，自己还是觉得做一个简单版本的todo项目好点，理由如下： 个人时间精力邮箱(main reason) todo项目 -&gt; 麻雀虽小，五脏俱全 项目包含一个简单的登录页面，然后跳转到todo小项目的页面。如图所示： 在登录页面，会要求你填写非空的内容进入，我这里填了自己的名字啦。在todo页面，你就需要在输入框输入你要做的事情啦，事情的添加默认是未做的状态。当然，允许进行时间的状态进行设置和事件的删除啦。成品可查看下面最终的效果gif动效，就酱 @～@ 项目的初始化⚠️ 本项目在mac系统上使用vue-cli的基础上搭建(搭建日期2018.01.14)的小项目，其完整的覆盖了vue的全家桶了 -&gt; 使用的vue版本是^2.5.2，vuex的版本是^3.0.1，vue-router的版本也是^3.0.1。如果你使用低版本，请参考低版本的相关说明。 123456789101112131415161718192021222324252627# 全局安装 vue-cli$ npm install --global vue-cli# 进入桌面$ cd desktop# 初始化项目min-demo$ vue init webpack min-demo? Project name min-demo # 项目名称? Project description A Vue.js project # 项目描述? Author reng99 # 项目作者? Vue build standalone? Install vue-router? Yes # 是否使用路由? Use ESLint to lint your code? No # 是否启动语法检查? Set up unit tests No # 是否配置单元测试? Setup e2e tests with Nightwatch? No # 是否配置集成测试? Should we run `npm install` for you after the project has been created? (recommended) npm # 选择那种包管理工具进行安装依赖，共三种选择：npm,yarn,no thanks 我选择了npm vue-cli · Generated "min-demo".# 等待安装依赖的完成...# 进入项目$ cd min-demo# 启动项目$ npm run dev# 如果一切正常，就会在浏览器的http://localhost:8080的地址页面有相关的vue界面展示出来 当然，使用脚手架搭建的项目，没有自动集成vuex，这就需要你进入项目的根目录，执行npm install vuex --save命令来安装啦。 项目的实现嗯嗯，下面我将改写在vue-cli搭建的项目，以符合我自己期望。改写的代码就不全给出来了啊，关键的项目代码还是会贴一下的。😝 这个项目的结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940.├── build/ #webpack 的配置项│ └── ...├── config/│ ├── index.js # 项目的主要配置│ └── ...├── node_modules/ # 相关依赖│ └── ...├── src/│ ├── main.js # 应用的主入口│ ├── App.vue # 引用的根组件│ ├── components/ │ │ ├── Login.vue # 登录组件│ │ └── Todo.vue # todo组件│ ├── store/ │ │ ├── modules/ # todo组件│ │ │ └── todo│ │ │ ├── actions.js # todo的actions│ │ │ ├── getters.js # todo的getters│ │ │ ├── index.js # todo的入口│ │ │ ├── mutations.js # todo的mutations│ │ │ └── state.js # todo的状态│ │ ├── actions.js # 根actions│ │ ├── index.js # store入口文件│ │ ├── mutation-types.js # 整个store中的mutation的管理│ │ ├── mutations.js # 根mutations│ │ └── state.js # 根的状态│ ├── router/ │ │ └── index.js # 路由文件│ └── assets/ # 模块的资源│ └── ...├── static/ # 静态资源存放的地方│ └── ...├── .babelrc # 语法转换babel的相关配置├── .editorconfig # 编辑器IDE的相关配置├── .gitignore # 提交到github忽略的内容配置├── .postcssrc.js # css的处理配置postcssrc├── index.html # index html模版├── package.json # 相关的执行命令和依赖配置└── README.md # 项目的说明文件 ⚠️ 项目重点在src文件夹内 在/src/components/Login.vue中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;template&gt; &lt;div id="login"&gt; &lt;div class='login'&gt; &lt;div class='login-title'&gt;简单模拟登录&lt;/div&gt; &lt;div class='login-body'&gt; &lt;div class='hint' v-show='hintFlag'&gt;输入的文字不能为空&lt;/div&gt; &lt;input placeholder='请输入任意文字...' type='text' v-model='loginTxt'/&gt; &lt;div class="btn" @click='login'&gt;登录&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Login', data () &#123; return &#123; hintFlag: false, loginTxt: '' &#125; &#125;, methods: &#123; login () &#123; var vm = this; if(vm.loginTxt.trim()=='')&#123; vm.hintFlag = true; &#125;else&#123; // 进入todo的页面 vm.hintFlag = false; // 触发获取登录名 vm.$store.dispatch('createUsername',vm.loginTxt); vm.$router.push('/todo'); &#125; &#125; &#125;, watch:&#123; loginTxt(curVal)&#123; var vm = this; if(curVal.trim()=='')&#123; vm.hintFlag = true; &#125;else&#123; vm.hintFlag = false; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped lang='less'&gt; #login&#123; margin-top: 100px; .login&#123; width: 400px; margin: 0 auto; &amp;-title&#123; color: #999; font-size: 22px; text-align: center; margin-bottom: 20px; &#125; &amp;-body&#123; width: 360px; padding: 40px 20px 60px 20px; background: #ededed; input&#123; width: 100%; display: block; height: 40px; text-indent: 10px; &#125; .btn&#123; width: 100%; text-align: center; height: 40px; line-height: 40px; background: #09c7d1; color: #fff; margin-top: 20px; cursor: pointer; &#125; .hint&#123; color: red; font-size: 12px; text-align: center; padding-bottom: 10px; &#125; &#125; &#125; &#125;&lt;/style&gt; 在上面的组件中，自己原封不动的将里面的代码复制过来了，你应该可以看出，这个.vue文件中结合了三块的东西，分别是html的模版、javascript代码和运用less预处理器编写的css代码。 在/src/components/Todo.vue组件的结构依旧是这样: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div id="todo"&gt; &lt;div class='username'&gt;欢迎您！&lt;span&gt;&#123;&#123;username&#125;&#125;&lt;/span&gt;&lt;/div&gt; &lt;div class="main"&gt; &lt;div class="input"&gt; &lt;input placeholder='请输入要做的事情...' type='text' v-model='eventTxt'/&gt; &lt;button @click="addEvent"&gt;增加&lt;/button&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'ToDo', data () &#123; return &#123; noDataFlag: true, ... &#125; &#125;, created()&#123; var vm = this; if(vm.username == '')&#123; vm.$router.push('/'); &#125; &#125;, computed: &#123; username()&#123; return this.$store.getters.username; &#125;, ... &#125;, methods: &#123; delEvent (id) &#123; this.$store.dispatch('delEvent',id); &#125;, ... &#125;, watch:&#123; ... &#125;&#125;&lt;/script&gt;&lt;style scoped lang='less'&gt; #todo&#123; margin-top: 100px; ... &#125;&lt;/style&gt; 在路由的文件中，因为知识涉及了两个页面的路由跳转，这里也全贴出来吧 – 123456789101112131415161718192021import Vue from 'vue'import Router from 'vue-router'import Login from '@/components/Login'import ToDo from '@/components/ToDo'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'Login', component: Login &#125;, &#123; path: '/todo', name: 'ToDo', component: ToDo &#125; ]&#125;) 关于store，这是一个重点，我打算详细说啦。首先当然得从整个store的入口文件讲起啦。在store/index.js中，我是这样引用的 ： 1234567891011121314151617181920import Vue from 'vue' // 引入vue依赖import Vuex from 'Vuex' // 引入vuex依赖import state from './state' // 引入根状态import * as actions from './actions' // 引入根actionsimport mutations from './mutations' // 引入根mutationsimport todo from './modules/todo/index' // 引入todo模块Vue.use(Vuex) // 引入vuex// 初始化storeexport default new Vuex.Store(&#123; state, actions, mutations, modules:&#123; todo &#125;&#125;) 在根的store的mutation-types.js文件中，管理着整个项目的状态管理函数 –&gt; 包括创建用户名、添加要做的事情、删除创建的事情、显示事件的状态(全部，已经做，没有做)和标记事件(已经做的事件标记为未做，未做的事件标记为已经做)。代码展示如下 ： 12345678export const CREATE_USERNAME = 'CREATE_USERNAME' // 创建用户名export const ADD_EVENT = 'ADD_EVENT' // 添加事件export const DEL_EVENT = 'DEL_EVENT' // 删除事件export const ALL_EVENT = 'ALL_EVENT' // 全部事件export const UNDO_EVENT = 'UNDO_EVENT' // 没做事件export const DONE_EVENT = 'DONE_EVENT' // 已做事件export const MARK_UNDONE = 'MARK_UNDONE' // 标记为未做export const MARK_DONE = 'MARK_DONE' // 标记为已做 store/state.js的作用在你听完store/todo/state.js的讲解后你应该会明白。在模块todo的state中，自己定义了此模块的相关的数据结构，如下： 1234567891011121314export default &#123; // 事件列表 list:[ // &#123; // id: 0, 相关的id // content:'', // 事件的内容 // flag: 1 // 是否完成,1是完成，0是未完成 // &#125; ], allList:[], increase: 0, total: 0, done: 0&#125; 定义的这些数据结构，你可以说是状态吧，是为了给mutation和getters进行操作。对了，你也许注意到了store根目录中没有getters.js文件。因为，这是分散模块管理项目，为什么还需要呢，如果你想保留，你可以自己新建一个，按照自己的习惯进行管理项目呗。 上个段落以及前面某部分内容已经谈及了mutations的作用，本项目中使用mutation就是为了改变自己在todo/state.js定义的状态，比如改变allList:[]： 12345678910111213141516import * as types from '../../mutation-types'export default &#123; // 添加事件 [types.ADD_EVENT] (state,data)&#123; var obj = &#123; id: state.increase++, content: data, flag: 0 &#125; state.allList.push(obj); state.list = state.allList; state.total = state.allList.length; &#125;, ...&#125; 而todo/getter.js就是为了将vuex中的状态获取，方便显示在页面的啦，在本项目中，自己超级简单的使用了下： 123456789export default &#123; list (state,getters,rootState) &#123; return state.list; &#125;, username (state,getters,rootState) &#123; return rootState.username; &#125;, ...&#125; 最后一个是关于todo/actions.js，这是页面中的用户的事件去发送事件，使得产生mutations去改变状态(state.js)，最终使得页面展示的内容(getters)发生改变。这里以一个派遣添加事件为例子 : 12345import * as types from '../../mutation-types'export const addEvent = (&#123;commit,state,rootState&#125;,query) =&gt; &#123; commit(types.ADD_EVENT,query);&#125; 嗯，整篇文章都说整个store是挂载在根组件上的，那么是在哪里呢？答案就是src/main.js文件啦，文件内的代码如下 : 123456789101112131415import Vue from 'vue'import App from './App'import router from './router'import store from './store'Vue.config.productionTip = falsenew Vue(&#123; el: '#app', router, store, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 最终的效果好吧，自己利用了一个下午搭建项目并简单思考了相关的逻辑，简单实现项目，其最终的效果如下gif动图啦 : 嗯，项目是不是很简单，所以就不放源码上去了 😂 。其实自己觉得源码实现不够严谨啦，毕竟只是花了短短一个下午和晚上从设计到实现… 逃：） 参考内容vuex官网 （ 完 @~@ ）]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二届前端体验大会 -- 本固枝荣]]></title>
    <url>%2F2017%2F12%2F24%2F2ndTencent-frontend-meeting%2F</url>
    <content type="text"><![CDATA[第二届前端体验大会，是至今为止，我参加的最棒的一次前端体验大会，不枉我从广州过去深圳啊。目前只参加过一次大型的前端体验大会 😝。在一天的时间里面，自己收获到了很多的东西。作为一个非典型的程序员，杂七杂八的就不谈了，还是谈技术来得简单粗暴一点。 开场白本会议的主题是本固枝荣，开场白的彪叔已经很好的解释了主题：基础牢固，才能更好的玩转前端（概括起来就这样吧）。在开场白的时候，彪叔介绍的前端的前三年的调查报告，着实让我一惊 -&gt; 原来前端的市场是酱紫啊，作为一个涉水不深的前端菜鸡来说，还是可以定m个小目标的。 一个UI的自我修养腾讯的QQ音乐的设计天团研发经理主要是针对一个UI开发的自我修养来讲述了前端开发人员需要有发现问题，定位问题，解决问题的能力（概括不到位的话，大佬不要怂我 😂 ）。 感知性能优化在众多嘉宾分享的话题中，我最喜欢的就是潇滨前辈讲解的感知性能优化的话题。在前端开发中，我们需要对自己做出来的产品进行优化，怎么进行优化呢，前辈经过三个层次进行说明：资源感知，代码感知和用户感知。这里也推荐雅虎的七个领域的35条优化原则，请戳传送门资源感知我们写的页面的img,js,html,css等都可以成为资源，我们在优化的时候，需要考虑到控制请求，控制资源的大小，控制缓存等。 感知代码在代码的层面，我们可以通过对请求加载数进行延迟或者按需加载来控制代码。一个产品的首页首次渲染很是重要，在代码层面对样式的前置，js后置等进行优化。 用户感知用户在产品中起到至关重要的作用，也许你的产品在电脑的模拟器上没有什么问题。但是是真的没有问题吗？这就需要站到用户的角度进行思考，如果用户的使用的网络是3g的怎么样等等。 整个感知优化的流程，可以用大佬ppt里面的图片进行总结，如下: 那些年我们所遗忘的XSS黑魔法至于前端方面的安全，志龙前辈演示了xss的黑魔法，自己一脸懵逼，因为接触前端安全这一块一直是个梗。在xss黑魔法中，哪里有用户输入，哪里就可能有前端的安全漏洞，当然，前辈不仅演示了如何攻击，还演示了如何防攻啦。自己很想加入他们的团队，貌似能力不足啊… 前端监控系统监控系统是幸福生活的保障。一个产品的异常都需要进行监控，这些就是问题的来源。监控系统对异常进行监控，进行错误信息自动上报，性能数据自动上报，进行数据的打点，最终显示出系列告警的错误日志数据。郑超前辈指出人是监控系统的关键组成部分。 跨界-成长：非典型程序员之路某磊前辈作为全场嘉宾中唯一一个文科生（自己猜的）出身的程序猿。在会场上分享了自己如何在钱途[逃：)]和热情的支撑下成为前端大神的经历。很喜欢他会场的一句话：你生命中的每个点（经历的事），在你生命的某一个时刻终将连成线。 作为一个非典型的程序猿，你的世界不应该只有代码和办公室，你应该到处走走。美妙的代码只是你生命中的一部分，生命中其他美妙的部分等待着你去发现、挖掘。嗯，我也是一个非典型的程序猿，打代码仅仅是人生乐趣的一部分。 😊 高性能React替代方案现在前端比较热门的框架有三个，分别是react、vue和angular。京东的某澈前辈对三种框架进行了比较选择了react。然后基于他们京东的产品和业务，对react进行了改写，支持IE8版本等，他们改写react的github仓库请戳传送门。 每个公司的情况不同，我们的大佬就选择了vue。经过一年的vue的锻炼，自己貌似已经把react知识点忘记了。但愿react别来个变脸 -&gt; 改协议了… 如何开发知晓榜工具类第一的小程序最后一位分享嘉宾是某博前辈讲的微信小程序。因为自己没开发过微信小程序，听不懂他在讲啥（我的锅），全程感觉就是围绕websocket和使用场景规模来讲。 如果需要学习微信小程序的时候只能靠后期了，也许找的资源比他讲解的还好(幻想中…) 结语会议的结尾，本会议的负责任某帅讲了自己的进入腾讯的幸酸的经历。嗯，是半开玩笑的那种。然后就是很形式的会议的闭幕的发言啦，感觉可以忽略。如果让自己用一个字还总结这次会议的话，那就是棒；两个字的话，那就是很棒；三个字的话，那就是非常棒。感谢主办方的精彩呈现 👏 其他作为一个非典型的程序猿，好吧，我说下参加本次会议的其他点吧： 嗯，主持人很会带气氛的说，特别是男的主持人(会场一对主持人，男帅女靓)，怂一下主持人 -&gt; 会场总说自己穷，穷的人在这里还没说话呢 😢 腾讯的工作环境真是超级棒的，能在这里工作是多么的幸福呢，希望自己有机会进入腾讯工作吧 腾讯的饭堂很赞，举办方免费开了会议还提供免费的午餐，真是有心了 会议的抽奖礼品很实在哦，大奖是服务器的优惠卷（价值9000）。好吧，我也很幸运，中了幸运奖–貌似是布娃娃吧，会后忘记自己还中奖来着，直接离场忘拿了 声明 本文的截图来自嘉宾的演讲稿 本文内容仅代表自己参加本固枝荣会议的观点，不喜勿喷 文中使用了嘉宾的名字，如果某嘉宾觉得本人使用不妥，可以文末留言，我将打码 😝 一张会议的合影图结束本文（原图太大，放上压缩后的图片，原图可以私信我，我还保留的话就发你了）]]></content>
      <categories>
        <category>技术交流</category>
      </categories>
      <tags>
        <tag>会议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的学习汇总]]></title>
    <url>%2F2017%2F12%2F13%2Fgit-learning%2F</url>
    <content type="text"><![CDATA[这篇博文是自己在学习git过程中的思考总结。本文仅仅代表个人的看法，如有不妥地方还请本文文末留言。 😊 GIT是什么GIT是一个免费并且开源的分布式版本控制系统，能够高速有效的处理或小或大的项目。(以上的话是自己翻译github官网) 至今，自己用过了window系统的TortoiseSVN, mac系统的CornerStone,最近的大半年也在用GIT(主要管理自己的github项目)。比较下来，还是GIT优势比较明显，虽然目前为止没有用GIT开发过团队项目。 GIT跨平台 GIT可以在不同的操作系统中使用。也许你注意到了，我在window上和mac系统上工作的时候是使用两个不同的svn。如果我在linux上工作会不会又是一个呢。 GIT是分布式版本控制系统,而svn是集中式版本控制系统 集中式版本控制系统是集中放在中央服务器上面的，而团队的人需要从中央服务器上面拉取最新的代码，然后进行开发，最后推送到中央服务器上面，就像串联的电路。而分布式版本控制系统没有中央服务器，团队的每个人的电脑就是一个完整的版本库，就好像并联的电路（自我理解）。 集中式版本控制系统必须联网才能工作，如果是在局域网内还好，带宽足够大，速度足够快，但是遇到网速慢的话，那心里就一万个羊驼🐑在蹦腾了。 集中式版本控制系统安全性比较低，如果中央系统崩溃了，那就有点悲催了。当然你不嫌麻烦，可以定期备份的啦。而分布式中央系统就比较安全，团队的每个成员的电脑就是一个完整的版本库。如果其中一个坏掉了，你可以从团队另外一个的人员电脑那里拷贝一份就行了。对了，GIT也会有一台中央的机子，主要是为了方便团队的交流，它是可以不存在的。 GIT安装GIT支持不同的系统，看者可以在链接https://git-scm.com/downloads中，找到和自己电脑系统匹配的GIT版本，下载安装包后根据提示进行安装。当然，GIT还提供图形界面管理工具，看者也可以在链接中下载GUI Clients，如下图所示–根据提示安装完成后，要验证是否安装成功。看者可打开命令行工具，输入git --version命令,如果安装成功，控制台输出安装的版本号（当然，安装前就应该输入git –version查看是否安装了git），我这里安装的GIT版本是2.10.0。 GIT配置GIT在使用前，需要进行相关的配置。每台计算机上面只需要配置一次，程序升级的时候会保留配置信息。当然，看者可以在任何时候再次通过运行命令行来修改它们。 用户信息设置GIT的用户名称和邮件地址，这个很重要，因为每个GIT的提交都会使用这些信息，并且它会写入到每一次的提交中。你可以在自己的仓库中使用git log，控制台上面显示的每次的提交都有Author字段，它的值就是用户名称 &lt;邮件地址&gt;。方便查看某次的提交的负责人是谁。 12$ git config --global user.name "你的用户名"$ git config --global user.email 你的邮箱地址 ⚠️ GIT一般和github配合使用，看者应该设置用户名称为你的github用户名。当然，还有和gitlab等配合使用… ⚠️ 如果配置中使用了--global选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，GIT都会使用这些信息。但是，当你想针对特定项目使用不同的用户名称与邮件地址的时候，可以在那个仓库目录下运行不使用global选项的命令来配置。 检查配置信息通过git config --list命令可以列出所有GIT能找到的配置。如下：（我的git版本为2.10.0） 12345678...user.name=reng99user.email=1837895991@qq.comcolor.ui=truecore.repositoryformatversion=0core.filemode=truecore.bare=false... 当然，你可以通过git config &lt;key&gt;来检查GIT的某一项配置。比如$ git config user.name。 帮助中心在使用GIT的时候，遇到问题寻求帮助的时候，可以运行git help或git --help或git命令来查看。在控制台上会展示相关的帮助啦。 123456789101112usage: ...start a working area (see also: git help tutorial) ...work on the current change (see also: git help everyday) ...examine the history and state (see alse: git help revisions) ...grow,mark and tweak your common history ...collaborate (see also: git help workflows) ... 更加详细的内容，请点击传送门 创建版本库版本库又名仓库(repository)，可以理解成一个目录，这个目录里面所有文件都可以被GIT管理起来，每个文件的修改、删除，GIT都能跟踪，以便任何时刻都能可以追踪历史，或者在将来某个时刻可以还原。 创建一个版本库，首先得选择一个存放目录的地方，我这里选择了桌面，并且创建一个空的目录。 12345$ cd desktop$ mkdir -p learngit$ cd learngit$ pwd/Users/reng/desktop/learngit mkdir -p dirnanme是创建一个子目录，这里的-p确保目录的名称存在，如果目录不存在的就新建一个，如果你确定目录不存在，直接使用mkdir dirname就可以了。pwd(Print Working Directory)是显示当前目录的整个路径名。 然后，通过命令行git init，将创建的目录变成GIT可以管理的仓库: 12$ git init Initialized empty Git repository in /Users/reng/Desktop/learngit/.git/ 初始化好仓库后就可以愉快的玩耍了，但是，得先来了解下GIT整个工作流程先。 GIT工作流程为了更好的学习，自己用Axure RP 8粗略的画了下流程图，如下– 本地仓库(repo)包含工作区和版本库,那么什么是工作区和版本库呢？基本的流程又是什么呢？ 工作区和版本库我们新建一个仓库，就像我们新建的learngit仓库，现在在里面添加一个文件README.md，用sublime打开learngit目录。此时会出现如下图的情况(当然你设置了其他东西例外)–如上图，出现的内容就是工作区（ 电脑上能看到的此目录下的内容），这里工作区只有README.md一个文件。工作区有一个隐藏的目录.git，这个不算工作区，而是GIT的版本库。版本库又包括暂存区和GIT仓库。暂存区是一个文件，保存了下次将提交的文件列表信息，而GIT仓库目录是GIT用来保存项目的元数据和对象数据库的地方。这是GIT中最重要的部分，从其他计算机克隆仓库的时候，拷贝的就是这里的数据。当执行git add .或者git add path/to/filename的时候，文件从工作区转到暂存区；执行git commit -m&quot;here is the message described the file you add&quot;的时候,文件从缓存区添加到GIT仓库。 基本的工作流基本的GIT工作流可以简单总结如下– 在工作区目录中修改文件 暂存区中暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到GIT仓库目录 时光机穿梭到目前为止，在自己创建的本地仓库–learngit中已经初具形态了。进入learngit，执行ls，可看到目前仓库中已有的文件README.md。 12345$ cd desktop/learngit$ lsREADME.md$ cat README.md## content 上面展示了本地learngit内的相关的内容。运行下git status查看现在的状态。 123$ git statusOn branch masternothing to commit, working tree clean 这时候会提示没有内容可以提交，工作区是干净的。因为我之前已经提交(git commit)过了。上面还提示了目前是位于主分支上面，GIT在初始化(git init)的时候会自动创建一个HEAD指针指向默认master分支，也只有一个分支，看者可以通过git branch查看。 现在，在README.md上添加一些内容。 123## content### first change 此刻再通过git status查看当前状态。 123456789$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a") 这时候显示出一堆的东西，告诉我们现在是位于主分支上面，然后告诉我们修改的文件啊，可以使用的命令进行下一步的操纵。那么我们来进行下一步的操作了，git add . 或者 git add README.md将修改的文件添加到暂存区域。 1234567$ git add .$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md 对了，有时候需要在添加的之前（执行git add . 或者 git add path/to/filename）的时候，需要看下修改了哪些内容可以执行下git diff。那么，现在先回退到修改的前一个版本。 12345678$ git reset HEAD README.mdUnstaged changes after reset:M README.md$ git checkout -- README.md$ lsREADME.md$ cat README.md## content 回退正确，现在像上次那样添加内容### first change，然后执行命令git diff来查看更改的内容。 123456789101112$ git diffdiff --git a/README.md b/README.mdindex 75759ec..0bc52b9 100644--- a/README.md+++ b/README.md@@ -1 +1,3 @@-## content\ No newline at end of file+## content++### first change\ No newline at end of file 现在就显示了修改前的内容–-前为修改前的内容，和修改后的内容–+前修改后的内容。查看完之后，觉得没有问题了，就可以进行添加(git add)，提交(git commit)。当然，一般不常用git diff的，因为自己修改的东西自己心里总有点数吧，可能合作中团队的其他人需要查看文件前后的不同点就需要用到git diff啦。 版本回退为了方便讲解下版本回退，我先将上面添加的### first change提交以下–git add . &amp;&amp; git commit -m &quot;add first change&quot;。下面通过git log就可以查看自己提交的记录了。 1234567891011121314151617181920212223$ git logcommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md $ git add . &amp;&amp; git commit -m "add first change"[master 0ac49ba] add first change 1 file changed, 3 insertions(+), 1 deletion(-) $ git logcommit 0ac49bae6ab55df9c05d0770de347665a2568f31Author: reng99 &lt;1837895991@qq.com&gt;Date: Mon Dec 18 15:26:06 2017 +0800 add first changecommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md 在上面中，自己先执行了git log来显示提交的日志，显示只有一条，然后执行了add和commit的命令，打印的内容是现实主分支、commit的id、commit的信息、多少个文件的更改、多少个插入以及多少个删除。之后再次执行git log打印日志，显示了两次提交。⚠️ 注意：当提交(commit)的次数较多之后，控制台会显示不下（最多现实4条）那么多的条数，可以通过按键盘的向上或向下键查看日志的内容，需要退出查看日志命令的话，在英文输入法的状态按下q，意思就是quit(退出)。 版本的回退就是改变HEAD指针的指向。通过git reset --hard HEAD^返回上一个版本，通过git reset --hard HEAD^^返回上上个版本…由此推论，往上100个版本的话就是100个^，当然，这样你数到明天也未必数得正确，所以写成git reset --hard HEAD~100。另外一种是，你知道提交的id，例如commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67的前7位就是commit的id(5c2639e)，执行git reset --hard 5c2639e就回到此版本啦。 123456789101112$ reng$ git reset --hard HEAD^HEAD is now at 5c2639e init README.md$ git logcommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md$ lsREADME.md$ cat README.md## content 现在你已经回到了最初的版本，这里演示的是通过HEAD，你也可以通过commit id来实现的。执行上面的代码后，README.md文件里面只有一### content文字内容,但是过了段时间后，你想恢复到原先的版本，通过git log命令行，控制台显示的以前的信息，通过它找不到回退前的commit id，怎么办？GIT提供一个git reflog显示提交的历史记录，在那里可以查看提交的id、HEAD的指针历史和操作的信息记录。下面演示回退到最新的版本（也就是commit -m “add first change”）– 123456789101112131415161718$ git logcommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md$ git reflog5c2639e HEAD@&#123;0&#125;: reset: moving to HEAD^0ac49ba HEAD@&#123;1&#125;: commit: add first change5c2639e HEAD@&#123;2&#125;: commit (initial): init README.md$ git reset --hard 0ac49baHEAD is now at 0ac49ba add first change$ lsREADME.md$ cat README.md## content### first 现在又回到了最新的版本，又能够愉快的玩耍了。😊 管理修改GIT比其他版本控制系统设计优秀，其中一点是–GIT跟踪并管理的是修改，而非文件。 下面在README.md内添加信息### second change。之后看下变化后的文件的状态和差异等。 123456789101112131415161718192021222324$ lsREADME.md$ cat README.md## content### first change#### second change$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")$ git add README.md$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md 此时，对README.md进行第三次的修改，添加内容### third change。 123456789101112131415161718192021222324252627282930313233$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.md$ cat README.md## content### first change#### second change### third change$ git commit -m "test file modify"[master 18f86ba] test file modify 1 file changed, 3 insertions(+), 1 deletion(-)$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a") 上面的演示流程是这样的第一次修改(#### second change) -&gt; git add -&gt; 第二次修改(### third change) -&gt; git commit。但是最后查看状态的时候(git status)，第二次的修改并没有被提交上去。因为GIT管理的是修改，当使用git add命令的时候，在工作区的第一次修改被放入暂存区，准备提交，但是在工作区的第二次修改并没有放入到暂存区，而git commit是将暂存区的修改提交到GIT仓库，所以第二次修改的内容是不会被提交的。这也是说明为什么可以多次添加(git add)，一次提交(git commit)的原因了。 撤销修改文件的撤销修改分成三种情况，一种是修改在工作区的内容，一种是修改在暂存区的内容，另一种是修改在GIT仓库的内容。也许会有看者说，不能修改在远程库中的内容吗？有啊，就是git add-&gt;git commit-&gt;git push将远程仓库的内容覆盖被，不过团队人在克隆远程库下来的时候，还是可以查看到你提交的错误内容的。我们现在只针对本地仓库的三种情况谈下自己的看法– 情况一：撤销工作区的内容 在管理修改中，自己的工作区还是没有提交，此时想放弃当前工作区的编辑内容执行git checkout -- file。接着上面的内容，我这里的工作区内有的内容是### third change，现在我要放弃第三次修改，只要执行git checkout -- README.md就可以了。 1234567891011121314151617181920212223242526272829$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")$ lsREADME.md$ cat README.md## content### first change#### second change### third change$ git checkout -- README.md$ cat README.md## content### first change#### second change$ git statusOn branch masternothing to commit, working tree clean 情况二：撤销暂存区的内容 当你不但改乱了工作区的某个文件的内容，还添加(git add)到了暂存区时，想丢弃修改，那么得分两步来撤销文件。先是通过git reset HEAD file，将暂存区的文件退回到工作区，然后通过git checkout -- file放弃修改改文件的内容。为了方便演示，我这里的暂存区没什么内容，所以添加内容### tentative content并将它添加到缓存区。之后，演示将缓存区的内容撤回– 1234567891011121314151617181920212223242526272829$ cat README.md## content### first change#### second change### tentative content$ git add .$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md$ git reset HEAD README.mdUnstaged changes after reset:M README.md$ git checkout -- README.md$ cat README.md## content### first change#### second change$ git statusOn branch masternothing to commit, working tree clean 情况三：撤销GIT仓库的内容 如果你不仅添加(git add)了内容到暂存区并且提交(git commit)了内容到GIT仓库中了。你需要撤销上一次的内容，也就是要回退到上一个版本，执行git reset --hard HEAD^就可以啦，详细的内容查看版本回退。如下– 123456789101112131415$ git statusOn branch masternothing to commit, working tree clean$ cat README.md## content### first change#### second change$ git reset --hard HEAD^HEAD is now at 0ac49ba add first change$ cat READMEmd## content### first change 远程仓库远程仓库的使用能够提高你和团队的工作效率，无论何时何地，团队的人员都可以在联网的情况下将代码进行拉取，修改和更新。因为我是使用github来管理项目的，所以我的远程仓库是放在github里面。这里默认看者已经安装了github，当然也可以用码云、gitlab等。 本地库添加到远程库这点很容易，登录自己注册的github，如果打不开，请开下VPN。进入自己的首页(https://github.com/username)，点击`+`号创建(new repository)一个名为learngit的仓库(注意哦⚠️ 名称是本地仓库已经初始化过的，我这里本地有个同名初始化的learngit仓库)，其他的字段自选来填写。点击Create repository创建此远程仓库。紧接着就是进行本地仓库和远程仓库的关联啦，github很友好的提示了你怎么进行一个远程仓库的关联。 现在按照上图来关联下远程仓库。 12345678910$ git remote add origin https://github.com/reng99/learngit.git$ git push -u origin masterCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (6/6), 456 bytes | 0 bytes/s, done.Total 6 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit.git * [new branch] master -&gt; masterBranch master set up to track remote branch master from origin. 注意⚠️ 第一次向远程仓库（关联）push的时候是$ git push -u origin master，不能忽略-u，以后的push不用带-u。至此，打开你的github的相关的仓库就可以看到添加了README.md文件，我这里地址是https://github.com/reng99/learngit，因为我是使用markdown语法写的，控制台显示的内容和仓库的显示内容有所区别啦。(⚠️ 后期我将learngit仓库删除啦，所以你访问链接是找不到这个仓库的，毕竟不想放一个没什么内容的仓库在我的github上)。 远程库克隆到本地从远程仓库克隆东西到本地同样很简单，只需要进入你想克隆的仓库，将仓库的url复制下来（当然你也可以复制window.location.href的内容），运行git clone address。现在我将本地桌面的learngit的仓库删除，然后从远程将learngit克隆到本地。 12345678910$ cd desktop$ rm -rf learngit$ find learngitfind: learngit: No such file or directory$ git clone https://github.com/reng99/learngitCloning into 'learngit'...remote: Counting objects: 6, done.remote: Compressing objects: 100% (2/2), done.remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0Unpacking objects: 100% (6/6), done. 成功将gitlearn从远程克隆下来，接下来又可以愉快的玩耍啦。 分支管理分支管理允许创建另一条线/方向上开发，能够让你在不影响他人工作的情况下，正常的工作。当在自己创建的分支中完成自己的功过后，合并到主分支就行了(git init初始化的时候已经默认创建了master主分支)。一般团队的合作是不在主分支上进行的，个人项目除外（个人理解）。 创建分支当前learngit仓库上只有一个分支，那就是master分支，看者可以通过git branch命令来查看当前的分支，git branch branchName命令来创建一个新的分支，我这里创建的是dev分支。 1234567$ cd desktop/learngit$ git branch* master$ git branch dev$ git branch dev* master 现在已经创建了dev分支，有两个分支了，分支前面带有一个星号的分支说明是当前的正在工作的分区。执行上面的分支后，可以简单的画下现在的情况了，有个HEAD指针指向主分支的最新点，刚才新创建的dev分支我这里默认是一个dev的指针指向了dev分支的最新点。 1234567.. HEAD指针. │├────────*master└────────dev │ dev指针 切换分支我们一般是很少在主分支进行工作的，所以在创建出新的分支之后，我们就切换到新的分支进行相关的工作。可以通过git checkout branchName切换到已经存在的分支工作，通过分支前面的*可查看目前位于哪个分支内。现在我切换到创建的dev分支。 12345678$ git branch dev* master$ git checkout devSwitched to branch 'dev'$ git branch* dev master 合并分支在创建好分支后，我们在新的分支上工作完成后，就需要往主分支上进行合并啦。我修改了分支dev上的README.md的内容，就是添加文字### new branch content。合并分支可以分成两个合并的方式，一种是本地合并到materz主分支之后，推送(push)到远程库，一种是直接将分支推送到远程库，在远程库进行合并。 本地合并推送 在合并分支前，需要切换到要合并到哪个分支(一般是master主分支)，通过git merge branchName将需要的合并的分支合并到当前分支，我是将dev分支合并到master分支。 123456789101112131415161718192021$ git branch* dev master$ git checkout masterM README.mdSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ git merge dev$ Already up-to-date.$ git add .$ git commit -m "merge dev branch"[master d705e73] merge dev branch 1 file changed, 3 insertions(+), 1 deletion(-)$ git push origin masterCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 282 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit 0ac49ba..d705e73 master -&gt; master 合并之后,此时，HEAD指针就指向了dev指针，也就是两者同时指向了master主分支的最新处。具体的内容参考传送门 1234567.. . ├────────*master└────────dev │ dev指针 ── HEAD指针 远程库推送合并 远程库内合并的话，要先将dev的分支推送到远程库，然后在远程库进行合并。我这里在dev分支上添加了### add new branch content into again然后demo演示推送(git push origin dev)以及合并。 1234567891011121314151617$ git branch dev* master$ git checkout devSwitched to branch 'dev'$ git add .$ git commit -m "add dev branch commit again"[dev dc817c4] add dev branch commit again 1 file changed, 3 insertions(+), 1 deletion(-)$ git push origin devCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 300 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit * [new branch] dev -&gt; dev 接下来就是进入我的远程learngit仓库进行合并，你会看到下面图示的提示。点击Compare &amp;&amp; pull request，然后写点相关的comment（选填），点击Create pull request。之后在绿色勾的提示下Merge pull request，紧接着点击Confirm merge按钮确定合并此分支，这时候返回主分支就可以看到dev内合并的内容了(后期我改动了dev的内容)。看者如果看得不明白，自己上手尝试一下呗！ 完成后，你会看到learngit仓库的Pull requests量为1，branches量为2。你可以点击进入分支，在ALL branches里面查看分支的具体内容。 删除分支在创建了分支，然后将分支的内容合并到主分支后，分支的使命就完成了，你就可以将分支删除了，这里的删除个人认为可以是两种，一种是本地仓库的分支删除，一种是远程仓库的分支的删除。当然啦，留着分支也没啥，可以留着呗，自己认为有点碍眼。 本地分支的删除 在本地的learngit的目录下，执行命令行git branch -D branchName就可以删除了。我这里删除的是dev分支。注意⚠️ ，删除的分支不应该是当前工作的分支，需要切换到其他分支，我这里切换的是master分支，毕竟我只有两个分支呢。 123456789101112131415$ git branch* dev master$ git branch -D deverror: Cannot delete branch 'dev' checked out at '/Users/reng/desktop/learngit'$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ git branch dev* master$ git branch -D devDeleted branch dev (was dc817c4).$ git branch* master 远程库分支的删除 删除远程库的分支，只要执行git push origin :branchName命令就行了。现在我要删除我远程库中的dev分支，执行git push origin :dev。 123$ git push origin :devTo https://github.com/reng99/learngit - [deleted] dev 此时，打开我的远程库learngit，发现之前的Pull requests量为0，branch量为1。 重命名分支通过git branch -m oldBranchName newBranchName来重命名分支。我这里没有分支了，现在创建一个reng分支，然后将它重命名为dev分支。 12345678910$ git branch* master$ git branch reng$ git branch* master reng$ git branch -m reng dev$ git branch dev* master 解决冲突在我们开发的时候，不知道分支和分支之间的进度情况是什么，难免会产生冲突。当产生冲突的时候，就得将冲突的内容更正，然后提交。为了方便演示，我将本地的learngit删除，重新拉取远程的gitlearn仓库(因为我不知道我之前在本地仓库做的修改是啥，对了，我将远程的分支删除了，只剩下master主分支)。克隆下来后，如果还存在本地分支，也将它删除，之后我将在master和dev分支中重新填充里面的README.md的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$ cd desktop$ git clone https://github.com/reng99/learngit.gitCloning into 'learngit'...remote: Counting objects: 43, done.remote: Compressing objects: 100% (17/17), done.remote: Total 43 (delta 4), reused 38 (delta 1), pack-reused 0Unpacking objects: 100% (43/43), done.$ cd learngit$ git branch* master$ lsREADME.md$ cat README.md## master branch content$ git add .$ git commit -m "add master branch content"[master 1cfa0aa] add master branch content 1 file changed, 1 insertion(+), 1 deletion(-)$ git push origin masterCounting objects: 3, done.Writing objects: 100% (3/3), 271 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit.git d2f936f..1cfa0aa master -&gt; master$ git branch dev$ git checkout devSwitched to branch 'dev'$ cat README.md## master branch content### dev branch content$ git add .$ git commit -m "add dev branch content"[dev 80faf6d] add dev branch content 1 file changed, 2 insertions(+)$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ cat README.md## master content### new master branch content$ git add .$ git commit -m "change master content"[master ec18715] change master content 1 file changed, 3 insertions(+), 1 deletion(-)$ git merge devAuto-merging README.mdCONFLICT (content): Merge conflict in README.mdAutomatic merge failed; fix conflicts and then commit the result. README.md文件中冲突内容– 123456789&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD (当前更改)## master content### new master branch content=======## master branch content### dev branch content&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev (传入更改) 手动修改了README.md文件中冲突的内容– 123## master branch content### new master branch content### dev branch content 然后命令行执行– 12345678910111213141516171819202122232425262728$ git add .$ git commit -m "fix confict content"[master dd848b4] fix confict content$ git log --graph* commit 980788b7690d8bcf14610072fc072460bee7e9f1|\ Merge: c49d09e 2929dca| | Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Thu Dec 21 11:14:10 2017 +0800| | | | fix confict content| | | * commit 2929dca91ef8f493adba7744cdad19656538334f| | Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Thu Dec 21 11:11:49 2017 +0800| | | | add dev branch content| | * | commit c49d09e33e7098d67b59c845d18e9c6f8a8f4fea|/ Author: reng99 &lt;1837895991@qq.com&gt;| Date: Thu Dec 21 11:12:50 2017 +0800| | change master content| * commit b07f0be8280e4e437cccf2a3f8fac6beef03ff41| Author: reng99 &lt;1837895991@qq.com&gt;| Date: Thu Dec 21 11:10:51 2017 +0800| : 上面操作过程是，我先从远程库中克隆learngit仓库到本地，目前的本地learngit的分支只有master分支，然后我在master分支的README.md中添加相关的文字(见代码)，接着把它推送到远程库。然后创建并切换dev分支，在README.md文件中添加新内容(见代码)，接着将它提交到GIT仓库。又切换到master分支，修改README.md到内容(见代码)，提交到GIT仓库后开始执行merge命令合并dev分支的内容。此时，产生了冲突，这就需要手动将冲突的内容解决，重新commit到GIT仓库，最后你就可以提交到远程库了(这步我没有演示，也就是git push origin master一行命令行的事情)。最后我还使用git log ----graph打印出整个分支合并图(从下往上看)，方便查看。⚠️ 此时退出git log --graph是书写英文状态按键盘的q键。 说这么多，目的只有一个 –&gt; 产生冲突后，需要手动调整😊 分支管理策略先放上一张分支管理策略图，然后再慢慢讲解相关的内容… 在分支管理中，我们不断的新建分支，开发，合并分支，删除分支的操作。这里需要注意合并分子的操作，之前我们进行分支的时候是直接将dev开发的分支使用git merge dev进行合并，这样有个缺点：我们看不出分支信息。因为在默认情况下，合并分支的时候，GIT是使用了Fast Foward的模式，在这种模式下，删除分支后，会丢掉分支的信息。下面我重新克隆下我远程learngit仓库，然后创建并更改dev分支的信息，使用默认的模式进行合并。 12345678910111213141516171819202122232425262728293031$ git branch* master$ git branch dev$ git checkout devSwitched to branch 'dev'$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content$ git add .$ git commit -m "add new dev contentt"[dev 750e1f1] add new dev content 1 file changed, 1 insertion(+)$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ git merge devUpdating 980788b..750e1f1Fast-forward README.md | 1 + 1 file changed, 1 insertion(+)$ git log --graph* commit 750e1f17854872eed4d6cff8315e404079ecb18f| Author: reng99 &lt;1837895991@qq.com&gt;| Date: Fri Dec 22 10:05:36 2017 +0800| | add new dev content| * commit 980788b7690d8bcf14610072fc072460bee7e9f1... 上面的合并就是将master分支上面的HEAD指向dev指针，如下： 123456789101112131415161718192021222324252627# 记录是从上往下- before merge master * (begin) | | * \ \ * | | * (end) dev - after merge master * (begin) | | * | | * | | * (end) 为了保留分支的情况，保证版本演进的清晰，我们就得使用普通模式合并，也就是在Fast Foward的模式基础上加上--no-ff参数，即git merge --no-ff branchName，不过我们一般加上你合并的相关信息，即git merge --no-ff -m &quot;your msg here&quot; banchName。现在更改dev分支的内容，再进行合并。 123456789101112131415161718192021222324252627282930313233343536$ git checkout devSwitched to branch 'dev'$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content### merge with no-ff$ git add .$ git commit -m "add no-ff mode content"[dev 80b628c] add no-ff mode content 1 file changed, 2 insertions(+), 1 deletion(-)$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 1 commit. (use "git push" to publish your local commits)$ git merge dev --no-ff -m "merge with no-ff" devMerge made by the 'recursive' strategy. README.md | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-)$ git log --graph* commit 98746d93a9b64ea02b8ff1c7f0fa5e915405c0e6|\ Merge: 750e1f1 80b628c| | Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Fri Dec 22 14:39:32 2017 +0800| | | | merge with no-ff| | | * commit 80b628c334618711b77da81fa805ffc246a2cf7d|/ Author: reng99 &lt;1837895991@qq.com&gt;| Date: Fri Dec 22 14:38:17 2017 +0800| | add no-ff mode content| * commit 750e1f17854872eed4d6cff8315e404079ecb18f... 使用--no-ff参数的普通模式合并，会执行正常合并，在master主分支上面会生成一个新的节点，如下（我上面的分支管理策略图里面的合并就是使用了普通的模式）： 12345678910111213141516# 记录是从上往下- --no-ff合并 master * (before) | | * |\ | \ | *dev | | | | | * | / |/ * (after) 我们在开发中，分支管理可以分成master主分支、dev开发分支、feature功能分支、release预发布分支、hotfixes修补bug分支。其中功能分支、预发布分支和修补bug分支可以归为临时分支。临时分支在进行分支的合并之后就可以被删除了。下面就一一讲解自己眼中的各种分支。 主分支master主分支是在你初始化仓库的时候(git init)，自动生成的一个master分支，删除不了的哦（演示待会给）。主分支是有且仅有一个，也是发布上线的分支，团队合作的最终代码都会在master主分支上面体现出来。也许你也注意到了分支管理策略图里面的主分支会被打上TAG的标签，这是为了方便到某个时间段对版本的查找，标签tag的学习总结后面给出。 1234567891011# 记录是从上往下 master | | *(tag 1.0) | | *(tag 1.1) | | *(tag 1.2) 下面代码演示下不能放删除master的情况: 123456$ cd learngit$ git branch dev* master$ git branch -D mastererror: Cannot delete branch 'master' checked out at '/Users/reng/desktop/learngit' 开发分支develop在开发的过程中，项目合作者应该保持自己本地有一个开发环境的分支，在进行分支开发之前，需要进行git pull拉取master主分支的最新内容，或者通过其他的方法。在获取到最新的内容之后才可以进行本地的新功能的开发。在开发完成后将内容merge到主分支之后，不用将dev分支删除，因为你开发的就是在这里进行，何必删除后再新建一个开发环境的分支呢。 接着上面的情况，我目前已经拥有了dev开发分支: 1234$ cd learngit$ git branch dev* master 功能（特性）分支feature一个软件就是一个个功能叠加起来的，在软件的开发中，我们总不能在主分支开发，将主分支搞乱吧。当然，你可以在dev分支中开发，一般新建功能分支来开发，然后功能开发完再合并到dev分支，之后删除功能分支。需要的时候就可以将dev开发分支合并到master主分支，这样就随时保证dev分支功能的完整性。 下面演示功能分支user开发（随便写点内容）的合并（这里也演示了合并到master主分支，跳过了release分支的测试），删除。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364$ git checkout devSwitched to branch 'dev'$ git branch user$ git branch* dev master user$ git checkout userSwitched to branch 'user'$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content### merge with no-ff### function user$ git add .$ git commit -m "function user was acheive"[user 26beda3] function user was acheive 1 file changed, 2 insertions(+), 1 deletion(-)$ git checkout devSwitched to branch 'dev'$ git merge --no-ff -m "merge user feature" userMerge made by the 'recursive' strategy. README.md | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-)$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 3 commits. (use "git push" to publish your local commits)$ git merge --no-ff -m "merge dev branch" devMerge made by the 'recursive' strategy. README.md | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-)$ git log --graph* commit f15a1e9012635fc21e944ab76c4cd4bbd539f82f|\ Merge: 98746d9 0ca83c6| | Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Fri Dec 22 16:35:43 2017 +0800| | | | merge dev branch| | | * commit 0ca83c654df64724743a966f5f0989477e504cbc| |\ Merge: 80b628c 26beda3| | | Author: reng99 &lt;1837895991@qq.com&gt;| | | Date: Fri Dec 22 16:33:27 2017 +0800| | | | | | merge user feature| | | | | * commit 26beda3b8246e047f10ac0461ca11d1a6f132819| |/ Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Fri Dec 22 16:31:41 2017 +0800| | | | function user was acheive| | * | commit 98746d93a9b64ea02b8ff1c7f0fa5e915405c0e6|\ \ Merge: 750e1f1 80b628c| |/ Author: reng99 &lt;1837895991@qq.com&gt;:$ git branch -D userDeleted branch user (was 26beda3).$ git branch dev* master 预发布分支release在进行一系列的功能的开发和合并后，在满足迭代目标的时候，就可以打包送测了。这里就需要一个预发布分支release。预发布分支是指在发布正式版本之前（ 即合并到master分支之前，可查看上面分支管理策略图），需要一个有预发布的版本（可以理解为灰度环境）进行测试。 预发布环境是从dev分支上面分出来的，预发布结束之后，必须合并到dev和master分支上面。这里我就不演示了，跟功能分支差不多，就是合并的时候要合并到dev和master上，这时候dev分支和master的同步的代码，就不需要将dev分支合并到master了。最后将预发布分支删除掉。 修复bug分支 bug/hotfixes在写代码的过程中，由于种种原因 -&gt; 比如功能考虑不周全，版本上线时间有限，产品突然改需求等，我们写的代码就出现一些或大或小的bug或者需要紧急修复。那么我们就可以使用bug分支（其实就是新建一个分支处理bug而已啦，命名随意起的），然后在这个分支上处理编码出现的问题。我在分支管理策略图上面已经展示了一种出现bug的情况 -&gt; 就是在测试发布版本看似没问题的情况下，将release版本整合到master和dev中，这时候火眼精金发现了遗留的一个bug，然后新建一个bug分支处理，再合并到master和dev中，之后将bug分支移除啦。 在开发的过程中，无论咋样都是这样 : 新建bug分支 -&gt; 把分支合并 -&gt; 删除分支，这里的demo就不演示了，可以参考上面的功能（特性）分支feature。 这里需要注意⚠️的一点，当在开发的过程中，开发到一定的程度，需要停下来需改紧急的bug，那么需要停下手头的工作需改bug啦。这时候需要将工作现场储藏(stash功能 git stash)起来，等以后回复现场了后接着工作(git stash pop)。现在我在原先的gitlearn仓库中README.md文件文末添加### modify content内容来进行演示。 1234567891011121314151617181920212223$ cd desktop$ cd learngit$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content### merge with no-ff$ git statusOn branch devChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")$ git stashSaved working directory and index state WIP on dev: 80b628c add no-ff mode contentHEAD is now at 80b628c add no-ff mode content$ git statusOn branch devnothing to commit, working tree clean 然后过段时间(这里省略修改的演示)，代码已经修改好合并后，需要回到最新的内容区域进行工作，这就需要还原最新的内容了，demo如下： 1234567891011121314$ cd learngit$ git stash liststash@&#123;0&#125;: WIP on dev: 80b628c add no-ff mode content$ git stash popOn branch devChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")Dropped refs/stash@&#123;0&#125; (9e85bcc8435ae38c17db59ddc3cd8401af404827)$ git stash list ⚠️ git stash不仅可以隐藏工作区的内容，也可以隐藏暂存区的内容。git stash list是查看隐藏的列表。git stash pop是将隐藏的内容恢复并删除，git stash pop相当于git stash apply &amp;&amp; git stash drop，这里的git stash apply是恢复隐藏内容，git stash drop是删除隐藏内容。 多人协作简单谈下自己git协作的过程吧。在负责人将搭建好的仓库上传到远程的仓库后（一般是包含了master默认的分支和dev分支），自己将远程仓库克隆到本地，然后在本地的仓库上新建一个dev分支，将远程的dev分支重新拉取下git pull origin dev，开发完成后就可以提交自己的代码到远程的dev分支了，如果提交之前或者之后需要修改bug或者添加新的需求的话，需要新建一个相关的分支并完成开发，将他们合并到本地dev分支后上传到远程dev分支。如果新建的远程仓库中只有master分支，我是这样处理的：依然要在本地新建一个dev分支，然后在完成特定版本的开发后，将分支合并到本地master分支然后再推送到远程master分支，本地的dev分支保留哦。我自己比较偏向于第一种情况。 注意⚠️ (1)如果master主分支有内容更新的话，而你又在分支上开发，如果要拉取主分支最新的内容，直接git pull origin master就行了。(2) 如果你修改了本地的仓库，然后想拉取远程的分支修改相关的bug（或者产生冲突），你可以先通过git stash将本地修改的内容存储起来，再拉去远程的分支仓库进行修改git pull origin branch-name，之后将自己的存储的内容弹出git stash pop。 标签管理发布一个版本前，为了唯一确定时刻的版本，我们通常在版本库中打一个标签(tag)，方便在发布版本以后，可以在某个时刻将某个历史的版本提取出来（因为标签tag也是版本库的一个快照）。 创建标签创建标签是默认在你切换的分支最新提交处创建的。我这里在本地桌面的learngit仓库的master分支上打一个v1.0标签。 1234567891011$ cd desktop/learngit$ git branch* dev master$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ git tag$ git tag v1.0$ git tagv1.0 当然，你可以在非新commit的地方进行标签。这就需要你查找到需要打标签处的commit的id，然后执行git tag tagName commitId。这里我随意找master分支中的commit id进行标签v0.9的标签创建。 123456$ git log --pretty=oneline --abbrev-commitf15a1e9 merge dev branch0ca83c6 merge user feature26beda3 function user was acheive98746d9 merge with no-ff... 现在在commit id为 98746d9处打标签。 1234$ git tag v0.9 98746d9$ git tagv0.9v1.0 操作标签在上面创建标签，我们已经有了标签v0.9 v1.0。有时候我们标签打错了，需要进行删除，那么就得更改啦，运用git tag -d tagName 1234567891011121314151617$ git tag -d v0.9Deleted tag 'v0.9' (was 98746d9)$ git tagv1.0$ git tag v0.8 80b628c -m "version 0.8"$ git tagv0.8v1.0$ git show v0.8$ git show v0.8tag v0.8Tagger: reng99 &lt;1837895991@qq.com&gt;tag v0.8Tagger: reng99 &lt;1837895991@qq.com&gt;Date: Wed Dec 27 16:07:46 2017 +0800version 0.8 在上面的演示中，我删除了v0.9，然后在创建v0.8的时候追加了打标签的信息，之后使用git show tagName查看签名信息。 我们还可以进行分支切换标签，类似于分支的切换，我这里打的两个标签的内容是不同的，我可以通过观察内容的改表来得知时候成功切换标签了。 123456789101112131415161718192021$ git tagv0.8v1.0$ git checkout v1.0HEAD is now at f15a1e9... merge dev branch$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content### merge with no-ff### function user$ git checkout v0.8Previous HEAD position was f15a1e9... merge dev branchHEAD is now at 80b628c... add no-ff mode content$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content### merge with no-ff 在确认好标签后，就可以像远程推送标签了，我这里推送v1.0。 1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit.git * [new tag] v1.0 -&gt; v1.0 上面是使用git push origin tagName推送特定的tag到远程库，但是我们能不能推送全部的tag呢？答案是肯定的，看者可以通过git push origin --tags进行推送。有时候，我们推送了tag标签到远程库中了，现在想删除掉怎么办？这个就略微麻烦点，我们不能像上面提到的删除本地库的标签那样，通过git tag -d tagName那样，而是通过git push origin --delete tag tagName，这里不演示，如果看者感兴趣可以自己来把弄一下哦。 参考内容廖雪峰官方网站–Git教程 易百教程–Git教程 git官网 分支管理模型图 Git分支管理策略 - 阮一峰的网络日志 完结 @~@]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桂林阳朔旅游]]></title>
    <url>%2F2017%2F12%2F04%2Ftourist-guiLin-and-yangShuo%2F</url>
    <content type="text"><![CDATA[桂林市区的两江四湖的夜景很美丽，还有桂林市区的一些步行街走起来挺舒服的。然后就是阳朔啦，我喜欢那山里的清新的空气(哈哈哈，不过，我更喜欢家里海边的空气)。在山里面就好像与世隔绝，可能一个人在喧闹的城市呆久了，都会喜欢吧。⚠️ 多图博文，手机党要留意咯。 此次的桂林阳朔之旅三个人一起游玩放松，一个是好友从柳州过来桂林，另一个本身就在桂林读研究生，还有我啦–从广州这边过去呗，一共在那边呆三天，两天桂林市区(2017.12.01 &amp;&amp; 2017.12.03)和一天阳朔(2017.12.02)。 这次不像丹霞山旅游的流水帐那样写游记啦，仅仅谈下个人在阳朔的感受，桂林市区的没啥好谈的，毕竟是市区，都那样。 也许在广州呆的时间久了的原因，去到阳朔有不一样的体验—-第一次进山的新鲜感。第一次来阳朔，除了玩了一下当地人推荐的旅游的项目，比如坐竹筏游漓江啊。我比较喜欢租电驴(电动摩托)在山间闲逛一个下午的那段经历。哈哈,带着感冒开了一个下午。 开着电驴，进入山里面闲逛，没有目标，没有时间观念，抛离城市的喧闹与繁华。山里面的空气超级好，活脱一个天然的氧吧。自己开开停停，哎呀，这里的风景不错哦，那座山还行哦，这湖賊好看，这里有活动…嗯，我们就缺了个单反，还有如果朋友再高点，再瘦点，脸再…哈哈哈，我就有模特啦，不过手机拍出来的效果还不赖啦(本博文的照片都是用自己的手机拍的啦)。在阳朔的山间看到了一个新人在取景拍婚纱照，看到了骑着自行车的几个外国人在标着村上春树字样的山间小屋前面停下来欣赏，吃了当地阿婆自己种的柚子(虽然有些皱皮，时间久了，但是还是挺美味的啦)，感受到了山里人慢节奏的生活…嗯，没有更多的详细内容，要具体展开的话，我可以写一万字，看者可以亲自去体会下啦。 下面放上自己觉得还可以的照片啦—- 文章的结尾简单谈下自己的一些攻略： 广州出发的话，要提前坐交通工具到广州南站坐高铁，自己就是刚踩点过了安检，感觉就是在作死啊 广州南站出发到桂林，建议买到桂林站(其次是桂林北)，因为你可以在那边比较方便在繁华的地方租到房子，费用大概¥ 100/晚。当然啦，选择旅游淡季去，并且选择网购旅店，实体店买贵了¥40（我选择在西城步行街那里的青皮树酒店住下，网购¥99/晚，在那里可以逛夜市，并且离两江四湖比较近） 从桂林市区去阳朔的话，选择滴滴顺风车（免费为滴滴打了一波广告），选择滴滴，当然是因为实惠啦，如果正常坐大巴过去阳朔的话，时间和金钱成本有所提升（看者可以自行比较呢）,我们从西城步行街滴滴顺风车过去阳朔的时间是一个小时左右，费用是¥33/人。从阳朔回来也是坐滴滴的顺风车。 在阳朔玩的时候，可以租借电驴（电动摩托）去玩，我们当初是¥40元/辆滴滴司机说淡季一般是¥30/辆，看你砍价啦，我们从¥50/辆降到¥40/辆，其他的景点看兴趣选择，进山必须是电驴啊，骑自行车踩累死你啦。 偶尔光顾阳朔街边的老奶奶老爷爷大叔大婶（请允许我这样称呼，年轻人没看到几个在路边摆摊的） 就餐的话，在桂林我推荐的是椿记烧鹅（倒数第二张餐厅图就是它）,在阳朔只要不在西街的饭店里面吃就行(我们在饭店里面被坑了一次，东西贵而且味道不咋样，本来朋友要拉我走的，我都还没反应过来就点餐了) 先就这么多攻略吧，后期如果有发现其他实用的我再放上去啦！😊 欢迎看者补充啦。]]></content>
      <categories>
        <category>诗和远方</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0 踩坑记]]></title>
    <url>%2F2017%2F11%2F27%2Fvue-attention%2F</url>
    <content type="text"><![CDATA[自己接触vuejs将近一年，在这段时间里面，一共参与了公司以vuejs技术为框架的两个项目—-工单系统（公司内部项目，不方便贴链接）和淘米淘手游交易平台移动端（未上线）。本文是自己在使用vuejs开发过程中踩到的坑，特此记录下来的文章。嗯，希望对相关的技术爱好者有所帮助啦（如果你知道我在讲什么的话） 😊 对了，在开始写文章之前，先说明下: 文章里面的代码，是在.vue后缀的文件中实现的，在脚手架vue-cli搭建的项目上已经验证过，如有疑问，请自行验证或者在文章底部留言功能那里留言(仅支持github账号用户),或者邮箱留言(1837895991@qq.com)哦。 父组件传递消息给子组件使用props，下面先来看一个简单的例子: 父组件: parent.vue 123456789101112131415161718192021&lt;template&gt; &lt;div id="parent"&gt; &lt;child-component :title='parentTitle' /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childComponent from '@/components/path/to/childComponent.vue' export default &#123; data () &#123; return &#123; parentTitle: 'title form parent' &#125; &#125;, components: &#123; childComponent &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; #parent&#123;&#125;&lt;/style&gt; 子组件: childComponent.vue 1234567891011121314151617181920212223&lt;template&gt; &lt;div id="child"&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; &#125; &#125;, props: &#123; title: &#123; type: String, // 可设置类型 default: 'title from child' // 默认值 &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; #child&#123;&#125;&lt;/style&gt; 最后显示的结果是父亲传过来的消息，即信息为title form parent的h1标题。在父组件向子组件传递消息的过程中，首先，父亲需要拿到子组件&lt;child-component /&gt;,然后告诉子组件我要传递一个title给你:title=&#39;parentTitle&#39;，注意查收。接着，子组件通过props新建一个title的属性，并将数据读取到数据填充到相应的位置。详情看官网Prop 子组件传递消息给父组件子组件是通过$emit向父组件发送事件和相关的数据，来传递信息给父组件。 子组件(child.vue)的demo代码如下: 123456789101112131415161718192021&lt;template&gt; &lt;div id="child"&gt; &lt;button @click="toParent"&gt;向父组件传递消息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "child", data () &#123; return &#123; message: 'message from children' &#125; &#125;, methods: &#123; toParent () &#123; var vm = this; vm.$emit('child-say',vm.message); &#125; &#125; &#125;&lt;/script&gt; 父组件demo代码如下： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id="parent"&gt; &lt;child-component @child-say="parentEvent" /&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childComponent from '@/components/path/to/child.vue'; export default &#123; name: 'parent', data () &#123; return &#123; msg : '' &#125; &#125;, methods: &#123; parentEvent: function (data) &#123; // data 是子组件传过来的数据 var vm = this; vm.msg = data; &#125; &#125;, components: &#123; childComponent &#125; &#125;&lt;/script&gt; 上面代码的过程是，点击了子组件里面的向父组件传递消息的按钮，将子组件里面的message信息放在$emit里面发送给父组件，而父组件在引用的子组件中新建一个事件来接受传过来的信息，然后在父组件中创建的方法对data里面的msg进行数据的改写。最终在页面上显示出的h1标题信息为message from children，即是子组件里面的信息。嗯，官网相关传送门 通过原型组件信息传递在组件的信息传递中，可以通过构造函数和实例之间的原型链来实现。如下： 123456import Vue from 'vue'// 注册一个中央事件总线，代替vuexVue.prototype.bus = new Vue();// 全局存储对象Vue.prototype.bus.global = &#123;&#125; 123456789101112131415methods: &#123; async getBaziData() &#123; const rsp = await requestBazi(); this.baziData = res; this.bus.global.baziData = res; &#125;, alreadyRequest(type) &#123; if(this.bus.global.baziData) &#123; this.baziDetail = this.bus.global.baziData[type]; this.articleCatId = this.bus.global.baziData.config[type] return true; &#125; return false; &#125;&#125; 使用vuex使用vuex来进行组件间的数据通信，详情请看我写的文章，请戳vuex要点 绑定HTML Class类名结合style的使用一般是用来动态改变样式，所以要用到v-bind:class简写:class。 demo如下: 12345678910111213141516171819202122232425&lt;template&gt; &lt;button class="default-bg" :class="&#123;'active-bg':flag&#125;" @click="changeBtnBg"&gt;按钮&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; flag : false &#125; &#125;, methods: &#123; changeBtnBg: function () &#123; vm.flag = true; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .default-bg&#123; background: red; &#125; .active-bg&#123; background: blue; &#125;&lt;/style&gt; 上面代码中，实现了一个红色按钮通过点击自身实现变成绿色按钮的功能。首先，自己给到一个默认的红色的按钮，并且在按钮上绑定了changeBtnBg的方法，用于控制标志符flag的布尔值。值得注意的是，:class通过flag的真假值来决定是否改变按钮的背景色为定义的绿色。官网相关请戳这里 v-model引用的数据需初始化也许你遇到这个问题，命名写了&lt;input type=&quot;text&quot; v-model=&quot;inputMsg&quot; /&gt;,可是相关的数据绑定&lt;div&gt;&lt;/div&gt;却没有消息，并报错。这是因为你还没有初始化相关的数据啊。正确的姿势应该像下面👇 12345678910111213&lt;template&gt; &lt;input type="text" v-model="inputMsg"/&gt; &lt;div&gt;&#123;&#123;inputMsg&#125;&#125;&lt;div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; inputMsg : '' // 记得初始化数据哦 &#125; &#125; &#125;&lt;/script&gt; style中的scoped也许你注意到了我上面的代码中，在每个&lt;style&gt;&lt;style&gt;的元素中添加了scoped。scoped是用来限定样式的作用的范围，防止此组件里面的样式和其他组件的同名的样式产生冲突。比如—- component1.vue 12345678&lt;template&gt; &lt;h1 id = "title"&gt;component1's title&lt;/h1&gt;&lt;/template&gt;&lt;style scoped&gt; #title&#123; color: red; &#125;&lt;/style&gt; component2.vue 12345678&lt;template&gt; &lt;h1 id="title"&gt;component2's title&lt;/h1&gt;&lt;/template&gt;&lt;style scoped&gt; #title&#123; color: blue; &#125;&lt;/style&gt; 在上面的两个组将component1.vue &amp;&amp; component2.vue中，虽然都有相同的id，但是对各自没什么影响。简单说，加上scoped之后，样式的编写只对本组件有效。 watch监听数据在数据发生改变的时候，需要监听数据做到动态修改数据，就要使用到watch了，这里分为普通监听和深度监听，直接看demo啦。 1234567891011121314151617181920212223242526&lt;script&gt; export default &#123; data()&#123; msg: 'init msg', obj: &#123; arr: [1,2,3], name: '嘉明' &#125; &#125;, watch: &#123; // 普通监听 msg(newVal , oldVal)&#123; console.log("msg:" + newVal , oldVal); &#125;, // 深度监听，可以监听到对象、数组的变化 obj: &#123; handler(newVal , oldVal)&#123; console.log("obj.arr" + newVal , oldVal); // 相关处理 // ... &#125;, deep: true &#125; &#125; &#125;&lt;/script&gt; @clcik/@mouseover等方法失效问题在使用一些整合了vue的ui框架的时候，比如使用element-ui，在其封装的标签上写一些方法的时候，通常是不会生效的（当然你可以使用他们封装好的方式去使用），可是在没有合适的方式的时候，想使用原来的@clcik怎么办？ 下面的代码说明问题，在@click后面添加一个native属性就行，即是@click.native，其他的方法类似。 12345# click无效代码&lt;el-col @click="alert('click')" :span="24"&gt;click me&lt;/el-col&gt;# click有效代码&lt;el-col @click.native="alert('click')" :span="24"&gt;click me&lt;/el-col&gt; 精力有限，未能一次性更新完,忘见谅…]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丹霞山旅游]]></title>
    <url>%2F2017%2F11%2F26%2Ftourist-danXia-mountain%2F</url>
    <content type="text"><![CDATA[由于公司的项目–淘米淘手游交易平台,自己已经有三个月没有离开过广州游玩了。刚好项目自己负责的部分已经ok，然后好友约了周末(2017.10.28～2017.10.29)去韶关爬丹霞山，自己不假思索的答应了！ 我们是四个人一同前往—-两位女生两位男生，同行的四个人中，我只认识我的好友(那个肥嘟嘟脸的男生)，不认识两位女生，因为在旅行完之后没有联系了，忘了她们的名字了，暂且用女生A(戴帽子笑起来很甜的女生)和女生B(一直被吐槽摆不好poss的女生😂 )来区分吧。四人组见下图 : 女生A : 好美啊！空气很好女生B : 周末来得值啊，下次还来好友 : 这山爬得都不累我 : 能在这里住真是超级幸福的…以下省略若干在归途中的对话。是啊，这趟来得很ok啊，重阳节在这么美的地方爬山，真的是超级满足的呢。 我们这两天的计划是，去山顶上看日落和日出，剩下的时间就是在山间闲逛，感受自然。计划如此，除了没能在山顶（人太多，登不上阳元山的顶部看日落，只能够在山腰山看日落了）。 我们早上从广州火车站出发，坐火车直达韶关东，然后坐大巴去丹霞山，买了低配版的门票（150元/人的48小时有效的票）进入丹霞山里面，在兜兜转转后还是女生B电话给来过的同事请教攻略，果断的拒接了在景区山脚下拉客的旅店店主，坐着免费的公交（其实费用包含在票价里面了）兜兜转转的去到被推荐的景区里面当地人的旅店住下。此刻必须赞一下店主啊—-因为我们选好房间后，直接将随身带的行李放到各自的房间后就去吃午餐了没登记个人信息，但是店主知道有人介绍过来的并没有叫我们返回登记，还有店主很是热心的比划着路线给我们。对了，我们住的店是放假啦客栈，租了两间双人房（100元/天，ps:当地人的房子改装的租房，整片区域的价格都差不多）。 来到丹霞山的第一天，简单的吃了顿午饭，我们一行四人就奔着看日出的地点长老峰那里踩点去了，因为观日出的地方阳元山在另一边，得提前熟悉下呢。然后我们就坐车返回原地走路去阳元山看日落，可能我们去的比较晚又加上那天是重阳节,人多得我们上不了山顶，只能在山腰上观看了。对了，比较逗的是，爬阳元山的女生A因为山路陡恐高症瞬间爆发，腿软难以前行。 第二天早上，我们五点就起床等车去长老峰看日出，这个点，公交的站点已经聚集了些人，此时天空还是可以看到星星几点。我们被送到长老峰不远处的终点站，大概是5:40分开始刷票进入长老峰，并沿着路灯一路爬上山顶。漆黑的凌晨借助着微弱的灯光，小心翼翼的爬着陡峭的山路，一大早就出着汗，还是第一次。我们爬到山顶的时候，有很多的人已经在山顶的平台了，我们很是难挤到里面去（对了，有人山顶上依靠帐篷过夜的）。选好一个不错的位置，在天边泛白的时候，踮着脚尖，看着太阳慢慢的奔出来，很是满足。 之后，在日出一段时间后，我们便下山根据地图，依据着店主推荐的路线去逛下其他的风景，神奇的是，我们真能走，又闲逛了好远的地方，期间自己还担任了女生A的摄影师，哈哈哈，我的拍照技术还是ok的啦。四人组边走边聊，从本来有些约束到自然交流，在山间中走动，那山很俊，那林很绿，那水很清，倍感轻松😄 对了，在吃的方面，我们在同一家店吃了走地鸡，味道棒棒的（原谅我忘记了店名），还有客家三宝这道菜，自己蛮喜欢的。 时间到了29号三四点的时候，我们就启程离开景区回广州了，结束丹霞山的两日游。 在本次的游玩中，自己整理了点旅游攻略，希望对见者有帮助或者重游的时候有提示： 提前两三天联系景区的旅店老板，定好房间。有下面的原因： 1231. 景区内和景区外的住房的价格是相差不大的，尽量在景区内订房，这样会节省你很多的时间2. 需要提前联系旅店的老板帮你定景区的票，这样会为你省下不少的经费（吐槽下，外来人的票价和当地人的票价相差太远）3. 寻找有去过丹霞山的朋友，取一下当初居住的旅店的老板的联系方式，在那里订房会得到一定程度的照顾 两天时间丹霞山游玩足够 过去韶关的话，如果经济条件还可以的话，还是不要选择火车吧 不要在什么国庆节啊节日过去，尽量选择周末 多多欣赏自然风光，拍照不游玩，游玩不拍照 学好拍照技术出去玩会更加惬意哦(带上专业的摄像机更好呢)]]></content>
      <categories>
        <category>诗和远方</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
</search>
