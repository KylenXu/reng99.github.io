<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重读《JavaScript高级程序设计》]]></title>
    <url>%2F2018%2F03%2F01%2Fjavascript-high-level%2F</url>
    <content type="text"><![CDATA[最近自己在休假，打算闭门几天将《JavaScript高级程序设计》(第3版)这本良心教材读完。进入前端领域两年多，记录下重读这本教材的“硬”知识点 😊 。另外自己准备离职，哪位伯乐推荐下前端岗位过来下，感激不尽，个人线上简历请猛戳这里 函数没有重载ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数类型和数量）不同即可[p66]。ECMAScript的类型是松散形的，没有签名，所以是没有重载的。 12345678function load(num)&#123; return num + 100;&#125;function load(num,name)&#123; return num + 200;&#125;var result = load(100); // 200# 后面的函数声明覆盖掉前面的函数声明 基本的数据类型基本类型值指的是简单的数据段，而引用类型指那些可能由多个值构成的对象[p68]。这里指出来的基本的数据类型是说的es5的哈：Undefined,Null,Boolean,Number和String。 传递参数ECMAScript 中所有的函数的参数都是按值传递的[p70]。也就是说，把函数外部的值复制给函数内部的参数，就是把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。下面分开例子介绍两种不同类型为什么是按值传递。 基本类型值基本类型这个按值传递比较好理解，直接复制变量的值传递： 12345678function addTen(num)&#123; num += 10; return num;&#125;var count = 20;var result = addTen(10);console.log(count); // 20 ，没有变化哈console.log(result); // 30 引用类型值有些人认为引用类型的传参是按照引用来传的，那暂且认为他们的理解是正确的，那下面的示例结果怎么解析呢？ 12345678function setName(obj)&#123; obj.name = '嘉明'; obj = new Object(); obj.name = '庞嘉明';&#125;var person = new Object();setName(person);console.log(person.name); // '嘉明'，为啥不是'庞嘉明'呢？ 如果是按照引用传的话，那么新建的对象obj = new Object()应该是指向堆内容的对象啊，那么改变它本有的name属性值应该生效，然而并没有生效。所以它也是按值传递滴。 函数声明与函数表达式解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁[p111]。解析器会率先读取函数声明，并使其执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析。 1234console.log(sum(10 , 10)); // 20function sum(num1 , num2)&#123; return num1 + num2;&#125; 1234console.log(sum(10 , 10)); //TypeError: sum is not a functionvar sum = function(num1 , num2)&#123; return num1 + num2;&#125; call和apply每个函数都包含两个非继承而来的方法：call()和apply()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值[116]。call和apply在对象中还是挺有用处的。 apply()方法和call()方法的作用是相同的，区别在于接收参数的方式不同。 applyapply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组，这里的参数数组可以是Array的实例，也可以是arguments对象（类数组对象）。 1234567891011function sum(num1 , num2)&#123; return num1 + num2;&#125;function callSum1(num1,num2)&#123; return sum.apply(this,arguments); // 传入arguments类数组对象&#125;function callSum2(num1,num2)&#123; return sum.apply(this,[num1 , num2]); // 传入数组&#125;console.log(callSum1(10 , 10)); // 20console.log(callSum2(10 , 10)); // 20 callcall()方法接收的第一个参数和apply()方法接收的一样，变化的是其余的参数直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。 1234567function sum(num1 , num2)&#123; return num1 + num2;&#125;function callSum(num1 , num2)&#123; return sum.call(this , sum1 , sum2);&#125;console.log(callSum(10 , 10)); // 20 精力有限，未能一次性更新完,忘见谅…]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2018计划]]></title>
    <url>%2F2018%2F02%2F21%2Fmy-2018-plans%2F</url>
    <content type="text"><![CDATA[嗖～嗖～嗖～～～🚀现在是农历正月初六的晚上十一点多，第二天就得上班了呢，一年的时间过得真是賊快，来不及感叹2017年自己做了什么，只想着眼现在，立flag啦，鬼知道我会在新的一年会遇到什么人和事情呢。希望一年后回头看不打脸咯… 看书看完下面的推荐书籍中的3-5本： 保罗.约翰逊 《文明的解析》 乔治.阿克洛夫 《动物精神》 南希.休斯顿 《断层线》 安德鲁.罗斯.索尔金 《大而不倒》 保罗.克利尔 《被掠夺的星球》 马特.里德利 《理智的乐观者》 丹.艾瑞里 《非理性的积极力量》 莱茵哈特.罗格夫 《这次不一样》 乔纳森.弗兰岑 《自由》 里查德.克拉克和罗伯特.克纳克 《网络战争》 巴塞维奇 《华盛顿规则》 查布里斯.西蒙斯 《看不见的大猩猩》 托尼.朱特 《乡土式微》 阿维沙伊.马加利特 《关于妥协和卑微的妥协》 奇普.希思 《瞬变》 刘易斯 《大空头》 查尔斯.默里 《人类成就》 瓦茨拉夫.斯米尔 《能源神话与现实》 南丹.尼莱卡尼 《印度畅想》 克莱.舍基 《未来是湿的》 深造好吧，过年回去已经跟家人达成协议，2018要把考研列入其中，嗯，工作之余努力读书哦，除了程序猿一职，我还有一职—-永远都是学生哈哈哈。对了，英文提高很重要，这也涉及到下面的技能提升。 技能作为一个码农，自己的码农技能总得上升一个阶段吧。将javascript的使用不仅仅局限于前端。自己的工作不仅仅是前端。相关的技能是html/html5,css/css3和javascript为主，java等为辅。 旅游下面的地点选择1-2进行旅游: 泰国 新疆 云南 海南 成都 杭州 北京 潮汕 就此打住了，这么列下来，感觉自己2018年要累成狗。希望能完成这些模糊又肯定的目标，对了，希望在新的一年里面能够遇到对的那个人 😂]]></content>
      <categories>
        <category>诗和远方</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack从零构建vue项目]]></title>
    <url>%2F2018%2F01%2F16%2Fwebpack-build-vue-project%2F</url>
    <content type="text"><![CDATA[看官别急 工作之余更新 预计2018.3.30(乐观的时间，因为自己时间感觉不够用)前完成本博文更新 可文末留言更新建议或打赏 看者可以到自己几个月前搭建的一个小的webapck项目github仓库下简单看搭建过程啦，如果你在webpack项目中留颗星星那就更好了。 当然本项目不会像之前的那么简单啦，注意的是本博文webpack的讲解版本是目前最新的版本–v3.10.0（截止2018.01.21），敬请期待… webpack是什么官方描述：At its core, webpack is a static module bundler for modern JavaScript applications. When webpack processes your application, it recursively builds a dependency graph that includes every module your application needs, then packages all of those modules into one or more bundles. 鄙人的翻译：webpack的核心是现代javascript程序的静态模块打包工具。当webpack处理你的应用的时候，它会根据你的应用需要的模块递归的描绘出一个依赖图，然后打包这些模块到指定的一个或者多个文件中。 翻译不妥，还请指出。 webpack核心概念webpack的核心包括： 入口(entry)，出口(output)，加载器(loader)和插件(plugin)。 Entry入口entry指明webpack应该从哪个文件开始解析去构建它内部的依赖图。入口的语法可以分为下面的这些 ： 单一的入口 使用方法： entry: string|Array&lt;string&gt; 相关的demo如下 ： 1234const config = &#123; entry: '/path/to/my/entry/file.js'&#125;;module.exports = config; 多入口（类型入口） 使用方法： entry:{[entryChunkName: string]: string|Array&lt;string&gt;} 相关的demo如下 ： 1234567const config = &#123; entry: &#123; app: '/path/to/app.js', vendors: '/path/to/vendors.js' &#125;&#125;;module.exports = config; Output输出点output是告诉webpack它处理后的文件命名和文件应该存放在哪里。 用法 (1) 属性filename是用来告诉webpack输出到的文件 (2) 属性path是确定文件的绝对路径，一般是用path.resolve(__dirname,’directoryName’) 单文件出口 单文件出口就是webpack处理后只输入一个文件，demo如下: 1234567const config = &#123; output: &#123; filename: 'bundle.js', path: '/path/to/project/assets' &#125;&#125;;module.exports = config; 多文件输出 如果想在多入口文件中输出对应的文件的话，就需要用到webpack带的name属性了，demo如下: 12345678910&#123; entry: &#123; app: '/path/to/app.js', search: '/path/to/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist' # 一般是存放在dist文件夹下啦 &#125;&#125; 执行相关的命令行后，就会在dist文件下面看到app.js和search.js文件了。 Loaderswebpack它本身只能够识别javascript文件，那么要webpack来处理除了javascript文件之外的文件，就需要用到loaders了。简单来讲，Loaders能够转换你应用中所有类型的文件到依赖的视图里面。 在webpack的配置中，Loaders需要注意以下的两点: (1) test属性定义哪种类型的文件应该被转换 (2) use属性指明哪种加载器应该用来转换文件 如下面的demo的rule字段中匹配后缀名为.txt的文件(假设你已经安装了raw-loader) ： 1234567891011121314151617const path = require('path)const config = &#123; entry: '/path/to/file.js', output: &#123; path: path.resolve(__dirname,'dist'), filename: 'file.name.js' &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;&#125; PluginsPlugin范围可以从优化和压缩的方法到定义类似环境的变量。英文原话Plugins range from bundle optimization and minification all the way to defining environment-like variables。 如果你要使用插件，你需要使用require()方法将它添加到plugins的数组中，然后创建相关的实例。下面以html-webpack-plugin插件为例子(前提是你已经安装了这个插件): 123456789101112131415161718192021222324252627const HtmlWebpackPlugin = require('html-webpack-plugin');const webpack = require('webpack');const path = require('path');const config = &#123; entry: '/path/to/entry/file.js', output: &#123; path: path.resolve(__dirname,'dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: '/\.txt$/', use: 'raw-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;) ]&#125;;module.exports = config; webpack项目搭建过程简单的讲解了webpack的核心概念，那么接下来就使用webpack来搭建项目吧。下面讲解整个的项目搭建的过程。😊 项目的初始化通过命令行npm init -y的初始化项目，建议在桌面新建文件（因为后面好找啊）还有通过npm init进行项目的初始化（自己可以控制内容）。自己在osx系统上是经过下面的步骤建项目的，如果你使用的电脑是其他系统，有所出入，请留意。 1234567891011121314$ cd desktop # 进入桌面$ mkdir projectName &amp;&amp; cd cd projectName # 新建目录并进入$ npm init # 开始初始化项目package name: as you like # 填写包名称，默认projectNameversion: as you like # 项目的版本号，默认1.0.0description: as you like # 关于项目的描述，默认为空entry point: as you like # 项目的入口文件，默认是index.jstest command: as you like # 测试命令，默认为空git repository: relatived git repository that you like # 相关的git仓库，如果有请关联一个，这样好管理。默认为空keyword: as you like # 项目的关键词，默认为空author: your name # 项目的作者/发起人，默认为空license: license you write # 相关的证书，默认是ISCIs this ok?(yes) # 询问你设置是否确认，确认的话就按回车键。如果放弃请英文输入法输入n，再按下回车键，就放弃更改，回到最初状态了，再执行 npm init 如果你直接执行npm init -y就会直接使用默认状态啦，如下： 1234567891011121314151617$ cd desktop$ mkdir projectName &amp;&amp; cd projectName$ npm init -yWrote to /Users/reng/Desktop/demo/package.json:&#123; "name": "projectName", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], "author": "", "license": "ISC"&#125; 个人还是比较偏向npm init啦！ 有待补充 全栈项目是什么全栈项目呢？说实在，自己还没想好 😂 看情况写或者不写 有待补充 参考webpack官网 vue官网 精力有限，未能一次性更新完,忘见谅…]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>mvvm</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex 要点]]></title>
    <url>%2F2018%2F01%2F01%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex是一个状态管理模式，通过用户的actions触发事件，然后通过mutations去更改数据（你也可以说状态啦 -&gt; state），最后通过getters对状态进行获取，更改页面展示的内容。哈哈 😄 ，详细的内容请接着往下看，如有不妥请文末留言啊。原创文章，转载请注明出处。 注意 ⚠️ 文章中涉及到项目代码是使用Vue官方提供的脚手架vue-cli进行搭建的，如果看者感兴趣，可以自行用vue-cli搭建项目，并进行代码的验证。 Vuex是什么官网介绍:Vuex是一个专门为Vuejs应用程序开发的状态管理模式。（类似react的redux）。Vuex采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex在构建中大型的应用比较适用，小型的应用用组件之间的通信就可以了，小型应用用上Vuex就显得比较臃肿了。 Vuex的安装因为自己是使用npm来辅助开发的，所以我也只说下通过npm安装Vuex的方法。其他的安装方法，请戳传送门。 进入你项目的根目录，然后执行: 123$ npm install vuex --save 或$ npm install vuex --save-dev 然后在store主入口的javascript文件，一般是store/index.js中通过use进行引用，前提是你已经安装了vue : 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 为了方便在各个组件中使用store，需要在程序的根组件中将其注入到每个子组件。我们需要在实例化Vue的时候将store引入（实例化Vue的文件一般是main.js主入口文件）。 123456import Vue from 'vue'import store from '/path/to/store/index.js'const initApp =new Vue(&#123; store: store &#125;).$mount('#app') 核心概念在使用Vuex进行开发的过程中，你可以理解核心的概念只有State、Action和Mutation三个，就像本文章开篇给出的截图流程那样简单明了。但是，我们使用Vuex开发一个应用，肯定是想要方便管理等等。这里自己按照五个核心概念来谈谈，五个核心概念也是官网推荐使用的。Vuex的五个核心概念除了上面指出的三个之外，还包括Getter和Module两个。先一句话来概括下它们 : State : 数据源的存放地 Getter : store的计算属性 Mutation : 处理数据逻辑，使得数据和视图分离（同步） Action : 类似Mutation（异步），改变状态的话，还得触发Mutation Module : 将store分解成模块 下面来详细讲解各个核心概念咯 😊 StateVuex是使用单一状态树，一个对象就包含了全部的应用层级状态。这也就表明，一个应用仅仅包含一个store的实例。 状态State对应于Vue对象中的data，因为两者是对应的关系，所以在这里可以称状态==数据的。如下代码指出： 12345678910&lt;script&gt; export default &#123; name: '', data() &#123; // state对应的地方 return &#123; ... &#125; &#125; &#125;&lt;/script&gt; State里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新。也就是说数据和视图是同步的。 局部状态 虽然说Vuex的Store仓库让我们统一管理数据变得更加方便，但是代码一多也会变得冗长和不直观。有些组件的数据是自己严格使用，我们可以将state放在组件自身，作为局部数据，专供此组件使用。比如现在只想在一个组件中使用emotion: happiness，那就不必要在store的state中进行定义了，只在本组件初始化就行了： 12345data () &#123; return &#123; emotion: 'happiness' &#125;&#125; 获取状态 在Vue组件中获取store中的数据（状态），最直接的就是通过计算属性获取。因为在上面我将store注册到根组件上了，所以在这里直接通过this.$store就可以调用了。比如我获取状态（state）中的count: 100 : 12345computed: &#123; count: function ()&#123; return this.$store.state.count; &#125;&#125; mapState辅助函数 mapState辅助函数把全局的State映射到当前组件computed计算属性中，即是帮助我们生成计算属性。简化我们的代码操作，不需要使用this.$store.state获取了。以上面状态（state）中的count: 100为例子 : 1234567import &#123; mapState &#125; from 'vuex' // 注意别漏了引入export default &#123; computed: mapState(&#123; count: state =&gt; state.count &#125;),&#125; Getter上面的state中我们了解到，在store仓库里，state是用来存储数据的。在多个组件中要进行使用同一种状态的话，对数据进行简单操作，我们可以通过在组件的computed中进行获取this.$store.state.theDataName。简单操作没问题，但是，我们进行其他的操作，比如过滤操作，我们就得写一堆的代码 : 1234567computed: &#123; filterData: function () &#123; this.$store.state.theDataName.filter(function(item)&#123; // do something ... &#125;) &#125;&#125; 然后在每个组件中复制这一大堆的代码，或者你单独新建一个文件把代码写进入，每个组件都引入（如果你不觉得很麻烦的话）。 而Getter可以把组件中共享状态抽取出来，这也是Getter存在的意义。我们可以认为，Getter是Store的计算属性。 如何使用Getter 为了方便管理，需要一个单独的getters.js的文件，假如已经有对数据进行过滤的函数了: 12345export default &#123; filterDatas (state,getter,rootState) &#123; // do something ... &#125;&#125; 那么只要在相关的组件的computed中引入就可以了，是不是很方便啊 ： 12345computed: &#123; filterItems: function () &#123; return this.$store.getters.filterDatas; &#125;&#125; mapGetters辅助函数 mapGetters辅助函数仅仅是将store中的getter映射到局部计算属性，看情况使用，类似mapState。下面使用mapGetter改写上面的filterItems ： 1234567import &#123; mapGetters &#125; from 'vuex' // 记得引入export default &#123; computed: mapGetters(&#123; filterItems: 'filterDatas' &#125;)&#125; MutationVuex的中文官网中明确指出更改Vuex的store中的状态（state）的唯一的方法是提交mutation。 Mutation可以理解为：在Mutation里面装着一些改变数据方法的集合。即把处理数据逻辑方法全部放在Mutation里面，使得数据和视图分离。 使用Mutation Mutation的结构：每个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)也可以理解为{type:handler()}，这和订阅发布有点类似。先是注册事件，当触发响应类型的时候调用handle()，调用type的时候需要用到store.commit(&#39;typeName&#39;)方法。比如我想在要触发mutations.js中的INCREASE处理函数: 1234567// mutations.jsconst INCREASE = 'INCREASE'; // 不能漏export default &#123; [INCREASE](state,data)&#123; // change the state ... &#125;&#125; 因为我注册了store到根组件，那么在.vue组件中就可以通过this.$store.commit(&#39;INCREASE&#39;)触发这个改变相关状态的处理函数了。如果在actions.js中调用，直接使用提供的commit参数进行commit(&#39;INCREASE&#39;)触发处理函数。 提交载荷（Payload） 可以向store.commit传入额外的参数，参数一般为object类型。我这里接着上面的示例，组件触发的时候传入一个100的数字到data里面 ： 12345methods:&#123; increase: function ()&#123; this.$store.commit('INCREASE',100); &#125;&#125; 使用mutation-types.js 使用mutation-types.js(名称可根据爱好随便取)是为了方便管理项目mutation的类型。我在知乎上也回答过为什么要使用mutation-types.js，当然你完全没必要使用它，不过我自己喜欢使用它。将使用mutation内容中的mutations.js代码拆分为两部分，一部分是mutation-types.js，另一部分是mutations.js，示范如下 ： 12345678910// mutation-types.jsexport const INCREASE = 'INCREASE';// mutations.jsimport &#123;INCREASE&#125; from '/path/to/mutation-type.js'export default &#123; [INCREASE](state,data)&#123; // change the state ... &#125;&#125; mapMutations辅助函数 为了简化你的代码量，使得代码看起来逼格更高点，你可以使用mapMutations辅助函数将组件中的methods映射为store.commit调用(需要在根节点注入store哦)。demo来映射上面的increase ： 12345678import &#123;mapMutations&#125; from 'vuex' // 不能漏哦export default &#123; methods: &#123; ...mapMutations([ 'INCREASE' ]) &#125;&#125; ActionAction 类似于 Mutation，不同点是 ： Action提交的是 mutation，而不是直接变更状态 Action是异步的，而Mutation是同步的 详细的相似点可以回滚看Mutation的啦，或者直接戳vue官网Store 组件内分发Action 因为我在全局组件中挂载了store，所以引用就可以这样写 -&gt; this.$store.dispatch(&#39;dispatchEvent&#39;)，当然你可以传参过去啦。比如：this.$store.dispatch(&#39;dispatchEvent&#39;,param)，param一般是obj类型的。 mapActions辅助 为了简化操作，Action像Mutaion一样有一个映射的函数mapActions。使用方法也类似Mutation，demo如下 ： 123456789101112import &#123;mapActions&#125; from 'vuex' // 不能漏哦export default &#123; methods: &#123; ...mapActions([ 'INCREASE' ]) 或 ...mapActions([ increase: 'INCREASE' ]) &#125;&#125; Module由于vue中使用单一的状态树，当管理的项目中大型的时候，所有的状态都集中在一个对象中会变得比较复杂，难以管理，显得项目比较臃肿。为了解决这些问题，我们可以使用vuex提供的Module功能，将store分割成模块。每个模块都有自己的state、mutation、action、getter。现在假设你的应用的功能包括登录和音乐两个功能模块页面，那么store的结构可以这样写： 12345678910111213141516171819- module - music actions.js getters.js index.js // music module 的入口文件 mutations.js state.js - user actions.js getters.js index.js // user module的入口文件 mutations.js state.jsactions.jsindex.js // store 的入口文件mutation-types.js // 管理所有的mutationsmutations.jsstate.js 模块的局部状态 对于模块内部的mutation，接收的第一个参数是state，也就是接收本模块的局部状态，比如上面的music模块，我在其state.js中写上 : 123456export default &#123; music: &#123; list: [], total: 100 &#125;&#125; 我在同级的mutations.js中有 ： 1234567import * as types from '../../mutation-types'export default &#123; [types.UPDATE_MUSIC](state,data)&#123; console.log(state.music.total); // 打印出100 ...other handle &#125;&#125; 命名空间 默认情况下，模块内部的action、mutation 和 getter是注册在全局命名空间的 -&gt; 这样使得多个模块能够对mutation和action作出响应。 如果看者希望你写的模块具有更高的封装度和复用性，你可以通过添加namespaced:true的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。比如上面的music模块 : 12345678910111213import state from './state' //stateimport getters from './getters' //gettersimport * as actions from './actions' //actionsimport mutations from './mutations' //mutations//modulesexport default &#123; namespaced: true, // 添加命名空间 state, getters, actions, mutations&#125; 详细的情况请戳vuex官网modules store结构vuex的官网谈项目结构，我这里谈store结构，因为我觉得每个人的项目的结构布局有所不同，但是vuex可以是一个模版化的使用。当然，这模版化的使用遵循了官网所定的规则： 应用层级的状态应该集中在单个 store对象中 提交mutation是更改状态（state）的唯一方法，并且这个过程是同步的 异步逻辑都应该封装到action里面 整理的store结构如下： 123456789101112131415161718.├── ...│└── store ├── actions.js // 根级别的 action ├── index.js // 我们组装模块并导出 store 的地方 ├── mutation-types.js // store所有mutations管理 ├── mutations.js // 根级别的 mutation ├── state.js // 根级别的 state └── modules ├── moduleA ├── moduleB └── moduleC ├── actions.js // moduleC 的 action ├── getters.js // moduleC 的 getter ├── index.js // moduleC 的 入口 ├── mutations.js // moduleC 的 mutation └── state.js // moduleC 的 state 上面的结构比较通用，模版化，我在接下来的完整小项目中就是使用上面的store结构来管理啦 😝 完整小项目自己在上面讲了一大推的废话，嗯哈，为了证明那不是废话，下面就结合上面讲的知识点来一个综合的min-demo吧，欢迎指正啊！ @~@ 是什么项目呢思来想去，自己还是觉得做一个简单版本的todo项目好点，理由如下： 个人时间精力邮箱(main reason) todo项目 -&gt; 麻雀虽小，五脏俱全 项目包含一个简单的登录页面，然后跳转到todo小项目的页面。如图所示： 在登录页面，会要求你填写非空的内容进入，我这里填了自己的名字啦。在todo页面，你就需要在输入框输入你要做的事情啦，事情的添加默认是未做的状态。当然，允许进行时间的状态进行设置和事件的删除啦。成品可查看下面最终的效果gif动效，就酱 @～@ 项目的初始化⚠️ 本项目在mac系统上使用vue-cli的基础上搭建(搭建日期2018.01.14)的小项目，其完整的覆盖了vue的全家桶了 -&gt; 使用的vue版本是^2.5.2，vuex的版本是^3.0.1，vue-router的版本也是^3.0.1。如果你使用低版本，请参考低版本的相关说明。 123456789101112131415161718192021222324252627# 全局安装 vue-cli$ npm install --global vue-cli# 进入桌面$ cd desktop# 初始化项目min-demo$ vue init webpack min-demo? Project name min-demo # 项目名称? Project description A Vue.js project # 项目描述? Author reng99 # 项目作者? Vue build standalone? Install vue-router? Yes # 是否使用路由? Use ESLint to lint your code? No # 是否启动语法检查? Set up unit tests No # 是否配置单元测试? Setup e2e tests with Nightwatch? No # 是否配置集成测试? Should we run `npm install` for you after the project has been created? (recommended) npm # 选择那种包管理工具进行安装依赖，共三种选择：npm,yarn,no thanks 我选择了npm vue-cli · Generated "min-demo".# 等待安装依赖的完成...# 进入项目$ cd min-demo# 启动项目$ npm run dev# 如果一切正常，就会在浏览器的http://localhost:8080的地址页面有相关的vue界面展示出来 当然，使用脚手架搭建的项目，没有自动集成vuex，这就需要你进入项目的根目录，执行npm install vuex --save命令来安装啦。 项目的实现嗯嗯，下面我将改写在vue-cli搭建的项目，以符合我自己期望。改写的代码就不全给出来了啊，关键的项目代码还是会贴一下的。😝 这个项目的结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940.├── build/ #webpack 的配置项│ └── ...├── config/│ ├── index.js # 项目的主要配置│ └── ...├── node_modules/ # 相关依赖│ └── ...├── src/│ ├── main.js # 应用的主入口│ ├── App.vue # 引用的根组件│ ├── components/ │ │ ├── Login.vue # 登录组件│ │ └── Todo.vue # todo组件│ ├── store/ │ │ ├── modules/ # todo组件│ │ │ └── todo│ │ │ ├── actions.js # todo的actions│ │ │ ├── getters.js # todo的getters│ │ │ ├── index.js # todo的入口│ │ │ ├── mutations.js # todo的mutations│ │ │ └── state.js # todo的状态│ │ ├── actions.js # 根actions│ │ ├── index.js # store入口文件│ │ ├── mutation-types.js # 整个store中的mutation的管理│ │ ├── mutations.js # 根mutations│ │ └── state.js # 根的状态│ ├── router/ │ │ └── index.js # 路由文件│ └── assets/ # 模块的资源│ └── ...├── static/ # 静态资源存放的地方│ └── ...├── .babelrc # 语法转换babel的相关配置├── .editorconfig # 编辑器IDE的相关配置├── .gitignore # 提交到github忽略的内容配置├── .postcssrc.js # css的处理配置postcssrc├── index.html # index html模版├── package.json # 相关的执行命令和依赖配置└── README.md # 项目的说明文件 ⚠️ 项目重点在src文件夹内 在/src/components/Login.vue中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;template&gt; &lt;div id="login"&gt; &lt;div class='login'&gt; &lt;div class='login-title'&gt;简单模拟登录&lt;/div&gt; &lt;div class='login-body'&gt; &lt;div class='hint' v-show='hintFlag'&gt;输入的文字不能为空&lt;/div&gt; &lt;input placeholder='请输入任意文字...' type='text' v-model='loginTxt'/&gt; &lt;div class="btn" @click='login'&gt;登录&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Login', data () &#123; return &#123; hintFlag: false, loginTxt: '' &#125; &#125;, methods: &#123; login () &#123; var vm = this; if(vm.loginTxt.trim()=='')&#123; vm.hintFlag = true; &#125;else&#123; // 进入todo的页面 vm.hintFlag = false; // 触发获取登录名 vm.$store.dispatch('createUsername',vm.loginTxt); vm.$router.push('/todo'); &#125; &#125; &#125;, watch:&#123; loginTxt(curVal)&#123; var vm = this; if(curVal.trim()=='')&#123; vm.hintFlag = true; &#125;else&#123; vm.hintFlag = false; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped lang='less'&gt; #login&#123; margin-top: 100px; .login&#123; width: 400px; margin: 0 auto; &amp;-title&#123; color: #999; font-size: 22px; text-align: center; margin-bottom: 20px; &#125; &amp;-body&#123; width: 360px; padding: 40px 20px 60px 20px; background: #ededed; input&#123; width: 100%; display: block; height: 40px; text-indent: 10px; &#125; .btn&#123; width: 100%; text-align: center; height: 40px; line-height: 40px; background: #09c7d1; color: #fff; margin-top: 20px; cursor: pointer; &#125; .hint&#123; color: red; font-size: 12px; text-align: center; padding-bottom: 10px; &#125; &#125; &#125; &#125;&lt;/style&gt; 在上面的组件中，自己原封不动的将里面的代码复制过来了，你应该可以看出，这个.vue文件中结合了三块的东西，分别是html的模版、javascript代码和运用less预处理器编写的css代码。 在/src/components/Todo.vue组件的结构依旧是这样: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div id="todo"&gt; &lt;div class='username'&gt;欢迎您！&lt;span&gt;&#123;&#123;username&#125;&#125;&lt;/span&gt;&lt;/div&gt; &lt;div class="main"&gt; &lt;div class="input"&gt; &lt;input placeholder='请输入要做的事情...' type='text' v-model='eventTxt'/&gt; &lt;button @click="addEvent"&gt;增加&lt;/button&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'ToDo', data () &#123; return &#123; noDataFlag: true, ... &#125; &#125;, created()&#123; var vm = this; if(vm.username == '')&#123; vm.$router.push('/'); &#125; &#125;, computed: &#123; username()&#123; return this.$store.getters.username; &#125;, ... &#125;, methods: &#123; delEvent (id) &#123; this.$store.dispatch('delEvent',id); &#125;, ... &#125;, watch:&#123; ... &#125;&#125;&lt;/script&gt;&lt;style scoped lang='less'&gt; #todo&#123; margin-top: 100px; ... &#125;&lt;/style&gt; 在路由的文件中，因为知识涉及了两个页面的路由跳转，这里也全贴出来吧 – 123456789101112131415161718192021import Vue from 'vue'import Router from 'vue-router'import Login from '@/components/Login'import ToDo from '@/components/ToDo'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'Login', component: Login &#125;, &#123; path: '/todo', name: 'ToDo', component: ToDo &#125; ]&#125;) 关于store，这是一个重点，我打算详细说啦。首先当然得从整个store的入口文件讲起啦。在store/index.js中，我是这样引用的 ： 1234567891011121314151617181920import Vue from 'vue' // 引入vue依赖import Vuex from 'Vuex' // 引入vuex依赖import state from './state' // 引入根状态import * as actions from './actions' // 引入根actionsimport mutations from './mutations' // 引入根mutationsimport todo from './modules/todo/index' // 引入todo模块Vue.use(Vuex) // 引入vuex// 初始化storeexport default new Vuex.Store(&#123; state, actions, mutations, modules:&#123; todo &#125;&#125;) 在根的store的mutation-types.js文件中，管理着整个项目的状态管理函数 –&gt; 包括创建用户名、添加要做的事情、删除创建的事情、显示事件的状态(全部，已经做，没有做)和标记事件(已经做的事件标记为未做，未做的事件标记为已经做)。代码展示如下 ： 12345678export const CREATE_USERNAME = 'CREATE_USERNAME' // 创建用户名export const ADD_EVENT = 'ADD_EVENT' // 添加事件export const DEL_EVENT = 'DEL_EVENT' // 删除事件export const ALL_EVENT = 'ALL_EVENT' // 全部事件export const UNDO_EVENT = 'UNDO_EVENT' // 没做事件export const DONE_EVENT = 'DONE_EVENT' // 已做事件export const MARK_UNDONE = 'MARK_UNDONE' // 标记为未做export const MARK_DONE = 'MARK_DONE' // 标记为已做 store/state.js的作用在你听完store/todo/state.js的讲解后你应该会明白。在模块todo的state中，自己定义了此模块的相关的数据结构，如下： 1234567891011121314export default &#123; // 事件列表 list:[ // &#123; // id: 0, 相关的id // content:'', // 事件的内容 // flag: 1 // 是否完成,1是完成，0是未完成 // &#125; ], allList:[], increase: 0, total: 0, done: 0&#125; 定义的这些数据结构，你可以说是状态吧，是为了给mutation和getters进行操作。对了，你也许注意到了store根目录中没有getters.js文件。因为，这是分散模块管理项目，为什么还需要呢，如果你想保留，你可以自己新建一个，按照自己的习惯进行管理项目呗。 上个段落以及前面某部分内容已经谈及了mutations的作用，本项目中使用mutation就是为了改变自己在todo/state.js定义的状态，比如改变allList:[]： 12345678910111213141516import * as types from '../../mutation-types'export default &#123; // 添加事件 [types.ADD_EVENT] (state,data)&#123; var obj = &#123; id: state.increase++, content: data, flag: 0 &#125; state.allList.push(obj); state.list = state.allList; state.total = state.allList.length; &#125;, ...&#125; 而todo/getter.js就是为了将vuex中的状态获取，方便显示在页面的啦，在本项目中，自己超级简单的使用了下： 123456789export default &#123; list (state,getters,rootState) &#123; return state.list; &#125;, username (state,getters,rootState) &#123; return rootState.username; &#125;, ...&#125; 最后一个是关于todo/actions.js，这是页面中的用户的事件去发送事件，使得产生mutations去改变状态(state.js)，最终使得页面展示的内容(getters)发生改变。这里以一个派遣添加事件为例子 : 12345import * as types from '../../mutation-types'export const addEvent = (&#123;commit,state,rootState&#125;,query) =&gt; &#123; commit(types.ADD_EVENT,query);&#125; 嗯，整篇文章都说整个store是挂载在根组件上的，那么是在哪里呢？答案就是src/main.js文件啦，文件内的代码如下 : 123456789101112131415import Vue from 'vue'import App from './App'import router from './router'import store from './store'Vue.config.productionTip = falsenew Vue(&#123; el: '#app', router, store, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 最终的效果好吧，自己利用了一个下午搭建项目并简单思考了相关的逻辑，简单实现项目，其最终的效果如下gif动图啦 : 嗯，项目是不是很简单，所以就不放源码上去了 😂 。其实自己觉得源码实现不够严谨啦，毕竟只是花了短短一个下午和晚上从设计到实现… 逃：） 参考内容vuex官网 （ 完 @~@ ）]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二届前端体验大会 -- 本固枝荣]]></title>
    <url>%2F2017%2F12%2F24%2F2ndTencent-frontend-meeting%2F</url>
    <content type="text"><![CDATA[第二届前端体验大会，是至今为止，我参加的最棒的一次前端体验大会，不枉我从广州过去深圳啊。目前只参加过一次大型的前端体验大会 😝。在一天的时间里面，自己收获到了很多的东西。作为一个非典型的程序员，杂七杂八的就不谈了，还是谈技术来得简单粗暴一点。 开场白本会议的主题是本固枝荣，开场白的彪叔已经很好的解释了主题：基础牢固，才能更好的玩转前端（概括起来就这样吧）。在开场白的时候，彪叔介绍的前端的前三年的调查报告，着实让我一惊 -&gt; 原来前端的市场是酱紫啊，作为一个涉水不深的前端菜鸡来说，还是可以定m个小目标的。 一个UI的自我修养腾讯的QQ音乐的设计天团研发经理主要是针对一个UI开发的自我修养来讲述了前端开发人员需要有发现问题，定位问题，解决问题的能力（概括不到位的话，大佬不要怂我 😂 ）。 感知性能优化在众多嘉宾分享的话题中，我最喜欢的就是潇滨前辈讲解的感知性能优化的话题。在前端开发中，我们需要对自己做出来的产品进行优化，怎么进行优化呢，前辈经过三个层次进行说明：资源感知，代码感知和用户感知。这里也推荐雅虎的七个领域的35条优化原则，请戳传送门资源感知我们写的页面的img,js,html,css等都可以成为资源，我们在优化的时候，需要考虑到控制请求，控制资源的大小，控制缓存等。 感知代码在代码的层面，我们可以通过对请求加载数进行延迟或者按需加载来控制代码。一个产品的首页首次渲染很是重要，在代码层面对样式的前置，js后置等进行优化。 用户感知用户在产品中起到至关重要的作用，也许你的产品在电脑的模拟器上没有什么问题。但是是真的没有问题吗？这就需要站到用户的角度进行思考，如果用户的使用的网络是3g的怎么样等等。 整个感知优化的流程，可以用大佬ppt里面的图片进行总结，如下: 那些年我们所遗忘的XSS黑魔法至于前端方面的安全，志龙前辈演示了xss的黑魔法，自己一脸懵逼，因为接触前端安全这一块一直是个梗。在xss黑魔法中，哪里有用户输入，哪里就可能有前端的安全漏洞，当然，前辈不仅演示了如何攻击，还演示了如何防攻啦。自己很想加入他们的团队，貌似能力不足啊… 前端监控系统监控系统是幸福生活的保障。一个产品的异常都需要进行监控，这些就是问题的来源。监控系统对异常进行监控，进行错误信息自动上报，性能数据自动上报，进行数据的打点，最终显示出系列告警的错误日志数据。郑超前辈指出人是监控系统的关键组成部分。 跨界-成长：非典型程序员之路某磊前辈作为全场嘉宾中唯一一个文科生（自己猜的）出身的程序猿。在会场上分享了自己如何在钱途[逃：)]和热情的支撑下成为前端大神的经历。很喜欢他会场的一句话：你生命中的每个点（经历的事），在你生命的某一个时刻终将连成线。 作为一个非典型的程序猿，你的世界不应该只有代码和办公室，你应该到处走走。美妙的代码只是你生命中的一部分，生命中其他美妙的部分等待着你去发现、挖掘。嗯，我也是一个非典型的程序猿，打代码仅仅是人生乐趣的一部分。 😊 高性能React替代方案现在前端比较热门的框架有三个，分别是react、vue和angular。京东的某澈前辈对三种框架进行了比较选择了react。然后基于他们京东的产品和业务，对react进行了改写，支持IE8版本等，他们改写react的github仓库请戳传送门。 每个公司的情况不同，我们的大佬就选择了vue。经过一年的vue的锻炼，自己貌似已经把react知识点忘记了。但愿react别来个变脸 -&gt; 改协议了… 如何开发知晓榜工具类第一的小程序最后一位分享嘉宾是某博前辈讲的微信小程序。因为自己没开发过微信小程序，听不懂他在讲啥（我的锅），全程感觉就是围绕websocket和使用场景规模来讲。 如果需要学习微信小程序的时候只能靠后期了，也许找的资源比他讲解的还好(幻想中…) 结语会议的结尾，本会议的负责任某帅讲了自己的进入腾讯的幸酸的经历。嗯，是半开玩笑的那种。然后就是很形式的会议的闭幕的发言啦，感觉可以忽略。如果让自己用一个字还总结这次会议的话，那就是棒；两个字的话，那就是很棒；三个字的话，那就是非常棒。感谢主办方的精彩呈现 👏 其他作为一个非典型的程序猿，好吧，我说下参加本次会议的其他点吧： 嗯，主持人很会带气氛的说，特别是男的主持人(会场一对主持人，男帅女靓)，怂一下主持人 -&gt; 会场总说自己穷，穷的人在这里还没说话呢 😢 腾讯的工作环境真是超级棒的，能在这里工作是多么的幸福呢，希望自己有机会进入腾讯工作吧 腾讯的饭堂很赞，举办方免费开了会议还提供免费的午餐，真是有心了 会议的抽奖礼品很实在哦，大奖是服务器的优惠卷（价值9000）。好吧，我也很幸运，中了幸运奖–貌似是布娃娃吧，会后忘记自己还中奖来着，直接离场忘拿了 声明 本文的截图来自嘉宾的演讲稿 本文内容仅代表自己参加本固枝荣会议的观点，不喜勿喷 文中使用了嘉宾的名字，如果某嘉宾觉得本人使用不妥，可以文末留言，我将打码 😝 一张会议的合影图结束本文（原图太大，放上压缩后的图片，原图可以私信我，我还保留的话就发你了）]]></content>
      <categories>
        <category>技术交流</category>
      </categories>
      <tags>
        <tag>会议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的学习汇总]]></title>
    <url>%2F2017%2F12%2F13%2Fgit-learning%2F</url>
    <content type="text"><![CDATA[这篇博文是自己在学习git过程中的思考总结。本文仅仅代表个人的看法，如有不妥地方还请本文文末留言。 😊 GIT是什么GIT是一个免费并且开源的分布式版本控制系统，能够高速有效的处理或小或大的项目。(以上的话是自己翻译github官网) 至今，自己用过了window系统的TortoiseSVN, mac系统的CornerStone,最近的大半年也在用GIT(主要管理自己的github项目)。比较下来，还是GIT优势比较明显，虽然目前为止没有用GIT开发过团队项目。 GIT跨平台 GIT可以在不同的操作系统中使用。也许你注意到了，我在window上和mac系统上工作的时候是使用两个不同的svn。如果我在linux上工作会不会又是一个呢。 GIT是分布式版本控制系统,而svn是集中式版本控制系统 集中式版本控制系统是集中放在中央服务器上面的，而团队的人需要从中央服务器上面拉取最新的代码，然后进行开发，最后推送到中央服务器上面，就像串联的电路。而分布式版本控制系统没有中央服务器，团队的每个人的电脑就是一个完整的版本库，就好像并联的电路（自我理解）。 集中式版本控制系统必须联网才能工作，如果是在局域网内还好，带宽足够大，速度足够快，但是遇到网速慢的话，那心里就一万个羊驼🐑在蹦腾了。 集中式版本控制系统安全性比较低，如果中央系统崩溃了，那就有点悲催了。当然你不嫌麻烦，可以定期备份的啦。而分布式中央系统就比较安全，团队的每个成员的电脑就是一个完整的版本库。如果其中一个坏掉了，你可以从团队另外一个的人员电脑那里拷贝一份就行了。对了，GIT也会有一台中央的机子，主要是为了方便团队的交流，它是可以不存在的。 GIT安装GIT支持不同的系统，看者可以在链接https://git-scm.com/downloads中，找到和自己电脑系统匹配的GIT版本，下载安装包后根据提示进行安装。当然，GIT还提供图形界面管理工具，看者也可以在链接中下载GUI Clients，如下图所示–根据提示安装完成后，要验证是否安装成功。看者可打开命令行工具，输入git --version命令,如果安装成功，控制台输出安装的版本号（当然，安装前就应该输入git –version查看是否安装了git），我这里安装的GIT版本是2.10.0。 GIT配置GIT在使用前，需要进行相关的配置。每台计算机上面只需要配置一次，程序升级的时候会保留配置信息。当然，看者可以在任何时候再次通过运行命令行来修改它们。 用户信息设置GIT的用户名称和邮件地址，这个很重要，因为每个GIT的提交都会使用这些信息，并且它会写入到每一次的提交中。你可以在自己的仓库中使用git log，控制台上面显示的每次的提交都有Author字段，它的值就是用户名称 &lt;邮件地址&gt;。方便查看某次的提交的负责人是谁。 12$ git config --global user.name "你的用户名"$ git config --global user.email 你的邮箱地址 ⚠️ GIT一般和github配合使用，看者应该设置用户名称为你的github用户名。当然，还有和gitlab等配合使用… ⚠️ 如果配置中使用了--global选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，GIT都会使用这些信息。但是，当你想针对特定项目使用不同的用户名称与邮件地址的时候，可以在那个仓库目录下运行不使用global选项的命令来配置。 检查配置信息通过git config --list命令可以列出所有GIT能找到的配置。如下：（我的git版本为2.10.0） 12345678...user.name=reng99user.email=1837895991@qq.comcolor.ui=truecore.repositoryformatversion=0core.filemode=truecore.bare=false... 当然，你可以通过git config &lt;key&gt;来检查GIT的某一项配置。比如$ git config user.name。 帮助中心在使用GIT的时候，遇到问题寻求帮助的时候，可以运行git help或git --help或git命令来查看。在控制台上会展示相关的帮助啦。 123456789101112usage: ...start a working area (see also: git help tutorial) ...work on the current change (see also: git help everyday) ...examine the history and state (see alse: git help revisions) ...grow,mark and tweak your common history ...collaborate (see also: git help workflows) ... 更加详细的内容，请点击传送门 创建版本库版本库又名仓库(repository)，可以理解成一个目录，这个目录里面所有文件都可以被GIT管理起来，每个文件的修改、删除，GIT都能跟踪，以便任何时刻都能可以追踪历史，或者在将来某个时刻可以还原。 创建一个版本库，首先得选择一个存放目录的地方，我这里选择了桌面，并且创建一个空的目录。 12345$ cd desktop$ mkdir -p learngit$ cd learngit$ pwd/Users/reng/desktop/learngit mkdir -p dirnanme是创建一个子目录，这里的-p确保目录的名称存在，如果目录不存在的就新建一个，如果你确定目录不存在，直接使用mkdir dirname就可以了。pwd(Print Working Directory)是显示当前目录的整个路径名。 然后，通过命令行git init，将创建的目录变成GIT可以管理的仓库: 12$ git init Initialized empty Git repository in /Users/reng/Desktop/learngit/.git/ 初始化好仓库后就可以愉快的玩耍了，但是，得先来了解下GIT整个工作流程先。 GIT工作流程为了更好的学习，自己用Axure RP 8粗略的画了下流程图，如下– 本地仓库(repo)包含工作区和版本库,那么什么是工作区和版本库呢？基本的流程又是什么呢？ 工作区和版本库我们新建一个仓库，就像我们新建的learngit仓库，现在在里面添加一个文件README.md，用sublime打开learngit目录。此时会出现如下图的情况(当然你设置了其他东西例外)–如上图，出现的内容就是工作区（ 电脑上能看到的此目录下的内容），这里工作区只有README.md一个文件。工作区有一个隐藏的目录.git，这个不算工作区，而是GIT的版本库。版本库又包括暂存区和GIT仓库。暂存区是一个文件，保存了下次将提交的文件列表信息，而GIT仓库目录是GIT用来保存项目的元数据和对象数据库的地方。这是GIT中最重要的部分，从其他计算机克隆仓库的时候，拷贝的就是这里的数据。当执行git add .或者git add path/to/filename的时候，文件从工作区转到暂存区；执行git commit -m&quot;here is the message described the file you add&quot;的时候,文件从缓存区添加到GIT仓库。 基本的工作流基本的GIT工作流可以简单总结如下– 在工作区目录中修改文件 暂存区中暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到GIT仓库目录 时光机穿梭到目前为止，在自己创建的本地仓库–learngit中已经初具形态了。进入learngit，执行ls，可看到目前仓库中已有的文件README.md。 12345$ cd desktop/learngit$ lsREADME.md$ cat README.md## content 上面展示了本地learngit内的相关的内容。运行下git status查看现在的状态。 123$ git statusOn branch masternothing to commit, working tree clean 这时候会提示没有内容可以提交，工作区是干净的。因为我之前已经提交(git commit)过了。上面还提示了目前是位于主分支上面，GIT在初始化(git init)的时候会自动创建一个HEAD指针指向默认master分支，也只有一个分支，看者可以通过git branch查看。 现在，在README.md上添加一些内容。 123## content### first change 此刻再通过git status查看当前状态。 123456789$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a") 这时候显示出一堆的东西，告诉我们现在是位于主分支上面，然后告诉我们修改的文件啊，可以使用的命令进行下一步的操纵。那么我们来进行下一步的操作了，git add . 或者 git add README.md将修改的文件添加到暂存区域。 1234567$ git add .$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md 对了，有时候需要在添加的之前（执行git add . 或者 git add path/to/filename）的时候，需要看下修改了哪些内容可以执行下git diff。那么，现在先回退到修改的前一个版本。 12345678$ git reset HEAD README.mdUnstaged changes after reset:M README.md$ git checkout -- README.md$ lsREADME.md$ cat README.md## content 回退正确，现在像上次那样添加内容### first change，然后执行命令git diff来查看更改的内容。 123456789101112$ git diffdiff --git a/README.md b/README.mdindex 75759ec..0bc52b9 100644--- a/README.md+++ b/README.md@@ -1 +1,3 @@-## content\ No newline at end of file+## content++### first change\ No newline at end of file 现在就显示了修改前的内容–-前为修改前的内容，和修改后的内容–+前修改后的内容。查看完之后，觉得没有问题了，就可以进行添加(git add)，提交(git commit)。当然，一般不常用git diff的，因为自己修改的东西自己心里总有点数吧，可能合作中团队的其他人需要查看文件前后的不同点就需要用到git diff啦。 版本回退为了方便讲解下版本回退，我先将上面添加的### first change提交以下–git add . &amp;&amp; git commit -m &quot;add first change&quot;。下面通过git log就可以查看自己提交的记录了。 1234567891011121314151617181920212223$ git logcommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md $ git add . &amp;&amp; git commit -m "add first change"[master 0ac49ba] add first change 1 file changed, 3 insertions(+), 1 deletion(-) $ git logcommit 0ac49bae6ab55df9c05d0770de347665a2568f31Author: reng99 &lt;1837895991@qq.com&gt;Date: Mon Dec 18 15:26:06 2017 +0800 add first changecommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md 在上面中，自己先执行了git log来显示提交的日志，显示只有一条，然后执行了add和commit的命令，打印的内容是现实主分支、commit的id、commit的信息、多少个文件的更改、多少个插入以及多少个删除。之后再次执行git log打印日志，显示了两次提交。⚠️ 注意：当提交(commit)的次数较多之后，控制台会显示不下（最多现实4条）那么多的条数，可以通过按键盘的向上或向下键查看日志的内容，需要退出查看日志命令的话，在英文输入法的状态按下q，意思就是quit(退出)。 版本的回退就是改变HEAD指针的指向。通过git reset --hard HEAD^返回上一个版本，通过git reset --hard HEAD^^返回上上个版本…由此推论，往上100个版本的话就是100个^，当然，这样你数到明天也未必数得正确，所以写成git reset --hard HEAD~100。另外一种是，你知道提交的id，例如commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67的前7位就是commit的id(5c2639e)，执行git reset --hard 5c2639e就回到此版本啦。 123456789101112$ reng$ git reset --hard HEAD^HEAD is now at 5c2639e init README.md$ git logcommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md$ lsREADME.md$ cat README.md## content 现在你已经回到了最初的版本，这里演示的是通过HEAD，你也可以通过commit id来实现的。执行上面的代码后，README.md文件里面只有一### content文字内容,但是过了段时间后，你想恢复到原先的版本，通过git log命令行，控制台显示的以前的信息，通过它找不到回退前的commit id，怎么办？GIT提供一个git reflog显示提交的历史记录，在那里可以查看提交的id、HEAD的指针历史和操作的信息记录。下面演示回退到最新的版本（也就是commit -m “add first change”）– 123456789101112131415161718$ git logcommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md$ git reflog5c2639e HEAD@&#123;0&#125;: reset: moving to HEAD^0ac49ba HEAD@&#123;1&#125;: commit: add first change5c2639e HEAD@&#123;2&#125;: commit (initial): init README.md$ git reset --hard 0ac49baHEAD is now at 0ac49ba add first change$ lsREADME.md$ cat README.md## content### first 现在又回到了最新的版本，又能够愉快的玩耍了。😊 管理修改GIT比其他版本控制系统设计优秀，其中一点是–GIT跟踪并管理的是修改，而非文件。 下面在README.md内添加信息### second change。之后看下变化后的文件的状态和差异等。 123456789101112131415161718192021222324$ lsREADME.md$ cat README.md## content### first change#### second change$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")$ git add README.md$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md 此时，对README.md进行第三次的修改，添加内容### third change。 123456789101112131415161718192021222324252627282930313233$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.md$ cat README.md## content### first change#### second change### third change$ git commit -m "test file modify"[master 18f86ba] test file modify 1 file changed, 3 insertions(+), 1 deletion(-)$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a") 上面的演示流程是这样的第一次修改(#### second change) -&gt; git add -&gt; 第二次修改(### third change) -&gt; git commit。但是最后查看状态的时候(git status)，第二次的修改并没有被提交上去。因为GIT管理的是修改，当使用git add命令的时候，在工作区的第一次修改被放入暂存区，准备提交，但是在工作区的第二次修改并没有放入到暂存区，而git commit是将暂存区的修改提交到GIT仓库，所以第二次修改的内容是不会被提交的。这也是说明为什么可以多次添加(git add)，一次提交(git commit)的原因了。 撤销修改文件的撤销修改分成三种情况，一种是修改在工作区的内容，一种是修改在暂存区的内容，另一种是修改在GIT仓库的内容。也许会有看者说，不能修改在远程库中的内容吗？有啊，就是git add-&gt;git commit-&gt;git push将远程仓库的内容覆盖被，不过团队人在克隆远程库下来的时候，还是可以查看到你提交的错误内容的。我们现在只针对本地仓库的三种情况谈下自己的看法– 情况一：撤销工作区的内容 在管理修改中，自己的工作区还是没有提交，此时想放弃当前工作区的编辑内容执行git checkout -- file。接着上面的内容，我这里的工作区内有的内容是### third change，现在我要放弃第三次修改，只要执行git checkout -- README.md就可以了。 1234567891011121314151617181920212223242526272829$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")$ lsREADME.md$ cat README.md## content### first change#### second change### third change$ git checkout -- README.md$ cat README.md## content### first change#### second change$ git statusOn branch masternothing to commit, working tree clean 情况二：撤销暂存区的内容 当你不但改乱了工作区的某个文件的内容，还添加(git add)到了暂存区时，想丢弃修改，那么得分两步来撤销文件。先是通过git reset HEAD file，将暂存区的文件退回到工作区，然后通过git checkout -- file放弃修改改文件的内容。为了方便演示，我这里的暂存区没什么内容，所以添加内容### tentative content并将它添加到缓存区。之后，演示将缓存区的内容撤回– 1234567891011121314151617181920212223242526272829$ cat README.md## content### first change#### second change### tentative content$ git add .$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md$ git reset HEAD README.mdUnstaged changes after reset:M README.md$ git checkout -- README.md$ cat README.md## content### first change#### second change$ git statusOn branch masternothing to commit, working tree clean 情况三：撤销GIT仓库的内容 如果你不仅添加(git add)了内容到暂存区并且提交(git commit)了内容到GIT仓库中了。你需要撤销上一次的内容，也就是要回退到上一个版本，执行git reset --hard HEAD^就可以啦，详细的内容查看版本回退。如下– 123456789101112131415$ git statusOn branch masternothing to commit, working tree clean$ cat README.md## content### first change#### second change$ git reset --hard HEAD^HEAD is now at 0ac49ba add first change$ cat READMEmd## content### first change 远程仓库远程仓库的使用能够提高你和团队的工作效率，无论何时何地，团队的人员都可以在联网的情况下将代码进行拉取，修改和更新。因为我是使用github来管理项目的，所以我的远程仓库是放在github里面。这里默认看者已经安装了github，当然也可以用码云、gitlab等。 本地库添加到远程库这点很容易，登录自己注册的github，如果打不开，请开下VPN。进入自己的首页(https://github.com/username)，点击`+`号创建(new repository)一个名为learngit的仓库(注意哦⚠️ 名称是本地仓库已经初始化过的，我这里本地有个同名初始化的learngit仓库)，其他的字段自选来填写。点击Create repository创建此远程仓库。紧接着就是进行本地仓库和远程仓库的关联啦，github很友好的提示了你怎么进行一个远程仓库的关联。 现在按照上图来关联下远程仓库。 12345678910$ git remote add origin https://github.com/reng99/learngit.git$ git push -u origin masterCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (6/6), 456 bytes | 0 bytes/s, done.Total 6 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit.git * [new branch] master -&gt; masterBranch master set up to track remote branch master from origin. 注意⚠️ 第一次向远程仓库（关联）push的时候是$ git push -u origin master，不能忽略-u，以后的push不用带-u。至此，打开你的github的相关的仓库就可以看到添加了README.md文件，我这里地址是https://github.com/reng99/learngit，因为我是使用markdown语法写的，控制台显示的内容和仓库的显示内容有所区别啦。(⚠️ 后期我将learngit仓库删除啦，所以你访问链接是找不到这个仓库的，毕竟不想放一个没什么内容的仓库在我的github上)。 远程库克隆到本地从远程仓库克隆东西到本地同样很简单，只需要进入你想克隆的仓库，将仓库的url复制下来（当然你也可以复制window.location.href的内容），运行git clone address。现在我将本地桌面的learngit的仓库删除，然后从远程将learngit克隆到本地。 12345678910$ cd desktop$ rm -rf learngit$ find learngitfind: learngit: No such file or directory$ git clone https://github.com/reng99/learngitCloning into 'learngit'...remote: Counting objects: 6, done.remote: Compressing objects: 100% (2/2), done.remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0Unpacking objects: 100% (6/6), done. 成功将gitlearn从远程克隆下来，接下来又可以愉快的玩耍啦。 分支管理分支管理允许创建另一条线/方向上开发，能够让你在不影响他人工作的情况下，正常的工作。当在自己创建的分支中完成自己的功过后，合并到主分支就行了(git init初始化的时候已经默认创建了master主分支)。一般团队的合作是不在主分支上进行的，个人项目除外（个人理解）。 创建分支当前learngit仓库上只有一个分支，那就是master分支，看者可以通过git branch命令来查看当前的分支，git branch branchName命令来创建一个新的分支，我这里创建的是dev分支。 1234567$ cd desktop/learngit$ git branch* master$ git branch dev$ git branch dev* master 现在已经创建了dev分支，有两个分支了，分支前面带有一个星号的分支说明是当前的正在工作的分区。执行上面的分支后，可以简单的画下现在的情况了，有个HEAD指针指向主分支的最新点，刚才新创建的dev分支我这里默认是一个dev的指针指向了dev分支的最新点。 1234567.. HEAD指针. │├────────*master└────────dev │ dev指针 切换分支我们一般是很少在主分支进行工作的，所以在创建出新的分支之后，我们就切换到新的分支进行相关的工作。可以通过git checkout branchName切换到已经存在的分支工作，通过分支前面的*可查看目前位于哪个分支内。现在我切换到创建的dev分支。 12345678$ git branch dev* master$ git checkout devSwitched to branch 'dev'$ git branch* dev master 合并分支在创建好分支后，我们在新的分支上工作完成后，就需要往主分支上进行合并啦。我修改了分支dev上的README.md的内容，就是添加文字### new branch content。合并分支可以分成两个合并的方式，一种是本地合并到materz主分支之后，推送(push)到远程库，一种是直接将分支推送到远程库，在远程库进行合并。 本地合并推送 在合并分支前，需要切换到要合并到哪个分支(一般是master主分支)，通过git merge branchName将需要的合并的分支合并到当前分支，我是将dev分支合并到master分支。 123456789101112131415161718192021$ git branch* dev master$ git checkout masterM README.mdSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ git merge dev$ Already up-to-date.$ git add .$ git commit -m "merge dev branch"[master d705e73] merge dev branch 1 file changed, 3 insertions(+), 1 deletion(-)$ git push origin masterCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 282 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit 0ac49ba..d705e73 master -&gt; master 合并之后,此时，HEAD指针就指向了dev指针，也就是两者同时指向了master主分支的最新处。具体的内容参考传送门 1234567.. . ├────────*master└────────dev │ dev指针 ── HEAD指针 远程库推送合并 远程库内合并的话，要先将dev的分支推送到远程库，然后在远程库进行合并。我这里在dev分支上添加了### add new branch content into again然后demo演示推送(git push origin dev)以及合并。 1234567891011121314151617$ git branch dev* master$ git checkout devSwitched to branch 'dev'$ git add .$ git commit -m "add dev branch commit again"[dev dc817c4] add dev branch commit again 1 file changed, 3 insertions(+), 1 deletion(-)$ git push origin devCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 300 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit * [new branch] dev -&gt; dev 接下来就是进入我的远程learngit仓库进行合并，你会看到下面图示的提示。点击Compare &amp;&amp; pull request，然后写点相关的comment（选填），点击Create pull request。之后在绿色勾的提示下Merge pull request，紧接着点击Confirm merge按钮确定合并此分支，这时候返回主分支就可以看到dev内合并的内容了(后期我改动了dev的内容)。看者如果看得不明白，自己上手尝试一下呗！ 完成后，你会看到learngit仓库的Pull requests量为1，branches量为2。你可以点击进入分支，在ALL branches里面查看分支的具体内容。 删除分支在创建了分支，然后将分支的内容合并到主分支后，分支的使命就完成了，你就可以将分支删除了，这里的删除个人认为可以是两种，一种是本地仓库的分支删除，一种是远程仓库的分支的删除。当然啦，留着分支也没啥，可以留着呗，自己认为有点碍眼。 本地分支的删除 在本地的learngit的目录下，执行命令行git branch -D branchName就可以删除了。我这里删除的是dev分支。注意⚠️ ，删除的分支不应该是当前工作的分支，需要切换到其他分支，我这里切换的是master分支，毕竟我只有两个分支呢。 123456789101112131415$ git branch* dev master$ git branch -D deverror: Cannot delete branch 'dev' checked out at '/Users/reng/desktop/learngit'$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ git branch dev* master$ git branch -D devDeleted branch dev (was dc817c4).$ git branch* master 远程库分支的删除 删除远程库的分支，只要执行git push origin :branchName命令就行了。现在我要删除我远程库中的dev分支，执行git push origin :dev。 123$ git push origin :devTo https://github.com/reng99/learngit - [deleted] dev 此时，打开我的远程库learngit，发现之前的Pull requests量为0，branch量为1。 重命名分支通过git branch -m oldBranchName newBranchName来重命名分支。我这里没有分支了，现在创建一个reng分支，然后将它重命名为dev分支。 12345678910$ git branch* master$ git branch reng$ git branch* master reng$ git branch -m reng dev$ git branch dev* master 解决冲突在我们开发的时候，不知道分支和分支之间的进度情况是什么，难免会产生冲突。当产生冲突的时候，就得将冲突的内容更正，然后提交。为了方便演示，我将本地的learngit删除，重新拉取远程的gitlearn仓库(因为我不知道我之前在本地仓库做的修改是啥，对了，我将远程的分支删除了，只剩下master主分支)。克隆下来后，如果还存在本地分支，也将它删除，之后我将在master和dev分支中重新填充里面的README.md的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$ cd desktop$ git clone https://github.com/reng99/learngit.gitCloning into 'learngit'...remote: Counting objects: 43, done.remote: Compressing objects: 100% (17/17), done.remote: Total 43 (delta 4), reused 38 (delta 1), pack-reused 0Unpacking objects: 100% (43/43), done.$ cd learngit$ git branch* master$ lsREADME.md$ cat README.md## master branch content$ git add .$ git commit -m "add master branch content"[master 1cfa0aa] add master branch content 1 file changed, 1 insertion(+), 1 deletion(-)$ git push origin masterCounting objects: 3, done.Writing objects: 100% (3/3), 271 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit.git d2f936f..1cfa0aa master -&gt; master$ git branch dev$ git checkout devSwitched to branch 'dev'$ cat README.md## master branch content### dev branch content$ git add .$ git commit -m "add dev branch content"[dev 80faf6d] add dev branch content 1 file changed, 2 insertions(+)$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ cat README.md## master content### new master branch content$ git add .$ git commit -m "change master content"[master ec18715] change master content 1 file changed, 3 insertions(+), 1 deletion(-)$ git merge devAuto-merging README.mdCONFLICT (content): Merge conflict in README.mdAutomatic merge failed; fix conflicts and then commit the result. README.md文件中冲突内容– 123456789&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD (当前更改)## master content### new master branch content=======## master branch content### dev branch content&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev (传入更改) 手动修改了README.md文件中冲突的内容– 123## master branch content### new master branch content### dev branch content 然后命令行执行– 12345678910111213141516171819202122232425262728$ git add .$ git commit -m "fix confict content"[master dd848b4] fix confict content$ git log --graph* commit 980788b7690d8bcf14610072fc072460bee7e9f1|\ Merge: c49d09e 2929dca| | Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Thu Dec 21 11:14:10 2017 +0800| | | | fix confict content| | | * commit 2929dca91ef8f493adba7744cdad19656538334f| | Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Thu Dec 21 11:11:49 2017 +0800| | | | add dev branch content| | * | commit c49d09e33e7098d67b59c845d18e9c6f8a8f4fea|/ Author: reng99 &lt;1837895991@qq.com&gt;| Date: Thu Dec 21 11:12:50 2017 +0800| | change master content| * commit b07f0be8280e4e437cccf2a3f8fac6beef03ff41| Author: reng99 &lt;1837895991@qq.com&gt;| Date: Thu Dec 21 11:10:51 2017 +0800| : 上面操作过程是，我先从远程库中克隆learngit仓库到本地，目前的本地learngit的分支只有master分支，然后我在master分支的README.md中添加相关的文字(见代码)，接着把它推送到远程库。然后创建并切换dev分支，在README.md文件中添加新内容(见代码)，接着将它提交到GIT仓库。又切换到master分支，修改README.md到内容(见代码)，提交到GIT仓库后开始执行merge命令合并dev分支的内容。此时，产生了冲突，这就需要手动将冲突的内容解决，重新commit到GIT仓库，最后你就可以提交到远程库了(这步我没有演示，也就是git push origin master一行命令行的事情)。最后我还使用git log ----graph打印出整个分支合并图(从下往上看)，方便查看。⚠️ 此时退出git log --graph是书写英文状态按键盘的q键。 说这么多，目的只有一个 –&gt; 产生冲突后，需要手动调整😊 分支管理策略先放上一张分支管理策略图，然后再慢慢讲解相关的内容… 在分支管理中，我们不断的新建分支，开发，合并分支，删除分支的操作。这里需要注意合并分子的操作，之前我们进行分支的时候是直接将dev开发的分支使用git merge dev进行合并，这样有个缺点：我们看不出分支信息。因为在默认情况下，合并分支的时候，GIT是使用了Fast Foward的模式，在这种模式下，删除分支后，会丢掉分支的信息。下面我重新克隆下我远程learngit仓库，然后创建并更改dev分支的信息，使用默认的模式进行合并。 12345678910111213141516171819202122232425262728293031$ git branch* master$ git branch dev$ git checkout devSwitched to branch 'dev'$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content$ git add .$ git commit -m "add new dev contentt"[dev 750e1f1] add new dev content 1 file changed, 1 insertion(+)$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ git merge devUpdating 980788b..750e1f1Fast-forward README.md | 1 + 1 file changed, 1 insertion(+)$ git log --graph* commit 750e1f17854872eed4d6cff8315e404079ecb18f| Author: reng99 &lt;1837895991@qq.com&gt;| Date: Fri Dec 22 10:05:36 2017 +0800| | add new dev content| * commit 980788b7690d8bcf14610072fc072460bee7e9f1... 上面的合并就是将master分支上面的HEAD指向dev指针，如下： 123456789101112131415161718192021222324252627# 记录是从上往下- before merge master * (begin) | | * \ \ * | | * (end) dev - after merge master * (begin) | | * | | * | | * (end) 为了保留分支的情况，保证版本演进的清晰，我们就得使用普通模式合并，也就是在Fast Foward的模式基础上加上--no-ff参数，即git merge --no-ff branchName，不过我们一般加上你合并的相关信息，即git merge --no-ff -m &quot;your msg here&quot; banchName。现在更改dev分支的内容，再进行合并。 123456789101112131415161718192021222324252627282930313233343536$ git checkout devSwitched to branch 'dev'$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content### merge with no-ff$ git add .$ git commit -m "add no-ff mode content"[dev 80b628c] add no-ff mode content 1 file changed, 2 insertions(+), 1 deletion(-)$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 1 commit. (use "git push" to publish your local commits)$ git merge dev --no-ff -m "merge with no-ff" devMerge made by the 'recursive' strategy. README.md | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-)$ git log --graph* commit 98746d93a9b64ea02b8ff1c7f0fa5e915405c0e6|\ Merge: 750e1f1 80b628c| | Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Fri Dec 22 14:39:32 2017 +0800| | | | merge with no-ff| | | * commit 80b628c334618711b77da81fa805ffc246a2cf7d|/ Author: reng99 &lt;1837895991@qq.com&gt;| Date: Fri Dec 22 14:38:17 2017 +0800| | add no-ff mode content| * commit 750e1f17854872eed4d6cff8315e404079ecb18f... 使用--no-ff参数的普通模式合并，会执行正常合并，在master主分支上面会生成一个新的节点，如下（我上面的分支管理策略图里面的合并就是使用了普通的模式）： 12345678910111213141516# 记录是从上往下- --no-ff合并 master * (before) | | * |\ | \ | *dev | | | | | * | / |/ * (after) 我们在开发中，分支管理可以分成master主分支、dev开发分支、feature功能分支、release预发布分支、hotfixes修补bug分支。其中功能分支、预发布分支和修补bug分支可以归为临时分支。临时分支在进行分支的合并之后就可以被删除了。下面就一一讲解自己眼中的各种分支。 主分支master主分支是在你初始化仓库的时候(git init)，自动生成的一个master分支，删除不了的哦（演示待会给）。主分支是有且仅有一个，也是发布上线的分支，团队合作的最终代码都会在master主分支上面体现出来。也许你也注意到了分支管理策略图里面的主分支会被打上TAG的标签，这是为了方便到某个时间段对版本的查找，标签tag的学习总结后面给出。 1234567891011# 记录是从上往下 master | | *(tag 1.0) | | *(tag 1.1) | | *(tag 1.2) 下面代码演示下不能放删除master的情况: 123456$ cd learngit$ git branch dev* master$ git branch -D mastererror: Cannot delete branch 'master' checked out at '/Users/reng/desktop/learngit' 开发分支develop在开发的过程中，项目合作者应该保持自己本地有一个开发环境的分支，在进行分支开发之前，需要进行git pull拉取master主分支的最新内容，或者通过其他的方法。在获取到最新的内容之后才可以进行本地的新功能的开发。在开发完成后将内容merge到主分支之后，不用将dev分支删除，因为你开发的就是在这里进行，何必删除后再新建一个开发环境的分支呢。 接着上面的情况，我目前已经拥有了dev开发分支: 1234$ cd learngit$ git branch dev* master 功能（特性）分支feature一个软件就是一个个功能叠加起来的，在软件的开发中，我们总不能在主分支开发，将主分支搞乱吧。当然，你可以在dev分支中开发，一般新建功能分支来开发，然后功能开发完再合并到dev分支，之后删除功能分支。需要的时候就可以将dev开发分支合并到master主分支，这样就随时保证dev分支功能的完整性。 下面演示功能分支user开发（随便写点内容）的合并（这里也演示了合并到master主分支，跳过了release分支的测试），删除。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364$ git checkout devSwitched to branch 'dev'$ git branch user$ git branch* dev master user$ git checkout userSwitched to branch 'user'$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content### merge with no-ff### function user$ git add .$ git commit -m "function user was acheive"[user 26beda3] function user was acheive 1 file changed, 2 insertions(+), 1 deletion(-)$ git checkout devSwitched to branch 'dev'$ git merge --no-ff -m "merge user feature" userMerge made by the 'recursive' strategy. README.md | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-)$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 3 commits. (use "git push" to publish your local commits)$ git merge --no-ff -m "merge dev branch" devMerge made by the 'recursive' strategy. README.md | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-)$ git log --graph* commit f15a1e9012635fc21e944ab76c4cd4bbd539f82f|\ Merge: 98746d9 0ca83c6| | Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Fri Dec 22 16:35:43 2017 +0800| | | | merge dev branch| | | * commit 0ca83c654df64724743a966f5f0989477e504cbc| |\ Merge: 80b628c 26beda3| | | Author: reng99 &lt;1837895991@qq.com&gt;| | | Date: Fri Dec 22 16:33:27 2017 +0800| | | | | | merge user feature| | | | | * commit 26beda3b8246e047f10ac0461ca11d1a6f132819| |/ Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Fri Dec 22 16:31:41 2017 +0800| | | | function user was acheive| | * | commit 98746d93a9b64ea02b8ff1c7f0fa5e915405c0e6|\ \ Merge: 750e1f1 80b628c| |/ Author: reng99 &lt;1837895991@qq.com&gt;:$ git branch -D userDeleted branch user (was 26beda3).$ git branch dev* master 预发布分支release在进行一系列的功能的开发和合并后，在满足迭代目标的时候，就可以打包送测了。这里就需要一个预发布分支release。预发布分支是指在发布正式版本之前（ 即合并到master分支之前，可查看上面分支管理策略图），需要一个有预发布的版本（可以理解为灰度环境）进行测试。 预发布环境是从dev分支上面分出来的，预发布结束之后，必须合并到dev和master分支上面。这里我就不演示了，跟功能分支差不多，就是合并的时候要合并到dev和master上，这时候dev分支和master的同步的代码，就不需要将dev分支合并到master了。最后将预发布分支删除掉。 修复bug分支 bug/hotfixes在写代码的过程中，由于种种原因 -&gt; 比如功能考虑不周全，版本上线时间有限，产品突然改需求等，我们写的代码就出现一些或大或小的bug或者需要紧急修复。那么我们就可以使用bug分支（其实就是新建一个分支处理bug而已啦，命名随意起的），然后在这个分支上处理编码出现的问题。我在分支管理策略图上面已经展示了一种出现bug的情况 -&gt; 就是在测试发布版本看似没问题的情况下，将release版本整合到master和dev中，这时候火眼精金发现了遗留的一个bug，然后新建一个bug分支处理，再合并到master和dev中，之后将bug分支移除啦。 在开发的过程中，无论咋样都是这样 : 新建bug分支 -&gt; 把分支合并 -&gt; 删除分支，这里的demo就不演示了，可以参考上面的功能（特性）分支feature。 这里需要注意⚠️的一点，当在开发的过程中，开发到一定的程度，需要停下来需改紧急的bug，那么需要停下手头的工作需改bug啦。这时候需要将工作现场储藏(stash功能)起来，等以后回复现场了后接着工作。现在我在原先的gitlearn仓库中README.md文件文末添加### modify content内容来进行演示。 1234567891011121314151617181920212223$ cd desktop$ cd learngit$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content### merge with no-ff$ git statusOn branch devChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")$ git stashSaved working directory and index state WIP on dev: 80b628c add no-ff mode contentHEAD is now at 80b628c add no-ff mode content$ git statusOn branch devnothing to commit, working tree clean 然后过段时间(这里省略修改的演示)，代码已经修改好合并后，需要回到最新的内容区域进行工作，这就需要还原最新的内容了，demo如下： 1234567891011121314$ cd learngit$ git stash liststash@&#123;0&#125;: WIP on dev: 80b628c add no-ff mode content$ git stash popOn branch devChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")Dropped refs/stash@&#123;0&#125; (9e85bcc8435ae38c17db59ddc3cd8401af404827)$ git stash list ⚠️ git stash不仅可以隐藏工作区的内容，也可以隐藏暂存区的内容。git stash list是查看隐藏的列表。git stash pop是将隐藏的内容恢复并删除，git stash pop相当于git stash apply &amp;&amp; git stash drop，这里的git stash apply是恢复隐藏内容，git stash drop是删除隐藏内容。 多人协作简单谈下自己git协作的过程吧。在负责人将搭建好的仓库上传到远程的仓库后（一般是包含了master默认的分支和dev分支），自己将远程仓库克隆到本地，然后在本地的仓库上新建一个dev分支，将远程的dev分支重新拉取下git pull origin dev，开发完成后就可以提交自己的代码到远程的dev分支了，如果提交之前或者之后需要修改bug或者添加新的需求的话，需要新建一个相关的分支并完成开发，将他们合并到本地dev分支后上传到远程dev分支。如果新建的远程仓库中只有master分支，我是这样处理的：依然要在本地新建一个dev分支，然后在完成特定版本的开发后，将分支合并到本地master分支然后再推送到远程master分支，本地的dev分支保留哦。我自己比较偏向于第一种情况。 注意⚠️ 如果master主分支有内容更新的话，而你又在分支上开发，如果要拉取主分支最新的内容，直接git pull origin master就行了。 标签管理发布一个版本前，为了唯一确定时刻的版本，我们通常在版本库中打一个标签(tag)，方便在发布版本以后，可以在某个时刻将某个历史的版本提取出来（因为标签tag也是版本库的一个快照）。 创建标签创建标签是默认在你切换的分支最新提交处创建的。我这里在本地桌面的learngit仓库的master分支上打一个v1.0标签。 1234567891011$ cd desktop/learngit$ git branch* dev master$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ git tag$ git tag v1.0$ git tagv1.0 当然，你可以在非新commit的地方进行标签。这就需要你查找到需要打标签处的commit的id，然后执行git tag tagName commitId。这里我随意找master分支中的commit id进行标签v0.9的标签创建。 123456$ git log --pretty=oneline --abbrev-commitf15a1e9 merge dev branch0ca83c6 merge user feature26beda3 function user was acheive98746d9 merge with no-ff... 现在在commit id为 98746d9处打标签。 1234$ git tag v0.9 98746d9$ git tagv0.9v1.0 操作标签在上面创建标签，我们已经有了标签v0.9 v1.0。有时候我们标签打错了，需要进行删除，那么就得更改啦，运用git tag -d tagName 1234567891011121314151617$ git tag -d v0.9Deleted tag 'v0.9' (was 98746d9)$ git tagv1.0$ git tag v0.8 80b628c -m "version 0.8"$ git tagv0.8v1.0$ git show v0.8$ git show v0.8tag v0.8Tagger: reng99 &lt;1837895991@qq.com&gt;tag v0.8Tagger: reng99 &lt;1837895991@qq.com&gt;Date: Wed Dec 27 16:07:46 2017 +0800version 0.8 在上面的演示中，我删除了v0.9，然后在创建v0.8的时候追加了打标签的信息，之后使用git show tagName查看签名信息。 我们还可以进行分支切换标签，类似于分支的切换，我这里打的两个标签的内容是不同的，我可以通过观察内容的改表来得知时候成功切换标签了。 123456789101112131415161718192021$ git tagv0.8v1.0$ git checkout v1.0HEAD is now at f15a1e9... merge dev branch$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content### merge with no-ff### function user$ git checkout v0.8Previous HEAD position was f15a1e9... merge dev branchHEAD is now at 80b628c... add no-ff mode content$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content### merge with no-ff 在确认好标签后，就可以像远程推送标签了，我这里推送v1.0。 1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit.git * [new tag] v1.0 -&gt; v1.0 上面是使用git push origin tagName推送特定的tag到远程库，但是我们能不能推送全部的tag呢？答案是肯定的，看者可以通过git push origin --tags进行推送。有时候，我们推送了tag标签到远程库中了，现在想删除掉怎么办？这个就略微麻烦点，我们不能像上面提到的删除本地库的标签那样，通过git tag -d tagName那样，而是通过git push origin :refs/tags/tagName，这里不演示，如果看者感兴趣可以自己来把弄一下哦。 参考内容廖雪峰官方网站–Git教程 易百教程–Git教程 git官网 分支管理模型图 Git分支管理策略 - 阮一峰的网络日志 完结 @~@]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桂林阳朔旅游]]></title>
    <url>%2F2017%2F12%2F04%2Ftourist-guiLin-and-yangShuo%2F</url>
    <content type="text"><![CDATA[桂林市区的两江四湖的夜景很美丽，还有桂林市区的一些步行街走起来挺舒服的。然后就是阳朔啦，我喜欢那山里的清新的空气(哈哈哈，不过，我更喜欢家里海边的空气)。在山里面就好像与世隔绝，可能一个人在喧闹的城市呆久了，都会喜欢吧。⚠️ 多图博文，手机党要留意咯。 此次的桂林阳朔之旅三个人一起游玩放松，一个是好友从柳州过来桂林，另一个本身就在桂林读研究生，还有我啦–从广州这边过去呗，一共在那边呆三天，两天桂林市区(2017.12.01 &amp;&amp; 2017.12.03)和一天阳朔(2017.12.02)。 这次不像丹霞山旅游的流水帐那样写游记啦，仅仅谈下个人在阳朔的感受，桂林市区的没啥好谈的，毕竟是市区，都那样。 也许在广州呆的时间久了的原因，去到阳朔有不一样的体验—-第一次进山的新鲜感。第一次来阳朔，除了玩了一下当地人推荐的旅游的项目，比如坐竹筏游漓江啊。我比较喜欢租电驴(电动摩托)在山间闲逛一个下午的那段经历。哈哈,带着感冒开了一个下午。 开着电驴，进入山里面闲逛，没有目标，没有时间观念，抛离城市的喧闹与繁华。山里面的空气超级好，活脱一个天然的氧吧。自己开开停停，哎呀，这里的风景不错哦，那座山还行哦，这湖賊好看，这里有活动…嗯，我们就缺了个单反，还有如果朋友再高点，再瘦点，脸再…哈哈哈，我就有模特啦，不过手机拍出来的效果还不赖啦(本博文的照片都是用自己的手机拍的啦)。在阳朔的山间看到了一个新人在取景拍婚纱照，看到了骑着自行车的几个外国人在标着村上春树字样的山间小屋前面停下来欣赏，吃了当地阿婆自己种的柚子(虽然有些皱皮，时间久了，但是还是挺美味的啦)，感受到了山里人慢节奏的生活…嗯，没有更多的详细内容，要具体展开的话，我可以写一万字，看者可以亲自去体会下啦。 下面放上自己觉得还可以的照片啦—- 文章的结尾简单谈下自己的一些攻略： 广州出发的话，要提前坐交通工具到广州南站坐高铁，自己就是刚踩点过了安检，感觉就是在作死啊 广州南站出发到桂林，建议买到桂林站(其次是桂林北)，因为你可以在那边比较方便在繁华的地方租到房子，费用大概¥ 100/晚。当然啦，选择旅游淡季去，并且选择网购旅店，实体店买贵了¥40（我选择在西城步行街那里的青皮树酒店住下，网购¥99/晚，在那里可以逛夜市，并且离两江四湖比较近） 从桂林市区去阳朔的话，选择滴滴顺风车（免费为滴滴打了一波广告），选择滴滴，当然是因为实惠啦，如果正常坐大巴过去阳朔的话，时间和金钱成本有所提升（看者可以自行比较呢）,我们从西城步行街滴滴顺风车过去阳朔的时间是一个小时左右，费用是¥33/人。从阳朔回来也是坐滴滴的顺风车。 在阳朔玩的时候，可以租借电驴（电动摩托）去玩，我们当初是¥40元/辆滴滴司机说淡季一般是¥30/辆，看你砍价啦，我们从¥50/辆降到¥40/辆，其他的景点看兴趣选择，进山必须是电驴啊，骑自行车踩累死你啦。 偶尔光顾阳朔街边的老奶奶老爷爷大叔大婶（请允许我这样称呼，年轻人没看到几个在路边摆摊的） 就餐的话，在桂林我推荐的是椿记烧鹅（倒数第二张餐厅图就是它）,在阳朔只要不在西街的饭店里面吃就行(我们在饭店里面被坑了一次，东西贵而且味道不咋样，本来朋友要拉我走的，我都还没反应过来就点餐了) 先就这么多攻略吧，后期如果有发现其他实用的我再放上去啦！😊 欢迎看者补充啦。]]></content>
      <categories>
        <category>诗和远方</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0 踩坑记]]></title>
    <url>%2F2017%2F11%2F27%2Fvue-attention%2F</url>
    <content type="text"><![CDATA[自己接触vuejs将近一年，在这段时间里面，一共参与了公司以vuejs技术为框架的两个项目—-工单系统（公司内部项目，不方便贴链接）和淘米淘手游交易平台移动端（未上线）。本文是自己在使用vuejs开发过程中踩到的坑，特此记录下来的文章。嗯，希望对相关的技术爱好者有所帮助啦（如果你知道我在讲什么的话） 😊 对了，在开始写文章之前，先说明下: 文章里面的代码，是在.vue后缀的文件中实现的，在脚手架vue-cli搭建的项目上已经验证过，如有疑问，请自行验证或者在文章底部留言功能那里留言(仅支持github账号用户),或者邮箱留言(1837895991@qq.com)哦。 父组件传递消息给子组件使用props，下面先来看一个简单的例子: 父组件: parent.vue 123456789101112131415161718192021&lt;template&gt; &lt;div id="parent"&gt; &lt;child-component :title='parentTitle' /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childComponent from '@/components/path/to/childComponent.vue' export default &#123; data () &#123; return &#123; parentTitle: 'title form parent' &#125; &#125;, components: &#123; childComponent &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; #parent&#123;&#125;&lt;/style&gt; 子组件: childComponent.vue 1234567891011121314151617181920212223&lt;template&gt; &lt;div id="child"&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; &#125; &#125;, props: &#123; title: &#123; type: String, // 可设置类型 default: 'title from child' // 默认值 &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; #child&#123;&#125;&lt;/style&gt; 最后显示的结果是父亲传过来的消息，即信息为title form parent的h1标题。在父组件向子组件传递消息的过程中，首先，父亲需要拿到子组件&lt;child-component /&gt;,然后告诉子组件我要传递一个title给你:title=&#39;parentTitle&#39;，注意查收。接着，子组件通过props新建一个title的属性，并将数据读取到数据填充到相应的位置。详情看官网Prop 子组件传递消息给父组件子组件是通过$emit向父组件发送事件和相关的数据，来传递信息给父组件。 子组件(child.vue)的demo代码如下: 123456789101112131415161718192021&lt;template&gt; &lt;div id="child"&gt; &lt;button @click="toParent"&gt;向父组件传递消息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "child", data () &#123; return &#123; message: 'message from children' &#125; &#125;, methods: &#123; toParent () &#123; var vm = this; vm.$emit('child-say',vm.message); &#125; &#125; &#125;&lt;/script&gt; 父组件demo代码如下： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id="parent"&gt; &lt;child-component :child-say="parentEvent" /&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childComponent from '@/components/path/to/child.vue'; export default &#123; name: 'parent', data () &#123; return &#123; msg : '' &#125; &#125;, methods: &#123; parentEvent: function (data) &#123; // data 是子组件传过来的数据 var vm = this; vm.msg = data; &#125; &#125;, components: &#123; childComponent &#125; &#125;&lt;/script&gt; 上面代码的过程是，点击了子组件里面的向父组件传递消息的按钮，将子组件里面的message信息放在$emit里面发送给父组件，而父组件在引用的子组件中新建一个事件来接受传过来的信息，然后在父组件中创建的方法对data里面的msg进行数据的改写。最终在页面上显示出的h1标题信息为message from children，即是子组件里面的信息。嗯，官网相关传送门 绑定HTML Class类名结合style的使用一般是用来动态改变样式，所以要用到v-bind:class简写:class。 demo如下: 12345678910111213141516171819202122232425&lt;template&gt; &lt;button class="default-bg" :class="&#123;'active-bg':flag&#125;" @click="changeBtnBg"&gt;按钮&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; flag : false &#125; &#125;, methods: &#123; changeBtnBg: function () &#123; vm.flag = true; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .default-bg&#123; background: red; &#125; .active-bg&#123; background: blue; &#125;&lt;/style&gt; 上面代码中，实现了一个红色按钮通过点击自身实现变成绿色按钮的功能。首先，自己给到一个默认的红色的按钮，并且在按钮上绑定了changeBtnBg的方法，用于控制标志符flag的布尔值。值得注意的是，:class通过flag的真假值来决定是否改变按钮的背景色为定义的绿色。官网相关请戳这里 v-model引用的数据需初始化也许你遇到这个问题，命名写了&lt;input type=&quot;text&quot; v-model=&quot;inputMsg&quot; /&gt;,可是相关的数据绑定&lt;div&gt;&lt;/div&gt;却没有消息，并报错。这是因为你还没有初始化相关的数据啊。正确的姿势应该像下面👇 12345678910111213&lt;template&gt; &lt;input type="text" v-model="inputMsg"/&gt; &lt;div&gt;&#123;&#123;inputMsg&#125;&#125;&lt;div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; inputMsg : '' // 记得初始化数据哦 &#125; &#125; &#125;&lt;/script&gt; style中的scoped也许你注意到了我上面的代码中，在每个&lt;style&gt;&lt;style&gt;的元素中添加了scoped。scoped是用来限定样式的作用的范围，防止此组件里面的样式和其他组件的同名的样式产生冲突。比如—- component1.vue 12345678&lt;template&gt; &lt;h1 id = "title"&gt;component1's title&lt;/h1&gt;&lt;/template&gt;&lt;style scoped&gt; #title&#123; color: red; &#125;&lt;/style&gt; component2.vue 12345678&lt;template&gt; &lt;h1 id="title"&gt;component2's title&lt;/h1&gt;&lt;/template&gt;&lt;style scoped&gt; #title&#123; color: blue; &#125;&lt;/style&gt; 在上面的两个组将component1.vue &amp;&amp; component2.vue中，虽然都有相同的id，但是对各自没什么影响。简单说，加上scoped之后，样式的编写只对本组件有效。 精力有限，未能一次性更新完,忘见谅…]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丹霞山旅游]]></title>
    <url>%2F2017%2F11%2F26%2Ftourist-danXia-mountain%2F</url>
    <content type="text"><![CDATA[由于公司的项目–淘米淘手游交易平台,自己已经有三个月没有离开过广州游玩了。刚好项目自己负责的部分已经ok，然后好友约了周末(2017.10.28～2017.10.29)去韶关爬丹霞山，自己不假思索的答应了！ 我们是四个人一同前往—-两位女生两位男生，同行的四个人中，我只认识我的好友(那个肥嘟嘟脸的男生)，不认识两位女生，因为在旅行完之后没有联系了，忘了她们的名字了，暂且用女生A(戴帽子笑起来很甜的女生)和女生B(一直被吐槽摆不好poss的女生😂 )来区分吧。四人组见下图 : 女生A : 好美啊！空气很好女生B : 周末来得值啊，下次还来好友 : 这山爬得都不累我 : 能在这里住真是超级幸福的…以下省略若干在归途中的对话。是啊，这趟来得很ok啊，重阳节在这么美的地方爬山，真的是超级满足的呢。 我们这两天的计划是，去山顶上看日落和日出，剩下的时间就是在山间闲逛，感受自然。计划如此，除了没能在山顶（人太多，登不上阳元山的顶部看日落，只能够在山腰山看日落了）。 我们早上从广州火车站出发，坐火车直达韶关东，然后坐大巴去丹霞山，买了低配版的门票（150元/人的48小时有效的票）进入丹霞山里面，在兜兜转转后还是女生B电话给来过的同事请教攻略，果断的拒接了在景区山脚下拉客的旅店店主，坐着免费的公交（其实费用包含在票价里面了）兜兜转转的去到被推荐的景区里面当地人的旅店住下。此刻必须赞一下店主啊—-因为我们选好房间后，直接将随身带的行李放到各自的房间后就去吃午餐了没登记个人信息，但是店主知道有人介绍过来的并没有叫我们返回登记，还有店主很是热心的比划着路线给我们。对了，我们住的店是放假啦客栈，租了两间双人房（100元/天，ps:当地人的房子改装的租房，整片区域的价格都差不多）。 来到丹霞山的第一天，简单的吃了顿午饭，我们一行四人就奔着看日出的地点长老峰那里踩点去了，因为观日出的地方阳元山在另一边，得提前熟悉下呢。然后我们就坐车返回原地走路去阳元山看日落，可能我们去的比较晚又加上那天是重阳节,人多得我们上不了山顶，只能在山腰上观看了。对了，比较逗的是，爬阳元山的女生A因为山路陡恐高症瞬间爆发，腿软难以前行。 第二天早上，我们五点就起床等车去长老峰看日出，这个点，公交的站点已经聚集了些人，此时天空还是可以看到星星几点。我们被送到长老峰不远处的终点站，大概是5:40分开始刷票进入长老峰，并沿着路灯一路爬上山顶。漆黑的凌晨借助着微弱的灯光，小心翼翼的爬着陡峭的山路，一大早就出着汗，还是第一次。我们爬到山顶的时候，有很多的人已经在山顶的平台了，我们很是难挤到里面去（对了，有人山顶上依靠帐篷过夜的）。选好一个不错的位置，在天边泛白的时候，踮着脚尖，看着太阳慢慢的奔出来，很是满足。 之后，在日出一段时间后，我们便下山根据地图，依据着店主推荐的路线去逛下其他的风景，神奇的是，我们真能走，又闲逛了好远的地方，期间自己还担任了女生A的摄影师，哈哈哈，我的拍照技术还是ok的啦。四人组边走边聊，从本来有些约束到自然交流，在山间中走动，那山很俊，那林很绿，那水很清，倍感轻松😄 对了，在吃的方面，我们在同一家店吃了走地鸡，味道棒棒的（原谅我忘记了店名），还有客家三宝这道菜，自己蛮喜欢的。 时间到了29号三四点的时候，我们就启程离开景区回广州了，结束丹霞山的两日游。 在本次的游玩中，自己整理了点旅游攻略，希望对见者有帮助或者重游的时候有提示： 提前两三天联系景区的旅店老板，定好房间。有下面的原因： 1231. 景区内和景区外的住房的价格是相差不大的，尽量在景区内订房，这样会节省你很多的时间2. 需要提前联系旅店的老板帮你定景区的票，这样会为你省下不少的经费（吐槽下，外来人的票价和当地人的票价相差太远）3. 寻找有去过丹霞山的朋友，取一下当初居住的旅店的老板的联系方式，在那里订房会得到一定程度的照顾 两天时间丹霞山游玩足够 过去韶关的话，如果经济条件还可以的话，还是不要选择火车吧 不要在什么国庆节啊节日过去，尽量选择周末 多多欣赏自然风光，拍照不游玩，游玩不拍照 学好拍照技术出去玩会更加惬意哦(带上专业的摄像机更好呢)]]></content>
      <categories>
        <category>诗和远方</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
</search>
