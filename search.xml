<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git的学习汇总]]></title>
    <url>%2F2017%2F12%2F13%2Fgit-learning%2F</url>
    <content type="text"><![CDATA[git的学习之旅，预计2018年01月的月底完成此博文更新！还请多多指教，可以本文文末留言。 GIT是什么GIT是一个免费并且开源的分布式版本控制系统，能够高速有效的处理处理或小或大的项目。(以上的话是自己翻译github官网) 至今，自己用过了window系统的TortoiseSVN, mac系统的CornerStone,最近的大半年也在用GIT(主要管理自己的github项目)。比较下来，还是GIT优势比较明显，虽然目前为止没有用GIT开发过团队项目。 GIT跨平台 我可以在不同的操作系统中使用。也许你注意到了，我在window上和mac系统上工作的时候是使用两个不同的svn。如果我在linux上工作会不会又是一个呢。 GIT是分布式版本控制系统,而svn是集中式版本控制系统 集中式版本控制系统是集中放在中央服务器上面的，而团队的人需要从中央服务器上面拉取最新的代码，然后进行开发，最后推送到中央服务器上面，就像串联的电路。而分布式版本控制系统没有中央服务器，团队的每个人的电脑就是一个完整的版本库，就好像并联的电路。 集中式版本控制系统必须联网才能工作，如果是在局域网内还好，带宽足够大，速度足够快，但是遇到网速慢的话，那就心里一万个羊驼在蹦腾了。 集中式版本控制系统安全性比较低，如果中央系统崩溃了，那就有点悲吹，当然你不闲麻烦，可以定期备份。而分布式中央系统就比较安全，每个团队的人员的电脑就是一个完整的版本库，如果其中一个坏掉了，从另外一个团队的人员那里拷贝一份就行了。对了，GIT也会有一台中央的机子，主要是为了方便团队的交流，它是可以不存在的。 GIT安装GIT支持不同的系统，看着可以在链接https://git-scm.com/downloads中，找到和自己电脑系统匹配的GIT，下载安装包后根据提示进行安装。当然，GIT还提供图形界面管理工具，看者也可以在链接中下载GUI Clients，如下图所示–根据提示安装完成后，要验证是否安装成功。看者可打开命令行工具，输入git --version命令,如果安装成功，控制台输出安装的版本号（当然，安装前就应该输入git –version查看是否安装了git）。 GIT配置GIT在使用前，需要进行相关的配置。每台计算机上面只需要配置一次，程序升级的时候会保留配置信息。当然，看者可以在任何时候可以再次通过运行命令行来修改它们。 用户信息设置GIT的用户名称和邮件地址，这个很重要，因为每个GIT的提交都会使用这些信息，并且它会写入到每一次的提交中。你可以在自己的仓库中使用git log，控制台上面显示的每次的提交都有Author字段，它的值就是用户名称 &lt;邮件地址&gt;。方便查看某次的提交的负责人是谁。 12$ git config --global user.name "你的用户名"$ git config --global user.email 你的邮箱地址 ⚠️ GIT一般和github配合使用，看者应该设置用户名称为你的github用户名。当然，还有和gitlab等配合使用… ⚠️ 如果配置中使用了--global选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，GIT都会使用这些信息。但是，当你想针对特定项目使用不同的用户名称与邮件地址的时候，可以在那个仓库目录下运行不使用global选项的命令来配置。 检查配置信息通过git config --list命令可以列出所有GIT能找到的配置。如下：（我的git版本为2.10.0） 12345678...user.name=reng99user.email=1837895991@qq.comcolor.ui=truecore.repositoryformatversion=0core.filemode=truecore.bare=false... 当然，你可以通过git config &lt;key&gt;来检查GIT的某一项配置。比如$ git config user.name。 帮助中心在使用GIT的时候，遇到问题寻求帮助的时候，可以运行git help或git --help或git命令来查看。在控制台上会展示相关的帮助啦。 123456789101112usage: ...start a working area (see also: git help tutorial) ...work on the current change (see also: git help everyday) ...examine the history and state (see alse: git help revisions) ...grow,mark and tweak your common history ...collaborate (see also: git help workflows) ... 更加详细的内容，请点击传送门 创建版本库版本库又名仓库(repository)，可以理解成一个目录，这个目录里面所有文件都可以被GIT管理起来，每个文件的修改、删除，GIT都能跟踪，以便任何时刻都能可以追踪历史，或者在将来某个时刻可以还原。 创建一个版本库，首先得选择一个存放目录的地方，我这里选择了桌面，并且创建一个空的目录。 12345$ cd desktop$ mkdir -p learngit$ cd learngit$ pwd/Users/reng/desktop/learngit mkdir -p dirnanme是创建一个子目录，这里的-p确保目录的名称存在，如果目录不存在的就新建一个，如果你确定目录不存在，直接使用mkdir dirname就可以了。pwd(Print Working Directory)是显示当前目录的整个路径名。 然后，通过命令行git init，将创建的目录变成GIT可以管理的仓库: 12$ git init Initialized empty Git repository in /Users/reng/Desktop/learngit/.git/ 初始化好仓库后就可以愉快的玩耍了，但是，得先来了解下GIT整个工作流程先。 GIT工作流程为了更好的学习，自己用Axure RP 8粗略的画了下流程图，如下– 本地仓库(repo)包含工作区和版本库,那么什么是工作区和版本库呢？基本的流程又是什么呢？ 工作区和版本库我们新建一个仓库，就像我们新建的learngit仓库，现在在里面添加一个文件README.md，用sublime打开learngit目录。此时会出现如下图的情况(当然你设置了其他东西例外)–如上图，出现的内容就是工作区（ 电脑上能看到的此目录下的内容），这里工作区只有README.md一个文件。工作区有一个隐藏的目录.git，这个不算工作区，而是GIT的版本库。版本库又包括暂存区和GIT仓库。暂存区是一个文件，保存了下次将提交的文件列表信息，而GIT仓库目录是GIT用来保存项目的元数据和对象数据库的地方。这是GIT中最重要的部分，从其他计算机克隆仓库的时候，拷贝的就是这里的数据。当执行git add .或者git add path/to/filename的时候，文件从工作区转到暂存区；执行git commit -m&quot;here is the message described the file you add&quot;的时候,文件从缓存区添加到GIT仓库。 基本的工作流基本的GIT工作流可以简单总结如下– 在工作区目录中修改文件 暂存区中暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到GIT仓库目录 时光机穿梭到目前为止，在自己创建的本地仓库–learngit中已经初具形态了。进入learngit，执行ls，可看到目前仓库中已有的文件README.md。 12345$ cd desktop/learngit$ lsREADME.md$ cat README.md## content 上面展示了本地learngit内的相关的内容。运行下git status查看现在的状态。 123$ git statusOn branch masternothing to commit, working tree clean 这时候会提示没有内容可以提交，工作区是干净的。因为我之前已经提交(git commit)过了。上面还提示了目前是位于主分支上面，GIT在初始化(git init)的时候会自动创建一个HEAD指针指向默认master分支，也只有一个分支，看者可以通过git branch查看。 现在，在README.md上添加一些内容。 123## content### first change 此刻再通过git status查看当前状态。 123456789$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a") 这时候显示出一堆的东西，告诉我们现在是位于主分支上面，然后告诉我们修改的文件啊，可以使用的命令进行下一步的操纵。那么我们来进行下一步的操作了，git add . 或者 git add README.md将修改的文件添加到暂存区域。 1234567$ git add .$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md 对了，有时候需要在添加的之前（执行git add . 或者 git add path/to/filename）的时候，需要看下修改了哪些内容可以执行下git diff。那么，现在先回退到修改的前一个版本。 12345678$ git reset HEAD README.mdUnstaged changes after reset:M README.md$ git checkout -- README.md$ lsREADME.md$ cat README.md## content 回退正确，现在像上次那样添加内容### first change，然后执行命令git diff来查看更改的内容。 123456789101112$ git diffdiff --git a/README.md b/README.mdindex 75759ec..0bc52b9 100644--- a/README.md+++ b/README.md@@ -1 +1,3 @@-## content\ No newline at end of file+## content++### first change\ No newline at end of file 现在就显示了修改前的内容–-前为修改前的内容，和修改后的内容–+前修改后的内容。查看完之后，觉得没有问题了，就可以进行添加(git add)，提交(git commit)。当然，一般不常用git diff的，因为自己修改的东西自己心里总有点数吧，可能合作中团队的其他人需要查看文件前后的不同点就需要用到git diff啦。 版本回退为了方便讲解下版本回退，我先将上面添加的### first change提交以下–git add . &amp;&amp; git commit -m &quot;add first change&quot;。下面通过git log就可以查看自己提交的记录了。 1234567891011121314151617181920212223$ git logcommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md $ git add . &amp;&amp; git commit -m "add first change"[master 0ac49ba] add first change 1 file changed, 3 insertions(+), 1 deletion(-) $ git logcommit 0ac49bae6ab55df9c05d0770de347665a2568f31Author: reng99 &lt;1837895991@qq.com&gt;Date: Mon Dec 18 15:26:06 2017 +0800 add first changecommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md 在上面中，自己先执行了git log来显示提交的日志，显示只有一条，然后执行了add和commit的命令，打印的内容是现实主分支、commit的id、commit的信息、多少个文件的更改、多少个插入以及多少个删除。之后再次执行git log打印日志，显示了两次提交。⚠️ 注意：当提交(commit)的次数较多之后，控制台会显示不下（最多现实4条）那么多的条数，可以通过按键盘的向上或向下键查看日志的内容，需要退出查看日志命令的话，在英文输入法的状态按下q，意思就是quit(退出)。 版本的回退就是改变HEAD指针的指向。通过git reset --hard HEAD^返回上一个版本，通过git reset --hard HEAD^^返回上上个版本…由此推论，往上100个版本的话就是100个^，当然，这样你数到明天也未必数得正确，所以写成git reset --hard HEAD~100。另外一种是，你知道提交的id，例如commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67的前7位就是commit的id(5c2639e)，执行git reset --hard 5c2639e就回到此版本啦。 123456789101112$ reng$ git reset --hard HEAD^HEAD is now at 5c2639e init README.md$ git logcommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md$ lsREADME.md$ cat README.md## content 现在你已经回到了最初的版本，这里演示的是通过HEAD，你也可以通过commit id来实现的。执行上面的代码后，README.md文件里面只有一### content文字内容,但是过了段时间后，你想恢复到原先的版本，通过git log命令行，控制台显示的以前的信息，通过它找不到回退前的commit id，怎么办？GIT提供一个git reflog显示提交的历史记录，在那里可以查看提交的id、HEAD的指针历史和操作的信息记录。下面演示回退到最新的版本（也就是commit -m “add first change”）– 123456789101112131415161718$ git logcommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md$ git reflog5c2639e HEAD@&#123;0&#125;: reset: moving to HEAD^0ac49ba HEAD@&#123;1&#125;: commit: add first change5c2639e HEAD@&#123;2&#125;: commit (initial): init README.md$ git reset --hard 0ac49baHEAD is now at 0ac49ba add first change$ lsREADME.md$ cat README.md## content### first 现在又回到了最新的版本，又能够愉快的玩耍了。😊 管理修改GIT比其他版本控制系统设计优秀，其中一点是–GIT跟踪并管理的是修改，而非文件。 下面在README.md内添加信息### second change。之后看下变化后的文件的状态和差异等。 123456789101112131415161718192021222324$ lsREADME.md$ cat README.md## content### first change#### second change$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")$ git add README.md$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md 此时，对README.md进行第三次的修改，添加内容### third change。 123456789101112131415161718192021222324252627282930313233$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.md$ cat README.md## content### first change#### second change### third change$ git commit -m "test file modify"[master 18f86ba] test file modify 1 file changed, 3 insertions(+), 1 deletion(-)$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a") 上面的演示流程是这样的第一次修改(#### second change) -&gt; git add -&gt; 第二次修改(### third change) -&gt; git commit。但是最后查看状态的时候(git status)，第二次的修改并没有被提交上去。因为GIT管理的是修改，当使用git add命令的时候，在工作区的第一次修改被放入暂存区，准备提交，但是在工作区的第二次修改并没有放入到暂存区，而git commit是将暂存区的修改提交到GIT仓库，所以第二次修改的内容是不会被提交的。这也是说明为什么可以多次添加(git add)，一次提交(git commit)的原因了。 撤销修改文件的撤销修改分成三种情况，一种是修改在工作区的内容，一种是修改在暂存区的内容，另一种是修改在GIT仓库的内容。也许会有看者说，不能修改在远程库中的内容吗？有啊，就是git add-&gt;git commit-&gt;git push将远程仓库的内容覆盖被，不过团队人在克隆远程库下来的时候，还是可以查看到你提交的错误内容的。我们现在只针对本地仓库的三种情况谈下自己的看法– 情况一：撤销工作区的内容 在管理修改中，自己的工作区还是没有提交，此时想放弃当前工作区的编辑内容执行git checkout -- file。接着上面的内容，我这里的工作区内有的内容是### third change，现在我要放弃第三次修改，只要执行git checkout -- README.md就可以了。 1234567891011121314151617181920212223242526272829$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")$ lsREADME.md$ cat README.md## content### first change#### second change### third change$ git checkout -- README.md$ cat README.md## content### first change#### second change$ git statusOn branch masternothing to commit, working tree clean 情况二：撤销暂存区的内容 当你不但改乱了工作区的某个文件的内容，还添加(git add)到了暂存区时，想丢弃修改，那么得分两步来撤销文件。先是通过git reset HEAD file，将暂存区的文件退回到工作区，然后通过git checkout -- file放弃修改改文件的内容。为了方便演示，我这里的暂存区没什么内容，所以添加内容### tentative content并将它添加到缓存区。之后，演示将缓存区的内容撤回– 1234567891011121314151617181920212223242526272829$ cat README.md## content### first change#### second change### tentative content$ git add .$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md$ git reset HEAD README.mdUnstaged changes after reset:M README.md$ git checkout -- README.md$ cat README.md## content### first change#### second change$ git statusOn branch masternothing to commit, working tree clean 情况三：撤销GIT仓库的内容 如果你不仅添加(git add)了内容到暂存区并且提交(git commit)了内容到GIT仓库中了。你需要撤销上一次的内容，也就是要回退到上一个版本，执行git reset --hard HEAD^就可以啦，详细的内容查看版本回退。如下– 123456789101112131415$ git statusOn branch masternothing to commit, working tree clean$ cat README.md## content### first change#### second change$ git reset --hard HEAD^HEAD is now at 0ac49ba add first change$ cat READMEmd## content### first change 远程仓库远程仓库的使用能够提高你和团队的工作效率，无论何时何地，团队的人员都可以在联网的情况下将代码进行拉取，修改和更新。因为我是使用github来管理项目的，所以我的远程仓库是放在github里面。这里默认看者已经安装了github，当然也可以用码云、gitlab等。 本地库添加到远程库这点很容易，登录自己注册的github，如果打不开，请开下VPN。进入自己的首页(https://github.com/username)，点击`+`号创建(new repository)一个名为learngit的仓库(注意哦⚠️ 名称是本地仓库已经初始化过的，我这里本地有个同名初始化的learngit仓库)，其他的字段自选来填写。点击Create repository创建此远程仓库。紧接着就是进行本地仓库和远程仓库的关联啦，github很友好的提示了你怎么进行一个远程仓库的关联。 现在按照上图来关联下远程仓库。 12345678910$ git remote add origin https://github.com/reng99/learngit.git$ git push -u origin masterCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (6/6), 456 bytes | 0 bytes/s, done.Total 6 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit.git * [new branch] master -&gt; masterBranch master set up to track remote branch master from origin. 注意⚠️ 第一次向远程仓库（关联）push的时候是$ git push -u origin master，不能忽略-u，以后的push不用带-u。至此，打开你的github的相关的仓库就可以看到添加了README.md文件，我这里地址是https://github.com/reng99/learngit，因为我是使用markdown语法写的，控制台显示的内容和仓库的显示内容有所区别啦。(⚠️ 后期我将learngit仓库删除啦，所以你访问链接是找不到这个仓库的，毕竟不想放一个没什么内容的仓库在我的github上)。 远程库克隆到本地从远程仓库克隆东西到本地同样很简单，只需要进入你想克隆的仓库，将仓库的url复制下来（当然你也可以复制window.location.href的内容），运行git clone address。现在我将本地桌面的learngit的仓库删除，然后从远程将learngit克隆到本地。 12345678910$ cd desktop$ rm -rf learngit$ find learngitfind: learngit: No such file or directory$ git clone https://github.com/reng99/learngitCloning into 'learngit'...remote: Counting objects: 6, done.remote: Compressing objects: 100% (2/2), done.remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0Unpacking objects: 100% (6/6), done. 成功将gitlearn从远程克隆下来，接下来又可以愉快的玩耍啦。 分支管理分支管理允许创建另一条线/方向上开发，能够让你在不影响他人工作的情况下，正常的工作。当在自己创建的分支中完成自己的功过后，合并到主分支就行了(git init初始化的时候已经默认创建了master主分支)。一般团队的合作是不在主分支上进行的，个人项目除外（个人理解）。 创建分支当前learngit仓库上只有一个分支，那就是master分支，看者可以通过git branch命令来查看当前的分支，git branch branchName命令来创建一个新的分支，我这里创建的是dev分支。 1234567$ cd desktop/learngit$ git branch* master$ git branch dev$ git branch dev* master 现在已经创建了dev分支，有两个分支了，分支前面带有一个星号的分支说明是当前的正在工作的分区。执行上面的分支后，可以简单的画下现在的情况了，有个HEAD指针指向主分支的最新点，刚才新创建的dev分支我这里默认是一个dev的指针指向了dev分支的最新点。 1234567.. HEAD指针. │├────────*master└────────dev │ dev指针 切换分支我们一般是很少在主分支进行工作的，所以在创建出新的分支之后，我们就切换到新的分支进行相关的工作。可以通过git checkout branchName切换到已经存在的分支工作，通过分支前面的*可查看目前位于哪个分支内。现在我切换到创建的dev分支。 12345678$ git branch dev* master$ git checkout devSwitched to branch 'dev'$ git branch* dev master 合并分支在创建好分支后，我们在新的分支上工作完成后，就需要往主分支上进行合并啦。我修改了分支dev上的README.md的内容，就是添加文字### new branch content。在合并分支前，需要切换到要合并到哪个分支(一般是master主分支)，通过git merge branchName将需要的合并的分支合并到当前分支，我是将dev分支合并到master分支。 123456789101112131415161718$ git branch* dev master$ lsREADME.md$ cat README.md## content### first change### new branch content$ git checkout masterM README.mdSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ lsREADME.md$ git merge dev 参考内容廖雪峰官方网站–Git教程 易百教程–Git教程 git官网 精力有限，未能一次性更新完，请见谅…]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桂林阳朔旅游]]></title>
    <url>%2F2017%2F12%2F04%2Ftourist-guiLin-and-yangShuo%2F</url>
    <content type="text"><![CDATA[桂林市区的两江四湖的夜景很美丽，还有桂林市区的一些步行街走起来挺舒服的。然后就是阳朔啦，我喜欢那山里的清新的空气(哈哈哈，不过，我更喜欢家里海边的空气)。在山里面就好像与世隔绝，可能一个人在喧闹的城市呆久了，都会喜欢吧。⚠️ 多图博文，手机党要留意咯。 此次的桂林阳朔之旅三个人一起游玩放松，一个是好友从柳州过来桂林，另一个本身就在桂林读研究生，还有我啦–从广州这边过去呗，一共在那边呆三天，两天桂林市区(2017.12.01 &amp;&amp; 2017.12.03)和一天阳朔(2017.12.02)。 这次不像丹霞山旅游的流水帐那样写游记啦，仅仅谈下个人在阳朔的感受，桂林市区的没啥好谈的，毕竟是市区，都那样。 也许在广州呆的时间久了的原因，去到阳朔有不一样的体验—-第一次进山的新鲜感。第一次来阳朔，除了玩了一下当地人推荐的旅游的项目，比如坐竹筏游漓江啊。我比较喜欢租电驴(电动摩托)在山间闲逛一个下午的那段经历。哈哈,带着感冒开了一个下午。 开着电驴，进入山里面闲逛，没有目标，没有时间观念，抛离城市的喧闹与繁华。山里面的空气超级好，活脱一个天然的氧吧。自己开开停停，哎呀，这里的风景不错哦，那座山还行哦，这湖賊好看，这里有活动…嗯，我们就缺了个单反，还有如果朋友再高点，再瘦点，脸再…哈哈哈，我就有模特啦，不过手机拍出来的效果还不赖啦(本博文的照片都是用自己的手机拍的啦)。在阳朔的山间看到了一个新人在取景拍婚纱照，看到了骑着自行车的几个外国人在标着村上春树字样的山间小屋前面停下来欣赏，吃了当地阿婆自己种的柚子(虽然有些皱皮，时间久了，但是还是挺美味的啦)，感受到了山里人慢节奏的生活…嗯，没有更多的详细内容，要具体展开的话，我可以写一万字，看者可以亲自去体会下啦。 下面放上自己觉得还可以的照片啦—- 文章的结尾简单谈下自己的一些攻略： 广州出发的话，要提前坐交通工具到广州南站坐高铁，自己就是刚踩点过了安检，感觉就是在作死啊 广州南站出发到桂林，建议买到桂林站(其次是桂林北)，因为你可以在那边比较方便在繁华的地方租到房子，费用大概¥ 100/晚。当然啦，选择旅游淡季去，并且选择网购旅店，实体店买贵了¥40（我选择在西城步行街那里的青皮树酒店住下，网购¥99/晚，在那里可以逛夜市，并且离两江四湖比较近） 从桂林市区去阳朔的话，选择滴滴顺风车（免费为滴滴打了一波广告），选择滴滴，当然是因为实惠啦，如果正常坐大巴过去阳朔的话，时间和金钱成本有所提升（看者可以自行比较呢）,我们从西城步行街滴滴顺风车过去阳朔的时间是一个小时左右，费用是¥33/人。从阳朔回来也是坐滴滴的顺风车。 在阳朔玩的时候，可以租借电驴（电动摩托）去玩，我们当初是¥40元/辆滴滴司机说淡季一般是¥30/辆，看你砍价啦，我们从¥50/辆降到¥40/辆，其他的景点看兴趣选择，进山必须是电驴啊，骑自行车踩累死你啦。 偶尔光顾阳朔街边的老奶奶老爷爷大叔大婶（请允许我这样称呼，年轻人没看到几个在路边摆摊的） 就餐的话，在桂林我推荐的是椿记烧鹅（倒数第二张餐厅图就是它）,在阳朔只要不在西街的饭店里面吃就行(我们在饭店里面被坑了一次，东西贵而且味道不咋样，本来朋友要拉我走的，我都还没反应过来就点餐了) 先就这么多攻略吧，后期如果有发现其他实用的我再放上去啦！😊 欢迎看者补充啦。]]></content>
      <categories>
        <category>诗和远方</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0 踩坑记]]></title>
    <url>%2F2017%2F11%2F27%2Fvue-attention%2F</url>
    <content type="text"><![CDATA[自己接触vuejs将近一年，在这段时间里面，一共参与了公司以vuejs技术为框架的两个项目—-工单系统（公司内部项目，不方便贴链接）和淘米淘手游交易平台移动端（未上线）。本文是自己在使用vuejs开发过程中踩到的坑，特此记录下来的文章。嗯，希望对相关的技术爱好者有所帮助啦（如果你知道我在讲什么的话） 😊 对了，在开始写文章之前，先说明下: 文章里面的代码，是在.vue后缀的文件中实现的，在脚手架vue-cli搭建的项目上已经验证过，如有疑问，请自行验证或者在文章底部留言功能那里留言(仅支持github账号用户),或者邮箱留言(1837895991@qq.com)哦。 父组件传递消息给子组件使用props，下面先来看一个简单的例子: 父组件: parent.vue 123456789101112131415161718192021&lt;template&gt; &lt;div id="parent"&gt; &lt;child-component :title='parentTitle' /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childComponent from '@/components/path/to/childComponent.vue' export default &#123; data () &#123; return &#123; title: 'title form parent' &#125; &#125;, components: &#123; childComponent &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; #parent&#123;&#125;&lt;/style&gt; 子组件: childComponent.vue 1234567891011121314151617181920212223&lt;template&gt; &lt;div id="child"&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; &#125; &#125;, props: &#123; title: &#123; type: String, // 可设置类型 default: 'title from child' // 默认值 &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; #child&#123;&#125;&lt;/style&gt; 最后显示的结果是父亲传过来的消息，即信息为title form parent的h1标题。在父组件向子组件传递消息的过程中，首先，父亲需要拿到子组件&lt;child-component /&gt;,然后告诉子组件我要传递一个title给你:title=&#39;parentTitle&#39;，注意查收。接着，子组件通过props新建一个title的属性，并将数据读取到数据填充到相应的位置。详情看官网Prop 子组件传递消息给父组件子组件是通过$emit向父组件发送事件和相关的数据，来传递信息给父组件。 子组件(child.vue)的demo代码如下: 123456789101112131415161718192021&lt;template&gt; &lt;div id="child"&gt; &lt;button @click="toParent"&gt;向父组件传递消息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "child", data () &#123; return &#123; message: 'message from children' &#125; &#125;, methods: &#123; toParent () &#123; var vm = this; vm.$emit('child-say',vm.message); &#125; &#125; &#125;&lt;/script&gt; 父组件demo代码如下： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id="parent"&gt; &lt;child-component :child-say="parentEvent" /&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childComponent from '@/components/path/to/child.vue'; export default &#123; name: 'parent', data () &#123; return &#123; msg : '' &#125; &#125;, methods: &#123; parentEvent: function (data) &#123; // data 是子组件传过来的数据 var vm = this; vm.msg = data; &#125; &#125;, components: &#123; childComponent &#125; &#125;&lt;/script&gt; 上面代码的过程是，点击了子组件里面的向父组件传递消息的按钮，将子组件里面的message信息放在$emit里面发送给父组件，而父组件在引用的子组件中新建一个事件来接受传过来的信息，然后在父组件中创建的方法对data里面的msg进行数据的改写。最终在页面上显示出的h1标题信息为message from children，即是子组件里面的信息。嗯，官网相关传送门 绑定HTML Class类名结合style的使用一般是用来动态改变样式，所以要用到v-bind:class简写:class。 demo如下: 12345678910111213141516171819202122232425&lt;template&gt; &lt;button class="default-bg" :class="&#123;'active-bg':flag&#125;" @click="changeBtnBg"&gt;按钮&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; flag : false &#125; &#125;, methods: &#123; changeBtnBg: function () &#123; vm.flag = true; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .default-bg&#123; background: red; &#125; .active-bg&#123; background: blue; &#125;&lt;/style&gt; 上面代码中，实现了一个红色按钮通过点击自身实现变成绿色按钮的功能。首先，自己给到一个默认的红色的按钮，并且在按钮上绑定了changeBtnBg的方法，用于控制标志符flag的布尔值。值得注意的是，:class通过flag的真假值来决定是否改变按钮的背景色为定义的绿色。官网相关请戳这里 v-model引用的数据需初始化也许你遇到这个问题，命名写了&lt;input type=&quot;text&quot; v-model=&quot;inputMsg&quot; /&gt;,可是相关的数据绑定&lt;div&gt;&lt;/div&gt;却没有消息，并报错。这是因为你还没有初始化相关的数据啊。正确的姿势应该像下面👇 12345678910111213&lt;template&gt; &lt;input type="text" v-model="inputMsg"/&gt; &lt;div&gt;&#123;&#123;inputMsg&#125;&#125;&lt;div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; inputMsg : '' // 记得初始化数据哦 &#125; &#125; &#125;&lt;/script&gt; style中的scoped也许你注意到了我上面的代码中，在每个&lt;style&gt;&lt;style&gt;的元素中添加了scoped。scoped是用来限定样式的作用的范围，防止此组件里面的样式和其他组件的同名的样式产生冲突。比如—- component1.vue 12345678&lt;template&gt; &lt;h1 id = "title"&gt;component1's title&lt;/h1&gt;&lt;/template&gt;&lt;style scoped&gt; #title&#123; color: red; &#125;&lt;/style&gt; component2.vue 12345678&lt;template&gt; &lt;h1 id="title"&gt;component2's title&lt;/h1&gt;&lt;/template&gt;&lt;style scoped&gt; #title&#123; color: blue; &#125;&lt;/style&gt; 在上面的两个组将component1.vue &amp;&amp; component2.vue中，虽然都有相同的id，但是对各自没什么影响。简单说，加上scoped之后，样式的编写只对本组件有效。 精力有限，未能一次性更新完,忘见谅…]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丹霞山旅游]]></title>
    <url>%2F2017%2F11%2F26%2Ftourist-danXia-mountain%2F</url>
    <content type="text"><![CDATA[由于公司的项目–淘米淘手游交易平台,自己已经有三个月没有离开过广州游玩了。刚好项目自己负责的部分已经ok，然后好友约了周末(2017.10.28～2017.10.29)去韶关爬丹霞山，自己不假思索的答应了！ 我们是四个人一同前往—-两位女生两位男生，同行的四个人中，我只认识我的好友(那个肥嘟嘟脸的男生)，不认识两位女生，因为在旅行完之后没有联系了，忘了她们的名字了，暂且用女生A(戴帽子笑起来很甜的女生)和女生B(一直被吐槽摆不好poss的女生😂 )来区分吧。四人组见下图 : 女生A : 好美啊！空气很好女生B : 周末来得值啊，下次还来好友 : 这山爬得都不累我 : 能在这里住真是超级幸福的…以下省略若干在归途中的对话。是啊，这趟来得很ok啊，重阳节在这么美的地方爬山，真的是超级满足的呢。 我们这两天的计划是，去山顶上看日落和日出，剩下的时间就是在山间闲逛，感受自然。计划如此，除了没能在山顶（人太多，登不上阳元山的顶部看日落，只能够在山腰山看日落了）。 我们早上从广州火车站出发，坐火车直达韶关东，然后坐大巴去丹霞山，买了低配版的门票（150元/人的48小时有效的票）进入丹霞山里面，在兜兜转转后还是女生B电话给来过的同事请教攻略，果断的拒接了在景区山脚下拉客的旅店店主，坐着免费的公交（其实费用包含在票价里面了）兜兜转转的去到被推荐的景区里面当地人的旅店住下。此刻必须赞一下店主啊—-因为我们选好房间后，直接将随身带的行李放到各自的房间后就去吃午餐了没登记个人信息，但是店主知道有人介绍过来的并没有叫我们返回登记，还有店主很是热心的比划着路线给我们。对了，我们住的店是放假啦客栈，租了两间双人房（100元/天，ps:当地人的房子改装的租房，整片区域的价格都差不多）。 来到丹霞山的第一天，简单的吃了顿午饭，我们一行四人就奔着看日出的地点长老峰那里踩点去了，因为观日出的地方阳元山在另一边，得提前熟悉下呢。然后我们就坐车返回原地走路去阳元山看日落，可能我们去的比较晚又加上那天是重阳节,人多得我们上不了山顶，只能在山腰上观看了。对了，比较逗的是，爬阳元山的女生A因为山路陡恐高症瞬间爆发，腿软难以前行。 第二天早上，我们五点就起床等车去长老峰看日出，这个点，公交的站点已经聚集了些人，此时天空还是可以看到星星几点。我们被送到长老峰不远处的终点站，大概是5:40分开始刷票进入长老峰，并沿着路灯一路爬上山顶。漆黑的凌晨借助着微弱的灯光，小心翼翼的爬着陡峭的山路，一大早就出着汗，还是第一次。我们爬到山顶的时候，有很多的人已经在山顶的平台了，我们很是难挤到里面去（对了，有人山顶上依靠帐篷过夜的）。选好一个不错的位置，在天边泛白的时候，踮着脚尖，看着太阳慢慢的奔出来，很是满足。 之后，在日出一段时间后，我们便下山根据地图，依据着店主推荐的路线去逛下其他的风景，神奇的是，我们真能走，又闲逛了好远的地方，期间自己还担任了女生A的摄影师，哈哈哈，我的拍照技术还是ok的啦。四人组边走边聊，从本来有些约束到自然交流，在山间中走动，那山很俊，那林很绿，那水很清，倍感轻松😄 对了，在吃的方面，我们在同一家店吃了走地鸡，味道棒棒的（原谅我忘记了店名），还有客家三宝这道菜，自己蛮喜欢的。 时间到了29号三四点的时候，我们就启程离开景区回广州了，结束丹霞山的两日游。 在本次的游玩中，自己整理了点旅游攻略，希望对见者有帮助或者重游的时候有提示： 提前两三天联系景区的旅店老板，定好房间。有下面的原因： 1231. 景区内和景区外的住房的价格是相差不大的，尽量在景区内订房，这样会节省你很多的时间2. 需要提前联系旅店的老板帮你定景区的票，这样会为你省下不少的经费（吐槽下，外来人的票价和当地人的票价相差太远）3. 寻找有去过丹霞山的朋友，取一下当初居住的旅店的老板的联系方式，在那里订房会得到一定程度的照顾 两天时间丹霞山游玩足够 过去韶关的话，如果经济条件还可以的话，还是不要选择火车吧 不要在什么国庆节啊节日过去，尽量选择周末 多多欣赏自然风光，拍照不游玩，游玩不拍照 学好拍照技术出去玩会更加惬意哦(带上专业的摄像机更好呢)]]></content>
      <categories>
        <category>诗和远方</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
</search>
