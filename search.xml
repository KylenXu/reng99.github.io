<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git的学习汇总]]></title>
    <url>%2F2017%2F12%2F13%2Fgit-learning%2F</url>
    <content type="text"><![CDATA[git的学习之旅，预计2018年01月的月底完成此博文更新！还请多多指教，可以本文文末留言。 GIT是什么GIT是一个免费并且开源的分布式版本控制系统，能够高速有效的处理处理或小或大的项目。(以上的话是自己翻译github官网) 至今，自己用过了window系统的TortoiseSVN, mac系统的CornerStone,最近的大半年也在用GIT(主要管理自己的github项目)。比较下来，还是GIT优势比较明显，虽然目前为止没有用GIT开发过团队项目。 GIT跨平台 我可以在不同的操作系统中使用。也许你注意到了，我在window上和mac系统上工作的时候是使用两个不同的svn。如果我在linux上工作会不会又是一个呢。 GIT是分布式版本控制系统,而svn是集中式版本控制系统 集中式版本控制系统是集中放在中央服务器上面的，而团队的人需要从中央服务器上面拉取最新的代码，然后进行开发，最后推送到中央服务器上面，就像串联的电路。而分布式版本控制系统没有中央服务器，团队的每个人的电脑就是一个完整的版本库，就好像并联的电路。 集中式版本控制系统必须联网才能工作，如果是在局域网内还好，带宽足够大，速度足够快，但是遇到网速慢的话，那就心里一万个羊驼在蹦腾了。 集中式版本控制系统安全性比较低，如果中央系统崩溃了，那就有点悲吹，当然你不闲麻烦，可以定期备份。而分布式中央系统就比较安全，每个团队的人员的电脑就是一个完整的版本库，如果其中一个坏掉了，从另外一个团队的人员那里拷贝一份就行了。对了，GIT也会有一台中央的机子，主要是为了方便团队的交流，它是可以不存在的。 GIT安装GIT支持不同的系统，看着可以在链接https://git-scm.com/downloads中，找到和自己电脑系统匹配的GIT，下载安装包后根据提示进行安装。当然，GIT还提供图形界面管理工具，看者也可以在链接中下载GUI Clients，如下图所示–根据提示安装完成后，要验证是否安装成功。看者可打开命令行工具，输入git --version命令,如果安装成功，控制台输出安装的版本号（当然，安装前就应该输入git –version查看是否安装了git）。 GIT配置GIT在使用前，需要进行相关的配置。每台计算机上面只需要配置一次，程序升级的时候会保留配置信息。当然，看者可以在任何时候可以再次通过运行命令行来修改它们。 用户信息设置GIT的用户名称和邮件地址，这个很重要，因为每个GIT的提交都会使用这些信息，并且它会写入到每一次的提交中。你可以在自己的仓库中使用git log，控制台上面显示的每次的提交都有Author字段，它的值就是用户名称 &lt;邮件地址&gt;。方便查看某次的提交的负责人是谁。 12$ git config --global user.name "你的用户名"$ git config --global user.email 你的邮箱地址 ⚠️ GIT一般和github配合使用，看者应该设置用户名称为你的github用户名。当然，还有和gitlab等配合使用… ⚠️ 如果配置中使用了--global选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，GIT都会使用这些信息。但是，当你想针对特定项目使用不同的用户名称与邮件地址的时候，可以在那个仓库目录下运行不使用global选项的命令来配置。 检查配置信息通过git config --list命令可以列出所有GIT能找到的配置。如下：（我的git版本为2.10.0） 12345678...user.name=reng99user.email=1837895991@qq.comcolor.ui=truecore.repositoryformatversion=0core.filemode=truecore.bare=false... 当然，你可以通过git config &lt;key&gt;来检查GIT的某一项配置。比如$ git config user.name。 帮助中心在使用GIT的时候，遇到问题寻求帮助的时候，可以运行git help或git --help或git命令来查看。在控制台上会展示相关的帮助啦。 123456789101112usage: ...start a working area (see also: git help tutorial) ...work on the current change (see also: git help everyday) ...examine the history and state (see alse: git help revisions) ...grow,mark and tweak your common history ...collaborate (see also: git help workflows) ... 更加详细的内容，请点击传送门 创建版本库版本库又名仓库(repository)，可以理解成一个目录，这个目录里面所有文件都可以被GIT管理起来，每个文件的修改、删除，GIT都能跟踪，以便任何时刻都能可以追踪历史，或者在将来某个时刻可以还原。 创建一个版本库，首先得选择一个存放目录的地方，我这里选择了桌面，并且创建一个空的目录。 12345$ cd desktop$ mkdir -p learngit$ cd learngit$ pwd/Users/reng/desktop/learngit mkdir -p dirnanme是创建一个子目录，这里的-p确保目录的名称存在，如果目录不存在的就新建一个，如果你确定目录不存在，直接使用mkdir dirname就可以了。pwd(Print Working Directory)是显示当前目录的整个路径名。 然后，通过命令行git init，将创建的目录变成GIT可以管理的仓库: 12$ git init Initialized empty Git repository in /Users/reng/Desktop/learngit/.git/ 初始化好仓库后就可以愉快的玩耍了，但是，得先来了解下GIT整个工作流程先。 GIT工作流程为了更好的学习，自己用Axure RP 8粗略的画了下流程图，如下– 本地仓库(repo)包含工作区和版本库,那么什么是工作区和版本库呢？基本的流程又是什么呢？ 工作区和版本库我们新建一个仓库，就像我们新建的learngit仓库，现在在里面添加一个文件README.md，用sublime打开learngit目录。此时会出现如下图的情况(当然你设置了其他东西例外)–如上图，出现的内容就是工作区（ 电脑上能看到的此目录下的内容），这里工作区只有README.md一个文件。工作区有一个隐藏的目录.git，这个不算工作区，而是GIT的版本库。版本库又包括暂存区和GIT仓库。暂存区是一个文件，保存了下次将提交的文件列表信息，而GIT仓库目录是GIT用来保存项目的元数据和对象数据库的地方。这是GIT中最重要的部分，从其他计算机克隆仓库的时候，拷贝的就是这里的数据。当执行git add .或者git add path/to/filename的时候，文件从工作区转到暂存区；执行git commit -m&quot;here is the message described the file you add&quot;的时候,文件从缓存区添加到GIT仓库。 基本的工作流基本的GIT工作流可以简单总结如下– 在工作区目录中修改文件 暂存区中暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到GIT仓库目录 时光机穿梭到目前为止，在自己创建的本地仓库–learngit中已经初具形态了。进入learngit，执行ls，可看到目前仓库中已有的文件README.md。 12345$ cd desktop/learngit$ lsREADME.md$ cat README.md## content 上面展示了本地learngit内的相关的内容。运行下git status查看现在的状态。 123$ git statusOn branch masternothing to commit, working tree clean 这时候会提示没有内容可以提交，工作区是干净的。因为我之前已经提交(git commit)过了。上面还提示了目前是位于主分支上面，GIT在初始化(git init)的时候会自动创建一个HEAD指针指向默认master分支，也只有一个分支，看者可以通过git branch查看。 现在，在README.md上添加一些内容。 123## content### first change 此刻再通过git status查看当前状态。 123456789$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a") 这时候显示出一堆的东西，告诉我们现在是位于主分支上面，然后告诉我们修改的文件啊，可以使用的命令进行下一步的操纵。那么我们来进行下一步的操作了，git add . 或者 git add README.md将修改的文件添加到暂存区域。 1234567$ git add .$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md 对了，有时候需要在添加的之前（执行git add . 或者 git add path/to/filename）的时候，需要看下修改了哪些内容可以执行下git diff。那么，现在先回退到修改的前一个版本。 12345678$ git reset HEAD README.mdUnstaged changes after reset:M README.md$ git checkout -- README.md$ lsREADME.md$ cat README.md## content 回退正确，现在像上次那样添加内容### first change，然后执行命令git diff来查看更改的内容。 123456789101112$ git diffdiff --git a/README.md b/README.mdindex 75759ec..0bc52b9 100644--- a/README.md+++ b/README.md@@ -1 +1,3 @@-## content\ No newline at end of file+## content++### first change\ No newline at end of file 现在就显示了修改前的内容–-前为修改前的内容，和修改后的内容–+前修改后的内容。查看完之后，觉得没有问题了，就可以进行添加(git add)，提交(git commit)。当然，一般不常用git diff的，因为自己修改的东西自己心里总有点数吧，可能合作中团队的其他人需要查看文件前后的不同点就需要用到git diff啦。 版本回退为了方便讲解下版本回退，我先将上面添加的### first change提交以下–git add . &amp;&amp; git commit -m &quot;add first change&quot;。下面通过git log就可以查看自己提交的记录了。 1234567891011121314151617181920212223$ git logcommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md $ git add . &amp;&amp; git commit -m "add first change"[master 0ac49ba] add first change 1 file changed, 3 insertions(+), 1 deletion(-) $ git logcommit 0ac49bae6ab55df9c05d0770de347665a2568f31Author: reng99 &lt;1837895991@qq.com&gt;Date: Mon Dec 18 15:26:06 2017 +0800 add first changecommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md 在上面中，自己先执行了git log来显示提交的日志，显示只有一条，然后执行了add和commit的命令，打印的内容是现实主分支、commit的id、commit的信息、多少个文件的更改、多少个插入以及多少个删除。之后再次执行git log打印日志，显示了两次提交。⚠️ 注意：当提交(commit)的次数较多之后，控制台会显示不下（最多现实4条）那么多的条数，可以通过按键盘的向上或向下键查看日志的内容，需要退出查看日志命令的话，在英文输入法的状态按下q，意思就是quit(退出)。 版本的回退就是改变HEAD指针的指向。通过git reset --hard HEAD^返回上一个版本，通过git reset --hard HEAD^^返回上上个版本…由此推论，往上100个版本的话就是100个^，当然，这样你数到明天也未必数得正确，所以写成git reset --hard HEAD~100。另外一种是，你知道提交的id，例如commit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67的前7位就是commit的id(5c2639e)，执行git reset --hard 5c2639e就回到此版本啦。 123456789101112$ reng$ git reset --hard HEAD^HEAD is now at 5c2639e init README.md$ git logcommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md$ lsREADME.md$ cat README.md## content 现在你已经回到了最初的版本，这里演示的是通过HEAD，你也可以通过commit id来实现的。执行上面的代码后，README.md文件里面只有一### content文字内容,但是过了段时间后，你想恢复到原先的版本，通过git log命令行，控制台显示的以前的信息，通过它找不到回退前的commit id，怎么办？GIT提供一个git reflog显示提交的历史记录，在那里可以查看提交的id、HEAD的指针历史和操作的信息记录。下面演示回退到最新的版本（也就是commit -m “add first change”）– 123456789101112131415161718$ git logcommit 5c2639ee54bd7c8ef2cbf186f5dc4798e72a4a67Author: reng99 &lt;1837895991@qq.com&gt;Date: Sun Dec 17 17:11:53 2017 +0800 init README.md$ git reflog5c2639e HEAD@&#123;0&#125;: reset: moving to HEAD^0ac49ba HEAD@&#123;1&#125;: commit: add first change5c2639e HEAD@&#123;2&#125;: commit (initial): init README.md$ git reset --hard 0ac49baHEAD is now at 0ac49ba add first change$ lsREADME.md$ cat README.md## content### first 现在又回到了最新的版本，又能够愉快的玩耍了。😊 管理修改GIT比其他版本控制系统设计优秀，其中一点是–GIT跟踪并管理的是修改，而非文件。 下面在README.md内添加信息### second change。之后看下变化后的文件的状态和差异等。 123456789101112131415161718192021222324$ lsREADME.md$ cat README.md## content### first change#### second change$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")$ git add README.md$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md 此时，对README.md进行第三次的修改，添加内容### third change。 123456789101112131415161718192021222324252627282930313233$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.md$ cat README.md## content### first change#### second change### third change$ git commit -m "test file modify"[master 18f86ba] test file modify 1 file changed, 3 insertions(+), 1 deletion(-)$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a") 上面的演示流程是这样的第一次修改(#### second change) -&gt; git add -&gt; 第二次修改(### third change) -&gt; git commit。但是最后查看状态的时候(git status)，第二次的修改并没有被提交上去。因为GIT管理的是修改，当使用git add命令的时候，在工作区的第一次修改被放入暂存区，准备提交，但是在工作区的第二次修改并没有放入到暂存区，而git commit是将暂存区的修改提交到GIT仓库，所以第二次修改的内容是不会被提交的。这也是说明为什么可以多次添加(git add)，一次提交(git commit)的原因了。 撤销修改文件的撤销修改分成三种情况，一种是修改在工作区的内容，一种是修改在暂存区的内容，另一种是修改在GIT仓库的内容。也许会有看者说，不能修改在远程库中的内容吗？有啊，就是git add-&gt;git commit-&gt;git push将远程仓库的内容覆盖被，不过团队人在克隆远程库下来的时候，还是可以查看到你提交的错误内容的。我们现在只针对本地仓库的三种情况谈下自己的看法– 情况一：撤销工作区的内容 在管理修改中，自己的工作区还是没有提交，此时想放弃当前工作区的编辑内容执行git checkout -- file。接着上面的内容，我这里的工作区内有的内容是### third change，现在我要放弃第三次修改，只要执行git checkout -- README.md就可以了。 1234567891011121314151617181920212223242526272829$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")$ lsREADME.md$ cat README.md## content### first change#### second change### third change$ git checkout -- README.md$ cat README.md## content### first change#### second change$ git statusOn branch masternothing to commit, working tree clean 情况二：撤销暂存区的内容 当你不但改乱了工作区的某个文件的内容，还添加(git add)到了暂存区时，想丢弃修改，那么得分两步来撤销文件。先是通过git reset HEAD file，将暂存区的文件退回到工作区，然后通过git checkout -- file放弃修改改文件的内容。为了方便演示，我这里的暂存区没什么内容，所以添加内容### tentative content并将它添加到缓存区。之后，演示将缓存区的内容撤回– 1234567891011121314151617181920212223242526272829$ cat README.md## content### first change#### second change### tentative content$ git add .$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md$ git reset HEAD README.mdUnstaged changes after reset:M README.md$ git checkout -- README.md$ cat README.md## content### first change#### second change$ git statusOn branch masternothing to commit, working tree clean 情况三：撤销GIT仓库的内容 如果你不仅添加(git add)了内容到暂存区并且提交(git commit)了内容到GIT仓库中了。你需要撤销上一次的内容，也就是要回退到上一个版本，执行git reset --hard HEAD^就可以啦，详细的内容查看版本回退。如下– 123456789101112131415$ git statusOn branch masternothing to commit, working tree clean$ cat README.md## content### first change#### second change$ git reset --hard HEAD^HEAD is now at 0ac49ba add first change$ cat READMEmd## content### first change 远程仓库远程仓库的使用能够提高你和团队的工作效率，无论何时何地，团队的人员都可以在联网的情况下将代码进行拉取，修改和更新。因为我是使用github来管理项目的，所以我的远程仓库是放在github里面。这里默认看者已经安装了github，当然也可以用码云、gitlab等。 本地库添加到远程库这点很容易，登录自己注册的github，如果打不开，请开下VPN。进入自己的首页(https://github.com/username)，点击`+`号创建(new repository)一个名为learngit的仓库(注意哦⚠️ 名称是本地仓库已经初始化过的，我这里本地有个同名初始化的learngit仓库)，其他的字段自选来填写。点击Create repository创建此远程仓库。紧接着就是进行本地仓库和远程仓库的关联啦，github很友好的提示了你怎么进行一个远程仓库的关联。 现在按照上图来关联下远程仓库。 12345678910$ git remote add origin https://github.com/reng99/learngit.git$ git push -u origin masterCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (6/6), 456 bytes | 0 bytes/s, done.Total 6 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit.git * [new branch] master -&gt; masterBranch master set up to track remote branch master from origin. 注意⚠️ 第一次向远程仓库（关联）push的时候是$ git push -u origin master，不能忽略-u，以后的push不用带-u。至此，打开你的github的相关的仓库就可以看到添加了README.md文件，我这里地址是https://github.com/reng99/learngit，因为我是使用markdown语法写的，控制台显示的内容和仓库的显示内容有所区别啦。(⚠️ 后期我将learngit仓库删除啦，所以你访问链接是找不到这个仓库的，毕竟不想放一个没什么内容的仓库在我的github上)。 远程库克隆到本地从远程仓库克隆东西到本地同样很简单，只需要进入你想克隆的仓库，将仓库的url复制下来（当然你也可以复制window.location.href的内容），运行git clone address。现在我将本地桌面的learngit的仓库删除，然后从远程将learngit克隆到本地。 12345678910$ cd desktop$ rm -rf learngit$ find learngitfind: learngit: No such file or directory$ git clone https://github.com/reng99/learngitCloning into 'learngit'...remote: Counting objects: 6, done.remote: Compressing objects: 100% (2/2), done.remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0Unpacking objects: 100% (6/6), done. 成功将gitlearn从远程克隆下来，接下来又可以愉快的玩耍啦。 分支管理分支管理允许创建另一条线/方向上开发，能够让你在不影响他人工作的情况下，正常的工作。当在自己创建的分支中完成自己的功过后，合并到主分支就行了(git init初始化的时候已经默认创建了master主分支)。一般团队的合作是不在主分支上进行的，个人项目除外（个人理解）。 创建分支当前learngit仓库上只有一个分支，那就是master分支，看者可以通过git branch命令来查看当前的分支，git branch branchName命令来创建一个新的分支，我这里创建的是dev分支。 1234567$ cd desktop/learngit$ git branch* master$ git branch dev$ git branch dev* master 现在已经创建了dev分支，有两个分支了，分支前面带有一个星号的分支说明是当前的正在工作的分区。执行上面的分支后，可以简单的画下现在的情况了，有个HEAD指针指向主分支的最新点，刚才新创建的dev分支我这里默认是一个dev的指针指向了dev分支的最新点。 1234567.. HEAD指针. │├────────*master└────────dev │ dev指针 切换分支我们一般是很少在主分支进行工作的，所以在创建出新的分支之后，我们就切换到新的分支进行相关的工作。可以通过git checkout branchName切换到已经存在的分支工作，通过分支前面的*可查看目前位于哪个分支内。现在我切换到创建的dev分支。 12345678$ git branch dev* master$ git checkout devSwitched to branch 'dev'$ git branch* dev master 合并分支在创建好分支后，我们在新的分支上工作完成后，就需要往主分支上进行合并啦。我修改了分支dev上的README.md的内容，就是添加文字### new branch content。合并分支可以分成两个合并的方式，一种是本地合并到materz主分支之后，推送(push)到远程库，一种是直接将分支推送到远程库，在远程库进行合并。 本地合并推送 在合并分支前，需要切换到要合并到哪个分支(一般是master主分支)，通过git merge branchName将需要的合并的分支合并到当前分支，我是将dev分支合并到master分支。 123456789101112131415161718192021$ git branch* dev master$ git checkout masterM README.mdSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ git merge dev$ Already up-to-date.$ git add .$ git commit -m "merge dev branch"[master d705e73] merge dev branch 1 file changed, 3 insertions(+), 1 deletion(-)$ git push origin masterCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 282 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit 0ac49ba..d705e73 master -&gt; master 合并之后,此时，HEAD指针就指向了dev指针，也就是两者同时指向了master主分支的最新处。具体的内容参考传送门 1234567.. . ├────────*master└────────dev │ dev指针 ── HEAD指针 远程库推送合并 远程库内合并的话，要先将dev的分支推送到远程库，然后在远程库进行合并。我这里在dev分支上添加了### add new branch content into again然后demo演示推送(git push origin dev)以及合并。 1234567891011121314151617$ git branch dev* master$ git checkout devSwitched to branch 'dev'$ git add .$ git commit -m "add dev branch commit again"[dev dc817c4] add dev branch commit again 1 file changed, 3 insertions(+), 1 deletion(-)$ git push origin devCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 300 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit * [new branch] dev -&gt; dev 接下来就是进入我的远程learngit仓库进行合并，你会看到下面图示的提示。点击Compare &amp;&amp; pull request，然后写点相关的comment（选填），点击Create pull request。之后在绿色勾的提示下Merge pull request，紧接着点击Confirm merge按钮确定合并此分支，这时候返回主分支就可以看到dev内合并的内容了(后期我改动了dev的内容)。看者如果看得不明白，自己上手尝试一下呗！ 完成后，你会看到learngit仓库的Pull requests量为1，branches量为2。你可以点击进入分支，在ALL branches里面查看分支的具体内容。 删除分支在创建了分支，然后将分支的内容合并到主分支后，分支的使命就完成了，你就可以将分支删除了，这里的删除个人认为可以是两种，一种是本地仓库的分支删除，一种是远程仓库的分支的删除。当然啦，留着分支也没啥，可以留着呗，自己认为有点碍眼。 本地分支的删除 在本地的learngit的目录下，执行命令行git branch -D branchName就可以删除了。我这里删除的是dev分支。注意⚠️ ，删除的分支不应该是当前工作的分支，需要切换到其他分支，我这里切换的是master分支，毕竟我只有两个分支呢。 123456789101112131415$ git branch* dev master$ git branch -D deverror: Cannot delete branch 'dev' checked out at '/Users/reng/desktop/learngit'$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ git branch dev* master$ git branch -D devDeleted branch dev (was dc817c4).$ git branch* master 远程库分支的删除 删除远程库的分支，只要执行git push origin :branchName命令就行了。现在我要删除我远程库中的dev分支，执行git push origin :dev。 123$ git push origin :devTo https://github.com/reng99/learngit - [deleted] dev 此时，打开我的远程库learngit，发现之前的Pull requests量为0，branch量为1。 重命名分支通过git branch -m oldBranchName newBranchName来重命名分支。我这里没有分支了，现在创建一个reng分支，然后将它重命名为dev分支。 12345678910$ git branch* master$ git branch reng$ git branch* master reng$ git branch -m reng dev$ git branch dev* master 解决冲突在我们开发的时候，不知道分支和分支之间的进度情况是什么，难免会产生冲突。当产生冲突的时候，就得将冲突的内容更正，然后提交。为了方便演示，我将本地的learngit删除，重新拉取远程的gitlearn仓库(因为我不知道我之前在本地仓库做的修改是啥，对了，我将远程的分支删除了，只剩下master主分支)。克隆下来后，如果还存在本地分支，也将它删除，之后我将在master和dev分支中重新填充里面的README.md的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$ cd desktop$ git clone https://github.com/reng99/learngit.gitCloning into 'learngit'...remote: Counting objects: 43, done.remote: Compressing objects: 100% (17/17), done.remote: Total 43 (delta 4), reused 38 (delta 1), pack-reused 0Unpacking objects: 100% (43/43), done.$ cd learngit$ git branch* master$ lsREADME.md$ cat README.md## master branch content$ git add .$ git commit -m "add master branch content"[master 1cfa0aa] add master branch content 1 file changed, 1 insertion(+), 1 deletion(-)$ git push origin masterCounting objects: 3, done.Writing objects: 100% (3/3), 271 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/reng99/learngit.git d2f936f..1cfa0aa master -&gt; master$ git branch dev$ git checkout devSwitched to branch 'dev'$ cat README.md## master branch content### dev branch content$ git add .$ git commit -m "add dev branch content"[dev 80faf6d] add dev branch content 1 file changed, 2 insertions(+)$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ cat README.md## master content### new master branch content$ git add .$ git commit -m "change master content"[master ec18715] change master content 1 file changed, 3 insertions(+), 1 deletion(-)$ git merge devAuto-merging README.mdCONFLICT (content): Merge conflict in README.mdAutomatic merge failed; fix conflicts and then commit the result. README.md文件中冲突内容– 123456789&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD (当前更改)## master content### new master branch content=======## master branch content### dev branch content&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev (传入更改) 手动修改了README.md文件中冲突的内容– 123## master branch content### new master branch content### dev branch content 然后命令行执行– 12345678910111213141516171819202122232425262728$ git add .$ git commit -m "fix confict content"[master dd848b4] fix confict content$ git log --graph* commit 980788b7690d8bcf14610072fc072460bee7e9f1|\ Merge: c49d09e 2929dca| | Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Thu Dec 21 11:14:10 2017 +0800| | | | fix confict content| | | * commit 2929dca91ef8f493adba7744cdad19656538334f| | Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Thu Dec 21 11:11:49 2017 +0800| | | | add dev branch content| | * | commit c49d09e33e7098d67b59c845d18e9c6f8a8f4fea|/ Author: reng99 &lt;1837895991@qq.com&gt;| Date: Thu Dec 21 11:12:50 2017 +0800| | change master content| * commit b07f0be8280e4e437cccf2a3f8fac6beef03ff41| Author: reng99 &lt;1837895991@qq.com&gt;| Date: Thu Dec 21 11:10:51 2017 +0800| : 上面操作过程是，我先从远程库中克隆learngit仓库到本地，目前的本地learngit的分支只有master分支，然后我在master分支的README.md中添加相关的文字(见代码)，接着把它推送到远程库。然后创建并切换dev分支，在README.md文件中添加新内容(见代码)，接着将它提交到GIT仓库。又切换到master分支，修改README.md到内容(见代码)，提交到GIT仓库后开始执行merge命令合并dev分支的内容。此时，产生了冲突，这就需要手动将冲突的内容解决，重新commit到GIT仓库，最后你就可以提交到远程库了(这步我没有演示，也就是git push origin master一行命令行的事情)。最后我还使用git log ----graph打印出整个分支合并图(从下往上看)，方便查看。⚠️ 此时退出git log --graph是书写英文状态按键盘的q键。 说这么多，目的只有一个 –&gt; 产生冲突后，需要手动调整😊 分支管理策略先放上一张分支管理策略图，然后再慢慢讲解相关的内容… 在分支管理中，我们不断的新建分支，开发，合并分支，删除分支的操作。这里需要注意合并分子的操作，之前我们进行分支的时候是直接将dev开发的分支使用git merge dev进行合并，这样有个缺点：我们看不出分支信息。因为在默认情况下，合并分支的时候，GIT是使用了Fast Foward的模式，在这种模式下，删除分支后，会丢掉分支的信息。下面我重新克隆下我远程learngit仓库，然后创建并更改dev分支的信息，使用默认的模式进行合并。 12345678910111213141516171819202122232425262728293031$ git branch* master$ git branch dev$ git checkout devSwitched to branch 'dev'$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content$ git add .$ git commit -m "add new dev contentt"[dev 750e1f1] add new dev content 1 file changed, 1 insertion(+)$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ git merge devUpdating 980788b..750e1f1Fast-forward README.md | 1 + 1 file changed, 1 insertion(+)$ git log --graph* commit 750e1f17854872eed4d6cff8315e404079ecb18f| Author: reng99 &lt;1837895991@qq.com&gt;| Date: Fri Dec 22 10:05:36 2017 +0800| | add new dev content| * commit 980788b7690d8bcf14610072fc072460bee7e9f1... 上面的合并就是将master分支上面的HEAD指向dev指针，如下： 123456789101112131415161718192021222324252627# 记录是从上往下- before merge master * (begin) | | * \ \ * | | * (end) dev - after merge master * (begin) | | * | | * | | * (end) 为了保留分支的情况，保证版本演进的清晰，我们就得使用普通模式合并，也就是在Fast Foward的模式基础上加上--no-ff参数，即git merge --no-ff branchName，不过我们一般加上你合并的相关信息，即git merge --no-ff -m &quot;your msg here&quot; banchName。现在更改dev分支的内容，再进行合并。 123456789101112131415161718192021222324252627282930313233343536$ git checkout devSwitched to branch 'dev'$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content### merge with no-ff$ git add .$ git commit -m "add no-ff mode content"[dev 80b628c] add no-ff mode content 1 file changed, 2 insertions(+), 1 deletion(-)$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 1 commit. (use "git push" to publish your local commits)$ git merge dev --no-ff -m "merge with no-ff" devMerge made by the 'recursive' strategy. README.md | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-)$ git log --graph* commit 98746d93a9b64ea02b8ff1c7f0fa5e915405c0e6|\ Merge: 750e1f1 80b628c| | Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Fri Dec 22 14:39:32 2017 +0800| | | | merge with no-ff| | | * commit 80b628c334618711b77da81fa805ffc246a2cf7d|/ Author: reng99 &lt;1837895991@qq.com&gt;| Date: Fri Dec 22 14:38:17 2017 +0800| | add no-ff mode content| * commit 750e1f17854872eed4d6cff8315e404079ecb18f... 使用--no-ff参数的普通模式合并，会执行正常合并，在master主分支上面会生成一个新的节点，如下（我上面的分支管理策略图里面的合并就是使用了普通的模式）： 12345678910111213141516# 记录是从上往下- --no-ff合并 master * (before) | | * |\ | \ | *dev | | | | | * | / |/ * (after) 我们在开发中，分支管理可以分成master主分支、dev开发分支、feature功能分支、release预发布分支、hotfixes修补bug分支。其中功能分支、预发布分支和修补bug分支可以归为临时分支。临时分支在进行分支的合并之后就可以被删除了。下面就一一讲解自己眼中的各种分支。 主分支master主分支是在你初始化仓库的时候(git init)，自动生成的一个master分支，删除不了的哦（演示待会给）。主分支是有且仅有一个，也是发布上线的分支，团队合作的最终代码都会在master主分支上面体现出来。也许你也注意到了分支管理策略图里面的主分支会被打上TAG的标签，这是为了方便到某个时间段对版本的查找，标签tag的学习总结后面给出。 1234567891011# 记录是从上往下 master | | *(tag 1.0) | | *(tag 1.1) | | *(tag 1.2) 下面代码演示下不能放删除master的情况: 123456$ cd learngit$ git branch dev* master$ git branch -D mastererror: Cannot delete branch 'master' checked out at '/Users/reng/desktop/learngit' 开发分支develop在开发的过程中，项目合作者应该保持自己本地有一个开发环境的分支，在进行分支开发之前，需要进行git pull拉取master主分支的最新内容，或者通过其他的方法。在获取到最新的内容之后才可以进行本地的新功能的开发。在开发完成后将内容merge到主分支之后，不用将dev分支删除，因为你开发的就是在这里进行，何必删除后再新建一个开发环境的分支呢。 接着上面的情况，我目前已经拥有了dev开发分支: 1234$ cd learngit$ git branch dev* master 功能（特性）分支feature一个软件就是一个个功能叠加起来的，在软件的开发中，我们总不能在主分支开发，将主分支搞乱吧。当然，你可以在dev分支中开发，一般新建功能分支来开发，然后功能开发完再合并到dev分支，之后删除功能分支。需要的时候就可以将dev开发分支合并到master主分支，这样就随时保证dev分支功能的完整性。 下面演示功能分支user开发（随便写点内容）的合并（这里也演示了合并到master主分支，跳过了release分支的测试），删除。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364$ git checkout devSwitched to branch 'dev'$ git branch user$ git branch* dev master user$ git checkout userSwitched to branch 'user'$ cat README.md## master branch content### new master branch content### dev branch content### new dev branch content### merge with no-ff### function user$ git add .$ git commit -m "function user was acheive"[user 26beda3] function user was acheive 1 file changed, 2 insertions(+), 1 deletion(-)$ git checkout devSwitched to branch 'dev'$ git merge --no-ff -m "merge user feature" userMerge made by the 'recursive' strategy. README.md | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-)$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 3 commits. (use "git push" to publish your local commits)$ git merge --no-ff -m "merge dev branch" devMerge made by the 'recursive' strategy. README.md | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-)$ git log --graph* commit f15a1e9012635fc21e944ab76c4cd4bbd539f82f|\ Merge: 98746d9 0ca83c6| | Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Fri Dec 22 16:35:43 2017 +0800| | | | merge dev branch| | | * commit 0ca83c654df64724743a966f5f0989477e504cbc| |\ Merge: 80b628c 26beda3| | | Author: reng99 &lt;1837895991@qq.com&gt;| | | Date: Fri Dec 22 16:33:27 2017 +0800| | | | | | merge user feature| | | | | * commit 26beda3b8246e047f10ac0461ca11d1a6f132819| |/ Author: reng99 &lt;1837895991@qq.com&gt;| | Date: Fri Dec 22 16:31:41 2017 +0800| | | | function user was acheive| | * | commit 98746d93a9b64ea02b8ff1c7f0fa5e915405c0e6|\ \ Merge: 750e1f1 80b628c| |/ Author: reng99 &lt;1837895991@qq.com&gt;:$ git branch -D userDeleted branch user (was 26beda3).$ git branch dev* master 预发布分支release在进行一系列的功能的开发和合并后，在满足迭代目标的时候，就可以打包送测了。这里就需要一个预发布分支release。预发布分支是指在发布正式版本之前（ 即合并到master分支之前，可查看上面分支管理策略图），需要一个有预发布的版本（可以理解为灰度环境）进行测试。 预发布环境是从dev分支上面分出来的，预发布结束之后，必须合并到dev和master分支上面。这里我就不演示了，跟功能分支差不多，就是合并的时候要合并到dev和master上，这时候dev分支和master的同步的代码，就不需要将dev分支合并到master了。最后将预发布分支删除掉。 修复bug分支 bug/hotfixes修复分支…有待完善 参考内容廖雪峰官方网站–Git教程 易百教程–Git教程 git官网 分支管理模型图 精力有限，未能一次性更新完，请见谅…]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桂林阳朔旅游]]></title>
    <url>%2F2017%2F12%2F04%2Ftourist-guiLin-and-yangShuo%2F</url>
    <content type="text"><![CDATA[桂林市区的两江四湖的夜景很美丽，还有桂林市区的一些步行街走起来挺舒服的。然后就是阳朔啦，我喜欢那山里的清新的空气(哈哈哈，不过，我更喜欢家里海边的空气)。在山里面就好像与世隔绝，可能一个人在喧闹的城市呆久了，都会喜欢吧。⚠️ 多图博文，手机党要留意咯。 此次的桂林阳朔之旅三个人一起游玩放松，一个是好友从柳州过来桂林，另一个本身就在桂林读研究生，还有我啦–从广州这边过去呗，一共在那边呆三天，两天桂林市区(2017.12.01 &amp;&amp; 2017.12.03)和一天阳朔(2017.12.02)。 这次不像丹霞山旅游的流水帐那样写游记啦，仅仅谈下个人在阳朔的感受，桂林市区的没啥好谈的，毕竟是市区，都那样。 也许在广州呆的时间久了的原因，去到阳朔有不一样的体验—-第一次进山的新鲜感。第一次来阳朔，除了玩了一下当地人推荐的旅游的项目，比如坐竹筏游漓江啊。我比较喜欢租电驴(电动摩托)在山间闲逛一个下午的那段经历。哈哈,带着感冒开了一个下午。 开着电驴，进入山里面闲逛，没有目标，没有时间观念，抛离城市的喧闹与繁华。山里面的空气超级好，活脱一个天然的氧吧。自己开开停停，哎呀，这里的风景不错哦，那座山还行哦，这湖賊好看，这里有活动…嗯，我们就缺了个单反，还有如果朋友再高点，再瘦点，脸再…哈哈哈，我就有模特啦，不过手机拍出来的效果还不赖啦(本博文的照片都是用自己的手机拍的啦)。在阳朔的山间看到了一个新人在取景拍婚纱照，看到了骑着自行车的几个外国人在标着村上春树字样的山间小屋前面停下来欣赏，吃了当地阿婆自己种的柚子(虽然有些皱皮，时间久了，但是还是挺美味的啦)，感受到了山里人慢节奏的生活…嗯，没有更多的详细内容，要具体展开的话，我可以写一万字，看者可以亲自去体会下啦。 下面放上自己觉得还可以的照片啦—- 文章的结尾简单谈下自己的一些攻略： 广州出发的话，要提前坐交通工具到广州南站坐高铁，自己就是刚踩点过了安检，感觉就是在作死啊 广州南站出发到桂林，建议买到桂林站(其次是桂林北)，因为你可以在那边比较方便在繁华的地方租到房子，费用大概¥ 100/晚。当然啦，选择旅游淡季去，并且选择网购旅店，实体店买贵了¥40（我选择在西城步行街那里的青皮树酒店住下，网购¥99/晚，在那里可以逛夜市，并且离两江四湖比较近） 从桂林市区去阳朔的话，选择滴滴顺风车（免费为滴滴打了一波广告），选择滴滴，当然是因为实惠啦，如果正常坐大巴过去阳朔的话，时间和金钱成本有所提升（看者可以自行比较呢）,我们从西城步行街滴滴顺风车过去阳朔的时间是一个小时左右，费用是¥33/人。从阳朔回来也是坐滴滴的顺风车。 在阳朔玩的时候，可以租借电驴（电动摩托）去玩，我们当初是¥40元/辆滴滴司机说淡季一般是¥30/辆，看你砍价啦，我们从¥50/辆降到¥40/辆，其他的景点看兴趣选择，进山必须是电驴啊，骑自行车踩累死你啦。 偶尔光顾阳朔街边的老奶奶老爷爷大叔大婶（请允许我这样称呼，年轻人没看到几个在路边摆摊的） 就餐的话，在桂林我推荐的是椿记烧鹅（倒数第二张餐厅图就是它）,在阳朔只要不在西街的饭店里面吃就行(我们在饭店里面被坑了一次，东西贵而且味道不咋样，本来朋友要拉我走的，我都还没反应过来就点餐了) 先就这么多攻略吧，后期如果有发现其他实用的我再放上去啦！😊 欢迎看者补充啦。]]></content>
      <categories>
        <category>诗和远方</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0 踩坑记]]></title>
    <url>%2F2017%2F11%2F27%2Fvue-attention%2F</url>
    <content type="text"><![CDATA[自己接触vuejs将近一年，在这段时间里面，一共参与了公司以vuejs技术为框架的两个项目—-工单系统（公司内部项目，不方便贴链接）和淘米淘手游交易平台移动端（未上线）。本文是自己在使用vuejs开发过程中踩到的坑，特此记录下来的文章。嗯，希望对相关的技术爱好者有所帮助啦（如果你知道我在讲什么的话） 😊 对了，在开始写文章之前，先说明下: 文章里面的代码，是在.vue后缀的文件中实现的，在脚手架vue-cli搭建的项目上已经验证过，如有疑问，请自行验证或者在文章底部留言功能那里留言(仅支持github账号用户),或者邮箱留言(1837895991@qq.com)哦。 父组件传递消息给子组件使用props，下面先来看一个简单的例子: 父组件: parent.vue 123456789101112131415161718192021&lt;template&gt; &lt;div id="parent"&gt; &lt;child-component :title='parentTitle' /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childComponent from '@/components/path/to/childComponent.vue' export default &#123; data () &#123; return &#123; title: 'title form parent' &#125; &#125;, components: &#123; childComponent &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; #parent&#123;&#125;&lt;/style&gt; 子组件: childComponent.vue 1234567891011121314151617181920212223&lt;template&gt; &lt;div id="child"&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; &#125; &#125;, props: &#123; title: &#123; type: String, // 可设置类型 default: 'title from child' // 默认值 &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; #child&#123;&#125;&lt;/style&gt; 最后显示的结果是父亲传过来的消息，即信息为title form parent的h1标题。在父组件向子组件传递消息的过程中，首先，父亲需要拿到子组件&lt;child-component /&gt;,然后告诉子组件我要传递一个title给你:title=&#39;parentTitle&#39;，注意查收。接着，子组件通过props新建一个title的属性，并将数据读取到数据填充到相应的位置。详情看官网Prop 子组件传递消息给父组件子组件是通过$emit向父组件发送事件和相关的数据，来传递信息给父组件。 子组件(child.vue)的demo代码如下: 123456789101112131415161718192021&lt;template&gt; &lt;div id="child"&gt; &lt;button @click="toParent"&gt;向父组件传递消息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "child", data () &#123; return &#123; message: 'message from children' &#125; &#125;, methods: &#123; toParent () &#123; var vm = this; vm.$emit('child-say',vm.message); &#125; &#125; &#125;&lt;/script&gt; 父组件demo代码如下： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id="parent"&gt; &lt;child-component :child-say="parentEvent" /&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import childComponent from '@/components/path/to/child.vue'; export default &#123; name: 'parent', data () &#123; return &#123; msg : '' &#125; &#125;, methods: &#123; parentEvent: function (data) &#123; // data 是子组件传过来的数据 var vm = this; vm.msg = data; &#125; &#125;, components: &#123; childComponent &#125; &#125;&lt;/script&gt; 上面代码的过程是，点击了子组件里面的向父组件传递消息的按钮，将子组件里面的message信息放在$emit里面发送给父组件，而父组件在引用的子组件中新建一个事件来接受传过来的信息，然后在父组件中创建的方法对data里面的msg进行数据的改写。最终在页面上显示出的h1标题信息为message from children，即是子组件里面的信息。嗯，官网相关传送门 绑定HTML Class类名结合style的使用一般是用来动态改变样式，所以要用到v-bind:class简写:class。 demo如下: 12345678910111213141516171819202122232425&lt;template&gt; &lt;button class="default-bg" :class="&#123;'active-bg':flag&#125;" @click="changeBtnBg"&gt;按钮&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; flag : false &#125; &#125;, methods: &#123; changeBtnBg: function () &#123; vm.flag = true; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .default-bg&#123; background: red; &#125; .active-bg&#123; background: blue; &#125;&lt;/style&gt; 上面代码中，实现了一个红色按钮通过点击自身实现变成绿色按钮的功能。首先，自己给到一个默认的红色的按钮，并且在按钮上绑定了changeBtnBg的方法，用于控制标志符flag的布尔值。值得注意的是，:class通过flag的真假值来决定是否改变按钮的背景色为定义的绿色。官网相关请戳这里 v-model引用的数据需初始化也许你遇到这个问题，命名写了&lt;input type=&quot;text&quot; v-model=&quot;inputMsg&quot; /&gt;,可是相关的数据绑定&lt;div&gt;&lt;/div&gt;却没有消息，并报错。这是因为你还没有初始化相关的数据啊。正确的姿势应该像下面👇 12345678910111213&lt;template&gt; &lt;input type="text" v-model="inputMsg"/&gt; &lt;div&gt;&#123;&#123;inputMsg&#125;&#125;&lt;div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; inputMsg : '' // 记得初始化数据哦 &#125; &#125; &#125;&lt;/script&gt; style中的scoped也许你注意到了我上面的代码中，在每个&lt;style&gt;&lt;style&gt;的元素中添加了scoped。scoped是用来限定样式的作用的范围，防止此组件里面的样式和其他组件的同名的样式产生冲突。比如—- component1.vue 12345678&lt;template&gt; &lt;h1 id = "title"&gt;component1's title&lt;/h1&gt;&lt;/template&gt;&lt;style scoped&gt; #title&#123; color: red; &#125;&lt;/style&gt; component2.vue 12345678&lt;template&gt; &lt;h1 id="title"&gt;component2's title&lt;/h1&gt;&lt;/template&gt;&lt;style scoped&gt; #title&#123; color: blue; &#125;&lt;/style&gt; 在上面的两个组将component1.vue &amp;&amp; component2.vue中，虽然都有相同的id，但是对各自没什么影响。简单说，加上scoped之后，样式的编写只对本组件有效。 精力有限，未能一次性更新完,忘见谅…]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丹霞山旅游]]></title>
    <url>%2F2017%2F11%2F26%2Ftourist-danXia-mountain%2F</url>
    <content type="text"><![CDATA[由于公司的项目–淘米淘手游交易平台,自己已经有三个月没有离开过广州游玩了。刚好项目自己负责的部分已经ok，然后好友约了周末(2017.10.28～2017.10.29)去韶关爬丹霞山，自己不假思索的答应了！ 我们是四个人一同前往—-两位女生两位男生，同行的四个人中，我只认识我的好友(那个肥嘟嘟脸的男生)，不认识两位女生，因为在旅行完之后没有联系了，忘了她们的名字了，暂且用女生A(戴帽子笑起来很甜的女生)和女生B(一直被吐槽摆不好poss的女生😂 )来区分吧。四人组见下图 : 女生A : 好美啊！空气很好女生B : 周末来得值啊，下次还来好友 : 这山爬得都不累我 : 能在这里住真是超级幸福的…以下省略若干在归途中的对话。是啊，这趟来得很ok啊，重阳节在这么美的地方爬山，真的是超级满足的呢。 我们这两天的计划是，去山顶上看日落和日出，剩下的时间就是在山间闲逛，感受自然。计划如此，除了没能在山顶（人太多，登不上阳元山的顶部看日落，只能够在山腰山看日落了）。 我们早上从广州火车站出发，坐火车直达韶关东，然后坐大巴去丹霞山，买了低配版的门票（150元/人的48小时有效的票）进入丹霞山里面，在兜兜转转后还是女生B电话给来过的同事请教攻略，果断的拒接了在景区山脚下拉客的旅店店主，坐着免费的公交（其实费用包含在票价里面了）兜兜转转的去到被推荐的景区里面当地人的旅店住下。此刻必须赞一下店主啊—-因为我们选好房间后，直接将随身带的行李放到各自的房间后就去吃午餐了没登记个人信息，但是店主知道有人介绍过来的并没有叫我们返回登记，还有店主很是热心的比划着路线给我们。对了，我们住的店是放假啦客栈，租了两间双人房（100元/天，ps:当地人的房子改装的租房，整片区域的价格都差不多）。 来到丹霞山的第一天，简单的吃了顿午饭，我们一行四人就奔着看日出的地点长老峰那里踩点去了，因为观日出的地方阳元山在另一边，得提前熟悉下呢。然后我们就坐车返回原地走路去阳元山看日落，可能我们去的比较晚又加上那天是重阳节,人多得我们上不了山顶，只能在山腰上观看了。对了，比较逗的是，爬阳元山的女生A因为山路陡恐高症瞬间爆发，腿软难以前行。 第二天早上，我们五点就起床等车去长老峰看日出，这个点，公交的站点已经聚集了些人，此时天空还是可以看到星星几点。我们被送到长老峰不远处的终点站，大概是5:40分开始刷票进入长老峰，并沿着路灯一路爬上山顶。漆黑的凌晨借助着微弱的灯光，小心翼翼的爬着陡峭的山路，一大早就出着汗，还是第一次。我们爬到山顶的时候，有很多的人已经在山顶的平台了，我们很是难挤到里面去（对了，有人山顶上依靠帐篷过夜的）。选好一个不错的位置，在天边泛白的时候，踮着脚尖，看着太阳慢慢的奔出来，很是满足。 之后，在日出一段时间后，我们便下山根据地图，依据着店主推荐的路线去逛下其他的风景，神奇的是，我们真能走，又闲逛了好远的地方，期间自己还担任了女生A的摄影师，哈哈哈，我的拍照技术还是ok的啦。四人组边走边聊，从本来有些约束到自然交流，在山间中走动，那山很俊，那林很绿，那水很清，倍感轻松😄 对了，在吃的方面，我们在同一家店吃了走地鸡，味道棒棒的（原谅我忘记了店名），还有客家三宝这道菜，自己蛮喜欢的。 时间到了29号三四点的时候，我们就启程离开景区回广州了，结束丹霞山的两日游。 在本次的游玩中，自己整理了点旅游攻略，希望对见者有帮助或者重游的时候有提示： 提前两三天联系景区的旅店老板，定好房间。有下面的原因： 1231. 景区内和景区外的住房的价格是相差不大的，尽量在景区内订房，这样会节省你很多的时间2. 需要提前联系旅店的老板帮你定景区的票，这样会为你省下不少的经费（吐槽下，外来人的票价和当地人的票价相差太远）3. 寻找有去过丹霞山的朋友，取一下当初居住的旅店的老板的联系方式，在那里订房会得到一定程度的照顾 两天时间丹霞山游玩足够 过去韶关的话，如果经济条件还可以的话，还是不要选择火车吧 不要在什么国庆节啊节日过去，尽量选择周末 多多欣赏自然风光，拍照不游玩，游玩不拍照 学好拍照技术出去玩会更加惬意哦(带上专业的摄像机更好呢)]]></content>
      <categories>
        <category>诗和远方</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
</search>
